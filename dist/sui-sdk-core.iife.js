(function(){"use strict";const An="1.38.0",Ms="1.57.0",_s={"-32700":"ParseError","-32701":"OversizedRequest","-32702":"OversizedResponse","-32600":"InvalidRequest","-32601":"MethodNotFound","-32602":"InvalidParams","-32603":"InternalError","-32604":"ServerBusy","-32000":"CallExecutionFailed","-32001":"UnknownError","-32003":"SubscriptionClosed","-32004":"SubscriptionClosedWithError","-32005":"BatchesNotSupported","-32006":"TooManySubscriptions","-32050":"TransientError","-32002":"TransactionExecutionClientError"};class $n extends Error{}class xn extends $n{constructor(e,t){super(e),this.code=t,this.type=_s[t]??"ServerError"}}class Cs extends $n{constructor(e,t,r){super(e),this.status=t,this.statusText=r}}var Pn=n=>{throw TypeError(n)},Lt=(n,e,t)=>e.has(n)||Pn("Cannot "+t),_=(n,e,t)=>(Lt(n,e,"read from private field"),t?t.call(n):e.get(n)),xe=(n,e,t)=>e.has(n)?Pn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Ge=(n,e,t,r)=>(Lt(n,e,"write to private field"),e.set(n,t),t),Un=(n,e,t)=>(Lt(n,e,"access private method"),t),As=(n,e,t,r)=>({set _(s){Ge(n,e,s)},get _(){return _(n,e,r)}}),je,et,ye,Pe,tt,Ue,wt,Rn,Bn;function $s(n){const e=new URL(n);return e.protocol=e.protocol.replace("http","ws"),e.toString()}const xs={WebSocketConstructor:typeof WebSocket<"u"?WebSocket:void 0,callTimeout:3e4,reconnectTimeout:3e3,maxReconnects:5};class Ps{constructor(e,t={}){if(xe(this,wt),xe(this,je,0),xe(this,et,0),xe(this,ye,null),xe(this,Pe,null),xe(this,tt,new Set),xe(this,Ue,new Map),this.endpoint=e,this.options={...xs,...t},!this.options.WebSocketConstructor)throw new Error("Missing WebSocket constructor");this.endpoint.startsWith("http")&&(this.endpoint=$s(this.endpoint))}async makeRequest(e,t,r){const s=await Un(this,wt,Rn).call(this);return new Promise((i,a)=>{Ge(this,je,_(this,je)+1),_(this,Ue).set(_(this,je),{resolve:i,reject:a,timeout:setTimeout(()=>{_(this,Ue).delete(_(this,je)),a(new Error(`Request timeout: ${e}`))},this.options.callTimeout)}),r?.addEventListener("abort",()=>{_(this,Ue).delete(_(this,je)),a(r.reason)}),s.send(JSON.stringify({jsonrpc:"2.0",id:_(this,je),method:e,params:t}))}).then(({error:i,result:a})=>{if(i)throw new xn(i.message,i.code);return a})}async subscribe(e){const t=new Us(e);return _(this,tt).add(t),await t.subscribe(this),()=>t.unsubscribe(this)}}je=new WeakMap,et=new WeakMap,ye=new WeakMap,Pe=new WeakMap,tt=new WeakMap,Ue=new WeakMap,wt=new WeakSet,Rn=function(){return _(this,Pe)?_(this,Pe):(Ge(this,Pe,new Promise(n=>{_(this,ye)?.close(),Ge(this,ye,new this.options.WebSocketConstructor(this.endpoint)),_(this,ye).addEventListener("open",()=>{Ge(this,et,0),n(_(this,ye))}),_(this,ye).addEventListener("close",()=>{As(this,et)._++,_(this,et)<=this.options.maxReconnects&&setTimeout(()=>{Un(this,wt,Bn).call(this)},this.options.reconnectTimeout)}),_(this,ye).addEventListener("message",({data:e})=>{let t;try{t=JSON.parse(e)}catch(r){console.error(new Error(`Failed to parse RPC message: ${e}`,{cause:r}));return}if("id"in t&&t.id!=null&&_(this,Ue).has(t.id)){const{resolve:r,timeout:s}=_(this,Ue).get(t.id);clearTimeout(s),r(t)}else if("params"in t){const{params:r}=t;_(this,tt).forEach(s=>{s.subscriptionId===r.subscription&&r.subscription===s.subscriptionId&&s.onMessage(r.result)})}})})),_(this,Pe))},Bn=async function(){return _(this,ye)?.close(),Ge(this,Pe,null),Promise.allSettled([..._(this,tt)].map(n=>n.subscribe(this)))};class Us{constructor(e){this.subscriptionId=null,this.subscribed=!1,this.input=e}onMessage(e){this.subscribed&&this.input.onMessage(e)}async unsubscribe(e){const{subscriptionId:t}=this;return this.subscribed=!1,t==null?!1:(this.subscriptionId=null,e.makeRequest(this.input.unsubscribe,[t]))}async subscribe(e){this.subscriptionId=null,this.subscribed=!0;const t=await e.makeRequest(this.input.method,this.input.params,this.input.signal);this.subscribed&&(this.subscriptionId=t)}}var Dn=n=>{throw TypeError(n)},Wt=(n,e,t)=>e.has(n)||Dn("Cannot "+t),Q=(n,e,t)=>(Wt(n,e,"read from private field"),t?t.call(n):e.get(n)),vt=(n,e,t)=>e.has(n)?Dn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Gt=(n,e,t,r)=>(Wt(n,e,"write to private field"),e.set(n,t),t),Rs=(n,e,t)=>(Wt(n,e,"access private method"),t),nt,se,rt,Kt,Nn;class Bs{constructor(e){vt(this,Kt),vt(this,nt,0),vt(this,se),vt(this,rt),Gt(this,se,e)}fetch(e,t){const r=Q(this,se).fetch??fetch;if(!r)throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");return r(e,t)}async request(e){Gt(this,nt,Q(this,nt)+1);const t=await this.fetch(Q(this,se).rpc?.url??Q(this,se).url,{method:"POST",signal:e.signal,headers:{"Content-Type":"application/json","Client-Sdk-Type":"typescript","Client-Sdk-Version":An,"Client-Target-Api-Version":Ms,"Client-Request-Method":e.method,...Q(this,se).rpc?.headers},body:JSON.stringify({jsonrpc:"2.0",id:Q(this,nt),method:e.method,params:e.params})});if(!t.ok)throw new Cs(`Unexpected status code: ${t.status}`,t.status,t.statusText);const r=await t.json();if("error"in r&&r.error!=null)throw new xn(r.error.message,r.error.code);return r.result}async subscribe(e){const t=await Rs(this,Kt,Nn).call(this).subscribe(e);return e.signal&&(e.signal.throwIfAborted(),e.signal.addEventListener("abort",()=>{t()})),async()=>!!await t()}}nt=new WeakMap,se=new WeakMap,rt=new WeakMap,Kt=new WeakSet,Nn=function(){if(!Q(this,rt)){const n=Q(this,se).WebSocketConstructor??WebSocket;if(!n)throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");Gt(this,rt,new Ps(Q(this,se).websocket?.url??Q(this,se).url,{WebSocketConstructor:n,...Q(this,se).websocket}))}return Q(this,rt)};function Ds(n){switch(n){case"mainnet":return"https://fullnode.mainnet.sui.io:443";case"testnet":return"https://fullnode.testnet.sui.io:443";case"devnet":return"https://fullnode.devnet.sui.io:443";case"localnet":return"http://127.0.0.1:9000";default:throw new Error(`Unknown network: ${n}`)}}/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ns(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function Vn(n,e){return Array.isArray(e)?e.length===0?!0:n?e.every(t=>typeof t=="string"):e.every(t=>Number.isSafeInteger(t)):!1}function qt(n,e){if(typeof e!="string")throw new Error(`${n}: string expected`);return!0}function zn(n){if(!Number.isSafeInteger(n))throw new Error(`invalid integer: ${n}`)}function Ht(n){if(!Array.isArray(n))throw new Error("array expected")}function Fn(n,e){if(!Vn(!0,e))throw new Error(`${n}: array of strings expected`)}function Vs(n,e){if(!Vn(!1,e))throw new Error(`${n}: array of numbers expected`)}function zs(...n){const e=i=>i,t=(i,a)=>c=>i(a(c)),r=n.map(i=>i.encode).reduceRight(t,e),s=n.map(i=>i.decode).reduce(t,e);return{encode:r,decode:s}}function Fs(n){const e=typeof n=="string"?n.split(""):n,t=e.length;Fn("alphabet",e);const r=new Map(e.map((s,i)=>[s,i]));return{encode:s=>(Ht(s),s.map(i=>{if(!Number.isSafeInteger(i)||i<0||i>=t)throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${n}`);return e[i]})),decode:s=>(Ht(s),s.map(i=>{qt("alphabet.decode",i);const a=r.get(i);if(a===void 0)throw new Error(`Unknown letter: "${i}". Allowed: ${n}`);return a}))}}function Ls(n=""){return qt("join",n),{encode:e=>(Fn("join.decode",e),e.join(n)),decode:e=>(qt("join.decode",e),e.split(n))}}function Ln(n,e,t){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(t<2)throw new Error(`convertRadix: invalid to=${t}, base cannot be less than 2`);if(Ht(n),!n.length)return[];let r=0;const s=[],i=Array.from(n,c=>{if(zn(c),c<0||c>=e)throw new Error(`invalid integer: ${c}`);return c}),a=i.length;for(;;){let c=0,u=!0;for(let h=r;h<a;h++){const l=i[h],g=e*c,v=g+l;if(!Number.isSafeInteger(v)||g/e!==c||v-l!==g)throw new Error("convertRadix: carry overflow");const I=v/t;c=v%t;const k=Math.floor(I);if(i[h]=k,!Number.isSafeInteger(k)||k*t+c!==v)throw new Error("convertRadix: carry overflow");if(u)k?u=!1:r=h;else continue}if(s.push(c),u)break}for(let c=0;c<n.length-1&&n[c]===0;c++)s.push(0);return s.reverse()}function Ws(n){zn(n);const e=2**8;return{encode:t=>{if(!Ns(t))throw new Error("radix.encode input should be Uint8Array");return Ln(Array.from(t),e,n)},decode:t=>(Vs("radix.decode",t),Uint8Array.from(Ln(t,n,e)))}}const Wn=(n=>zs(Ws(58),Fs(n),Ls("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),St=n=>Wn.encode(n),st=n=>Wn.decode(n);function H(n){return Uint8Array.from(atob(n),e=>e.charCodeAt(0))}const Jt=8192;function z(n){if(n.length<Jt)return btoa(String.fromCharCode(...n));let e="";for(var t=0;t<n.length;t+=Jt){const r=n.slice(t,t+Jt);e+=String.fromCharCode(...r)}return btoa(e)}function Gn(n){const e=n.startsWith("0x")?n.slice(2):n,t=e.length%2===0?e:`0${e}`,r=t.match(/[0-9a-fA-F]{2}/g)?.map(s=>parseInt(s,16))??[];if(r.length!==t.length/2)throw new Error(`Invalid hex string ${n}`);return Uint8Array.from(r)}function Ke(n){return n.reduce((e,t)=>e+t.toString(16).padStart(2,"0"),"")}function kt(n,e){return Array.from({length:Math.ceil(n.length/e)},(t,r)=>n.slice(r*e,(r+1)*e))}class Kn{constructor(e,t){if(typeof e!="function")throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${e}.`);this._batchLoadFn=e,this._maxBatchSize=Hs(t),this._batchScheduleFn=Js(t),this._cacheKeyFn=Xs(t),this._cacheMap=Zs(t),this._batch=null,this.name=Ys(t)}load(e){if(e==null)throw new TypeError(`The loader.load() function must be called with a value, but got: ${String(e)}.`);const t=Ks(this),r=this._cacheMap;let s;if(r){s=this._cacheKeyFn(e);const a=r.get(s);if(a){const c=t.cacheHits||(t.cacheHits=[]);return new Promise(u=>{c.push(()=>{u(a)})})}}t.keys.push(e);const i=new Promise((a,c)=>{t.callbacks.push({resolve:a,reject:c})});return r&&r.set(s,i),i}loadMany(e){if(!qn(e))throw new TypeError(`The loader.loadMany() function must be called with Array<key>, but got: ${e}.`);const t=[];for(let r=0;r<e.length;r++)t.push(this.load(e[r]).catch(s=>s));return Promise.all(t)}clear(e){const t=this._cacheMap;if(t){const r=this._cacheKeyFn(e);t.delete(r)}return this}clearAll(){const e=this._cacheMap;return e&&e.clear(),this}prime(e,t){const r=this._cacheMap;if(r){const s=this._cacheKeyFn(e);if(r.get(s)===void 0){let i;t instanceof Error?(i=Promise.reject(t),i.catch(()=>{})):i=Promise.resolve(t),r.set(s,i)}}return this}}const Gs=typeof process=="object"&&typeof process.nextTick=="function"?function(n){Xt||(Xt=Promise.resolve()),Xt.then(()=>{process.nextTick(n)})}:typeof setImmediate=="function"?function(n){setImmediate(n)}:function(n){setTimeout(n)};let Xt;function Ks(n){const e=n._batch;if(e!==null&&!e.hasDispatched&&e.keys.length<n._maxBatchSize)return e;const t={hasDispatched:!1,keys:[],callbacks:[]};return n._batch=t,n._batchScheduleFn(()=>{qs(n,t)}),t}function qs(n,e){if(e.hasDispatched=!0,e.keys.length===0){Yt(e);return}let t;try{t=n._batchLoadFn(e.keys)}catch(r){return Zt(n,e,new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(r)}.`))}if(!t||typeof t.then!="function")return Zt(n,e,new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(t)}.`));Promise.resolve(t).then(r=>{if(!qn(r))throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(r)}.`);if(r.length!==e.keys.length)throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.

Keys:
${String(e.keys)}

Values:
${String(r)}`);Yt(e);for(let s=0;s<e.callbacks.length;s++){const i=r[s];i instanceof Error?e.callbacks[s].reject(i):e.callbacks[s].resolve(i)}}).catch(r=>{Zt(n,e,r)})}function Zt(n,e,t){Yt(e);for(let r=0;r<e.keys.length;r++)n.clear(e.keys[r]),e.callbacks[r].reject(t)}function Yt(n){if(n.cacheHits)for(let e=0;e<n.cacheHits.length;e++)n.cacheHits[e]()}function Hs(n){if(!(!n||n.batch!==!1))return 1;const t=n&&n.maxBatchSize;if(t===void 0)return 1/0;if(typeof t!="number"||t<1)throw new TypeError(`maxBatchSize must be a positive number: ${t}`);return t}function Js(n){const e=n&&n.batchScheduleFn;if(e===void 0)return Gs;if(typeof e!="function")throw new TypeError(`batchScheduleFn must be a function: ${e}`);return e}function Xs(n){const e=n&&n.cacheKeyFn;if(e===void 0)return t=>t;if(typeof e!="function")throw new TypeError(`cacheKeyFn must be a function: ${e}`);return e}function Zs(n){if(!(!n||n.cache!==!1))return null;const t=n&&n.cacheMap;if(t===void 0)return new Map;if(t!==null){const s=["get","set","delete","clear"].filter(i=>t&&typeof t[i]!="function");if(s.length!==0)throw new TypeError("Custom cacheMap missing methods: "+s.join(", "))}return t}function Ys(n){return n&&n.name?n.name:null}function qn(n){return typeof n=="object"&&n!==null&&"length"in n&&typeof n.length=="number"&&(n.length===0||n.length>0&&Object.prototype.hasOwnProperty.call(n,n.length-1))}function Ot(n){const e=[];let t=0;if(n===0)return[0];for(;n>0;)e[t]=n&127,(n>>=7)&&(e[t]|=128),t+=1;return e}function Qs(n){let e=0,t=0,r=0;for(;;){const s=n[r];if(r+=1,e|=(s&127)<<t,(s&128)===0)break;t+=7}return{value:e,length:r}}class ei{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength)}shift(e){return this.bytePosition+=e,this}read8(){const e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){const e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){const e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){const e=this.read32(),r=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+r).toString(10)}read128(){const e=BigInt(this.read64()),r=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+r).toString(10)}read256(){const e=BigInt(this.read128()),r=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+r).toString(10)}readBytes(e){const t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){const e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:s}=Qs(t);return this.shift(s),r}readVec(e){const t=this.readULEB(),r=[];for(let s=0;s<t;s++)r.push(e(this,s,t));return r}}function ti(n,e){switch(e){case"base58":return St(n);case"base64":return z(n);case"hex":return Ke(n);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function Hn(n,e=["<",">"]){const[t,r]=e,s=[];let i="",a=0;for(let c=0;c<n.length;c++){const u=n[c];if(u===t&&a++,u===r&&a--,a===0&&u===","){s.push(i.trim()),i="";continue}i+=u}return s.push(i.trim()),s}class ni{constructor({initialSize:e=1024,maxSize:t=1/0,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=t,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const r=Math.min(this.maxSize,this.size+this.allocateSize);if(t>r)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=r;const s=new ArrayBuffer(this.size);new Uint8Array(s).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(s)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return Qt(BigInt(e),8).forEach(t=>this.write8(t)),this}write128(e){return Qt(BigInt(e),16).forEach(t=>this.write8(t)),this}write256(e){return Qt(BigInt(e),32).forEach(t=>this.write8(t)),this}writeULEB(e){return Ot(e).forEach(t=>this.write8(t)),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach((r,s)=>t(this,r,s,e.length)),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return ti(this.toBytes(),e)}}function Qt(n,e){const t=new Uint8Array(e);let r=0;for(;n>0;)t[r]=Number(n%BigInt(256)),n=n/BigInt(256),r+=1;return t}var Jn=n=>{throw TypeError(n)},Xn=(n,e,t)=>e.has(n)||Jn("Cannot "+t),ie=(n,e,t)=>(Xn(n,e,"read from private field"),t?t.call(n):e.get(n)),Et=(n,e,t)=>e.has(n)?Jn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),jt=(n,e,t,r)=>(Xn(n,e,"write to private field"),e.set(n,t),t),qe,it,Tt,Te;const ri=class Ts{constructor(e){Et(this,qe),Et(this,it),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),jt(this,qe,e.write),jt(this,it,e.serialize??((t,r)=>{const s=new ni({initialSize:this.serializedSize(t)??void 0,...r});return ie(this,qe).call(this,t,s),s.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),ie(this,qe).call(this,e,t)}serialize(e,t){return this.validate(e),new si(this,ie(this,it).call(this,e,t))}parse(e){const t=new ei(e);return this.read(t)}fromHex(e){return this.parse(Gn(e))}fromBase58(e){return this.parse(st(e))}fromBase64(e){return this.parse(H(e))}transform({name:e,input:t,output:r,validate:s}){return new Ts({name:e??this.name,read:i=>r?r(this.read(i)):this.read(i),write:(i,a)=>ie(this,qe).call(this,t?t(i):i,a),serializedSize:i=>this.serializedSize(t?t(i):i),serialize:(i,a)=>ie(this,it).call(this,t?t(i):i,a),validate:i=>{s?.(i),this.validate(t?t(i):i)}})}};qe=new WeakMap,it=new WeakMap;let he=ri;const Zn=Symbol.for("@mysten/serialized-bcs");function en(n){return!!n&&typeof n=="object"&&n[Zn]===!0}class si{constructor(e,t){Et(this,Tt),Et(this,Te),jt(this,Tt,e),jt(this,Te,t)}get[Zn](){return!0}toBytes(){return ie(this,Te)}toHex(){return Ke(ie(this,Te))}toBase64(){return z(ie(this,Te))}toBase58(){return St(ie(this,Te))}parse(){return ie(this,Tt).parse(ie(this,Te))}}Tt=new WeakMap,Te=new WeakMap;function It({size:n,...e}){return new he({...e,serializedSize:()=>n})}function tn({readMethod:n,writeMethod:e,...t}){return It({...t,read:r=>r[n](),write:(r,s)=>s[e](r),validate:r=>{if(r<0||r>t.maxValue)throw new TypeError(`Invalid ${t.name} value: ${r}. Expected value in range 0-${t.maxValue}`);t.validate?.(r)}})}function nn({readMethod:n,writeMethod:e,...t}){return It({...t,read:r=>r[n](),write:(r,s)=>s[e](BigInt(r)),validate:r=>{const s=BigInt(r);if(s<0||s>t.maxValue)throw new TypeError(`Invalid ${t.name} value: ${s}. Expected value in range 0-${t.maxValue}`);t.validate?.(s)}})}function ii({serialize:n,...e}){const t=new he({...e,serialize:n,write:(r,s)=>{for(const i of t.serialize(r).toBytes())s.write8(i)}});return t}function ai({toBytes:n,fromBytes:e,...t}){return new he({...t,read:r=>{const s=r.readULEB(),i=r.readBytes(s);return e(i)},write:(r,s)=>{const i=n(r);s.writeULEB(i.length);for(let a=0;a<i.length;a++)s.write8(i[a])},serialize:r=>{const s=n(r),i=Ot(s.length),a=new Uint8Array(i.length+s.length);return a.set(i,0),a.set(s,i.length),a},validate:r=>{if(typeof r!="string")throw new TypeError(`Invalid ${t.name} value: ${r}. Expected string`);t.validate?.(r)}})}function oi(n){let e=null;function t(){return e||(e=n()),e}return new he({name:"lazy",read:r=>t().read(r),serializedSize:r=>t().serializedSize(r),write:(r,s)=>t().write(r,s),serialize:(r,s)=>t().serialize(r,s).toBytes()})}class ci extends he{constructor({name:e,fields:t,...r}){const s=Object.entries(t);super({name:e,serializedSize:i=>{let a=0;for(const[c,u]of s){const h=u.serializedSize(i[c]);if(h==null)return null;a+=h}return a},read:i=>{const a={};for(const[c,u]of s)a[c]=u.read(i);return a},write:(i,a)=>{for(const[c,u]of s)u.write(i[c],a)},...r,validate:i=>{if(r?.validate?.(i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})}}class ui extends he{constructor({fields:e,...t}){const r=Object.entries(e);super({read:s=>{const i=s.readULEB(),a=r[i];if(!a)throw new TypeError(`Unknown value ${i} for enum ${name}`);const[c,u]=a;return{[c]:u?.read(s)??!0,$kind:c}},write:(s,i)=>{const[a,c]=Object.entries(s).filter(([u])=>Object.hasOwn(e,u))[0];for(let u=0;u<r.length;u++){const[h,l]=r[u];if(h===a){i.writeULEB(u),l?.write(c,i);return}}},...t,validate:s=>{if(t?.validate?.(s),typeof s!="object"||s==null)throw new TypeError(`Expected object, found ${typeof s}`);const i=Object.keys(s).filter(c=>s[c]!==void 0&&Object.hasOwn(e,c));if(i.length!==1)throw new TypeError(`Expected object with one key, but found ${i.length} for type ${name}}`);const[a]=i;if(!Object.hasOwn(e,a))throw new TypeError(`Invalid enum variant ${a}`)}})}}class li extends he{constructor({fields:e,name:t,...r}){super({name:t??`(${e.map(s=>s.name).join(", ")})`,serializedSize:s=>{let i=0;for(let a=0;a<e.length;a++){const c=e[a].serializedSize(s[a]);if(c==null)return null;i+=c}return i},read:s=>{const i=[];for(const a of e)i.push(a.read(s));return i},write:(s,i)=>{for(let a=0;a<e.length;a++)e[a].write(s[a],i)},...r,validate:s=>{if(r?.validate?.(s),!Array.isArray(s))throw new TypeError(`Expected array, found ${typeof s}`);if(s.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${s.length}`)}})}}function di(n,e,t){return new he({read:r=>{const s=new Array(n);for(let i=0;i<n;i++)s[i]=e.read(r);return s},write:(r,s)=>{for(const i of r)e.write(i,s)},...t,name:t?.name??`${e.name}[${n}]`,validate:r=>{if(t?.validate?.(r),!r||typeof r!="object"||!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==n)throw new TypeError(`Expected array of length ${n}, found ${r.length}`)}})}function hi(n){return o.enum(`Option<${n.name}>`,{None:null,Some:n}).transform({input:e=>e==null?{None:!0}:{Some:e},output:e=>e.$kind==="Some"?e.Some:null})}function pi(n,e){return new he({read:t=>{const r=t.readULEB(),s=new Array(r);for(let i=0;i<r;i++)s[i]=n.read(t);return s},write:(t,r)=>{r.writeULEB(t.length);for(const s of t)n.write(s,r)},...e,name:e?.name??`vector<${n.name}>`,validate:t=>{if(e?.validate?.(t),!t||typeof t!="object"||!("length"in t))throw new TypeError(`Expected array, found ${typeof t}`)}})}function fi(n,e){return o.vector(o.tuple([n,e])).transform({name:`Map<${n.name}, ${e.name}>`,input:t=>[...t.entries()],output:t=>{const r=new Map;for(const[s,i]of t)r.set(s,i);return r}})}const o={u8(n){return tn({readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...n,name:n?.name??"u8"})},u16(n){return tn({readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...n,name:n?.name??"u16"})},u32(n){return tn({readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...n,name:n?.name??"u32"})},u64(n){return nn({readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...n,name:n?.name??"u64"})},u128(n){return nn({readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...n,name:n?.name??"u128"})},u256(n){return nn({readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...n,name:n?.name??"u256"})},bool(n){return It({size:1,read:e=>e.read8()===1,write:(e,t)=>t.write8(e?1:0),...n,name:n?.name??"bool",validate:e=>{if(n?.validate?.(e),typeof e!="boolean")throw new TypeError(`Expected boolean, found ${typeof e}`)}})},uleb128(n){return ii({read:e=>e.readULEB(),serialize:e=>Uint8Array.from(Ot(e)),...n,name:n?.name??"uleb128"})},bytes(n,e){return It({size:n,read:t=>t.readBytes(n),write:(t,r)=>{const s=new Uint8Array(t);for(let i=0;i<n;i++)r.write8(s[i]??0)},...e,name:e?.name??`bytes[${n}]`,validate:t=>{if(e?.validate?.(t),!t||typeof t!="object"||!("length"in t))throw new TypeError(`Expected array, found ${typeof t}`);if(t.length!==n)throw new TypeError(`Expected array of length ${n}, found ${t.length}`)}})},byteVector(n){return new he({read:e=>{const t=e.readULEB();return e.readBytes(t)},write:(e,t)=>{const r=new Uint8Array(e);t.writeULEB(r.length);for(let s=0;s<r.length;s++)t.write8(r[s]??0)},...n,name:n?.name??"vector<u8>",serializedSize:e=>{const t="length"in e?e.length:null;return t==null?null:Ot(t).length+t},validate:e=>{if(n?.validate?.(e),!e||typeof e!="object"||!("length"in e))throw new TypeError(`Expected array, found ${typeof e}`)}})},string(n){return ai({toBytes:e=>new TextEncoder().encode(e),fromBytes:e=>new TextDecoder().decode(e),...n,name:n?.name??"string"})},fixedArray:di,option:hi,vector:pi,tuple(n,e){return new li({fields:n,...e})},struct(n,e,t){return new ci({name:n,fields:e,...t})},enum(n,e,t){return new ui({name:n,fields:e,...t})},map:fi,lazy(n){return oi(n)}};var Yn=n=>{throw TypeError(n)},Qn=(n,e,t)=>e.has(n)||Yn("Cannot "+t),F=(n,e,t)=>(Qn(n,e,"read from private field"),e.get(n)),er=(n,e,t)=>e.has(n)?Yn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),tr=(n,e,t,r)=>(Qn(n,e,"write to private field"),e.set(n,t),t),Re,W;const gi=class Is{constructor({prefix:e,cache:t}={}){er(this,Re),er(this,W),tr(this,Re,e??[]),tr(this,W,t??new Map)}read(e,t){const r=[F(this,Re),...e].join(":");if(F(this,W).has(r))return F(this,W).get(r);const s=t();return F(this,W).set(r,s),typeof s=="object"&&s!==null&&"then"in s?Promise.resolve(s).then(i=>(F(this,W).set(r,i),i)).catch(i=>{throw F(this,W).delete(r),i}):s}readSync(e,t){const r=[F(this,Re),...e].join(":");if(F(this,W).has(r))return F(this,W).get(r);const s=t();return F(this,W).set(r,s),s}clear(e){const t=[...F(this,Re),...e??[]].join(":");if(!t){F(this,W).clear();return}for(const r of F(this,W).keys())r.startsWith(t)&&F(this,W).delete(r)}scope(e){return new Is({prefix:[...F(this,Re),...Array.isArray(e)?e:[e]],cache:F(this,W)})}};Re=new WeakMap,W=new WeakMap;let mi=gi;class nr{constructor({network:e,base:t,cache:r=t?.cache??new mi}){this.network=e,this.base=t??this,this.cache=r}$extend(...e){return Object.create(this,Object.fromEntries(e.map(t=>{if("experimental_asClientExtension"in t){const{name:r,register:s}=t.experimental_asClientExtension();return[r,{value:s(this)}]}return[t.name,{value:t.register(this)}]})))}}const rr=/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i,sr=/^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i,yi=235;function bi(n){return n.length>yi?!1:n.includes("@")?rr.test(n):sr.test(n)}function wi(n,e="at"){const t=n.toLowerCase();let r;if(t.includes("@")){if(!rr.test(t))throw new Error(`Invalid SuiNS name ${n}`);const[s,i]=t.split("@");r=[...s?s.split("."):[],i]}else{if(!sr.test(t))throw new Error(`Invalid SuiNS name ${n}`);r=t.split(".").slice(0,-1)}return e==="dot"?`${r.join(".")}.sui`:`${r.slice(0,-1).join(".")}@${r[r.length-1]}`}const vi=/^([a-z0-9]+(?:-[a-z0-9]+)*)$/,Si=/^\d+$/,ki=64,ir="/",J=n=>{const e=n.split(ir);if(e.length<2||e.length>3)return!1;const[t,r,s]=e;return s!==void 0&&!Si.test(s)||!bi(t)?!1:vi.test(r)&&r.length<ki},Oi=n=>{const e=n.split(/::|<|>|,/);for(const t of e)if(t.includes(ir)&&!J(t))return!1;return!0},Ei=32;function ar(n){try{return st(n).length===Ei}catch{return!1}}const Mt=32;function ae(n){return Ti(n)&&Ii(n)===Mt}function _t(n){return ae(n)}function ji(n){return n.includes("::")?Be(n):n}function Be(n){const[e,t]=n.split("::"),r=J(e),s=n.slice(e.length+t.length+4),i=s.includes("<")?s.slice(0,s.indexOf("<")):s,a=s.includes("<")?Hn(s.slice(s.indexOf("<")+1,s.lastIndexOf(">"))).map(c=>ji(c.trim())):[];return{address:r?e:E(e),module:t,name:i,typeParams:a}}function Ct(n){const{address:e,module:t,name:r,typeParams:s}=typeof n=="string"?Be(n):n,i=s?.length>0?`<${s.map(a=>typeof a=="string"?a:Ct(a)).join(",")}>`:"";return`${e}::${t}::${r}${i}`}function E(n,e=!1){let t=n.toLowerCase();return!e&&t.startsWith("0x")&&(t=t.slice(2)),`0x${t.padStart(Mt*2,"0")}`}function be(n,e=!1){return E(n,e)}function Ti(n){return/^(0x|0X)?[a-fA-F0-9]+$/.test(n)&&n.length%2===0}function Ii(n){return/^(0x|0X)/.test(n)?(n.length-2)/2:n.length/2}const Mi=/^vector<(.+)>$/,_i=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class oe{static parseFromStr(e,t=!1){if(e==="address")return{address:null};if(e==="bool")return{bool:null};if(e==="u8")return{u8:null};if(e==="u16")return{u16:null};if(e==="u32")return{u32:null};if(e==="u64")return{u64:null};if(e==="u128")return{u128:null};if(e==="u256")return{u256:null};if(e==="signer")return{signer:null};const r=e.match(Mi);if(r)return{vector:oe.parseFromStr(r[1],t)};const s=e.match(_i);if(s)return{struct:{address:t?E(s[1]):s[1],module:s[2],name:s[3],typeParams:s[5]===void 0?[]:oe.parseStructTypeArgs(s[5],t)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,t=!1){return Hn(e).map(r=>oe.parseFromStr(r,t))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${oe.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(oe.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}function Ci(n){return o.u64({name:"unsafe_u64",...n}).transform({input:e=>e,output:e=>Number(e)})}function Ai(n){return o.enum("Option",{None:null,Some:n})}const M=o.bytes(Mt).transform({validate:n=>{const e=typeof n=="string"?n:Ke(n);if(!e||!ae(E(e)))throw new Error(`Invalid Sui address ${e}`)},input:n=>typeof n=="string"?Gn(E(n)):n,output:n=>E(Ke(n))}),ce=o.vector(o.u8()).transform({name:"ObjectDigest",input:n=>st(n),output:n=>St(new Uint8Array(n)),validate:n=>{if(st(n).length!==32)throw new Error("ObjectDigest must be 32 bytes")}}),ee=o.struct("SuiObjectRef",{objectId:M,version:o.u64(),digest:ce}),or=o.struct("SharedObjectRef",{objectId:M,initialSharedVersion:o.u64(),mutable:o.bool()}),cr=o.enum("ObjectArg",{ImmOrOwnedObject:ee,SharedObject:or,Receiving:ee}),De=o.enum("Owner",{AddressOwner:M,ObjectOwner:M,Shared:o.struct("Shared",{initialSharedVersion:o.u64()}),Immutable:null,ConsensusAddressOwner:o.struct("ConsensusAddressOwner",{owner:M,startVersion:o.u64()})}),ur=o.enum("CallArg",{Pure:o.struct("Pure",{bytes:o.vector(o.u8()).transform({input:n=>typeof n=="string"?H(n):n,output:n=>z(new Uint8Array(n))})}),Object:cr}),rn=o.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:o.lazy(()=>rn),struct:o.lazy(()=>gr),u16:null,u32:null,u256:null}),sn=rn.transform({input:n=>typeof n=="string"?oe.parseFromStr(n,!0):n,output:n=>oe.tagToString(n)}),pe=o.enum("Argument",{GasCoin:null,Input:o.u16(),Result:o.u16(),NestedResult:o.tuple([o.u16(),o.u16()])}),lr=o.struct("ProgrammableMoveCall",{package:M,module:o.string(),function:o.string(),typeArguments:o.vector(sn),arguments:o.vector(pe)}),dr=o.enum("Command",{MoveCall:lr,TransferObjects:o.struct("TransferObjects",{objects:o.vector(pe),address:pe}),SplitCoins:o.struct("SplitCoins",{coin:pe,amounts:o.vector(pe)}),MergeCoins:o.struct("MergeCoins",{destination:pe,sources:o.vector(pe)}),Publish:o.struct("Publish",{modules:o.vector(o.vector(o.u8()).transform({input:n=>typeof n=="string"?H(n):n,output:n=>z(new Uint8Array(n))})),dependencies:o.vector(M)}),MakeMoveVec:o.struct("MakeMoveVec",{type:Ai(sn).transform({input:n=>n===null?{None:!0}:{Some:n},output:n=>n.Some??null}),elements:o.vector(pe)}),Upgrade:o.struct("Upgrade",{modules:o.vector(o.vector(o.u8()).transform({input:n=>typeof n=="string"?H(n):n,output:n=>z(new Uint8Array(n))})),dependencies:o.vector(M),package:M,ticket:pe})}),hr=o.struct("ProgrammableTransaction",{inputs:o.vector(ur),commands:o.vector(dr)}),pr=o.enum("TransactionKind",{ProgrammableTransaction:hr,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),fr=o.enum("TransactionExpiration",{None:null,Epoch:Ci()}),gr=o.struct("StructTag",{address:M,module:o.string(),name:o.string(),typeParams:o.vector(rn)}),mr=o.struct("GasData",{payment:o.vector(ee),owner:M,price:o.u64(),budget:o.u64()}),yr=o.struct("TransactionDataV1",{kind:pr,sender:M,gasData:mr,expiration:fr}),br=o.enum("TransactionData",{V1:yr}),wr=o.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),vr=o.enum("IntentVersion",{V0:null}),Sr=o.enum("AppId",{Sui:null}),kr=o.struct("Intent",{scope:wr,version:vr,appId:Sr});function Or(n){return o.struct(`IntentMessage<${n.name}>`,{intent:kr,value:n})}const Er=o.enum("CompressedSignature",{ED25519:o.fixedArray(64,o.u8()),Secp256k1:o.fixedArray(64,o.u8()),Secp256r1:o.fixedArray(64,o.u8()),ZkLogin:o.vector(o.u8()),Passkey:o.vector(o.u8())}),jr=o.enum("PublicKey",{ED25519:o.fixedArray(32,o.u8()),Secp256k1:o.fixedArray(33,o.u8()),Secp256r1:o.fixedArray(33,o.u8()),ZkLogin:o.vector(o.u8()),Passkey:o.fixedArray(33,o.u8())}),Tr=o.struct("MultiSigPkMap",{pubKey:jr,weight:o.u8()}),Ir=o.struct("MultiSigPublicKey",{pk_map:o.vector(Tr),threshold:o.u16()}),$i=o.struct("MultiSig",{sigs:o.vector(Er),bitmap:o.u16(),multisig_pk:Ir}),xi=o.vector(o.u8()).transform({input:n=>typeof n=="string"?H(n):n,output:n=>z(new Uint8Array(n))}),Mr=o.struct("SenderSignedTransaction",{intentMessage:Or(br),txSignatures:o.vector(xi)}),Pi=o.vector(Mr,{name:"SenderSignedData"}),Ui=o.struct("PasskeyAuthenticator",{authenticatorData:o.vector(o.u8()),clientDataJson:o.string(),userSignature:o.vector(o.u8())}),Ri=o.enum("PackageUpgradeError",{UnableToFetchPackage:o.struct("UnableToFetchPackage",{packageId:M}),NotAPackage:o.struct("NotAPackage",{objectId:M}),IncompatibleUpgrade:null,DigestDoesNotMatch:o.struct("DigestDoesNotMatch",{digest:o.vector(o.u8())}),UnknownUpgradePolicy:o.struct("UnknownUpgradePolicy",{policy:o.u8()}),PackageIDDoesNotMatch:o.struct("PackageIDDoesNotMatch",{packageId:M,ticketId:M})}),Bi=o.struct("ModuleId",{address:M,name:o.string()}),_r=o.struct("MoveLocation",{module:Bi,function:o.u16(),instruction:o.u16(),functionName:o.option(o.string())}),Di=o.enum("CommandArgumentError",{TypeMismatch:null,InvalidBCSBytes:null,InvalidUsageOfPureArg:null,InvalidArgumentToPrivateEntryFunction:null,IndexOutOfBounds:o.struct("IndexOutOfBounds",{idx:o.u16()}),SecondaryIndexOutOfBounds:o.struct("SecondaryIndexOutOfBounds",{resultIdx:o.u16(),secondaryIdx:o.u16()}),InvalidResultArity:o.struct("InvalidResultArity",{resultIdx:o.u16()}),InvalidGasCoinUsage:null,InvalidValueUsage:null,InvalidObjectByValue:null,InvalidObjectByMutRef:null,SharedObjectOperationNotAllowed:null}),Ni=o.enum("TypeArgumentError",{TypeNotFound:null,ConstraintNotSatisfied:null}),Vi=o.enum("ExecutionFailureStatus",{InsufficientGas:null,InvalidGasObject:null,InvariantViolation:null,FeatureNotYetSupported:null,MoveObjectTooBig:o.struct("MoveObjectTooBig",{objectSize:o.u64(),maxObjectSize:o.u64()}),MovePackageTooBig:o.struct("MovePackageTooBig",{objectSize:o.u64(),maxObjectSize:o.u64()}),CircularObjectOwnership:o.struct("CircularObjectOwnership",{object:M}),InsufficientCoinBalance:null,CoinBalanceOverflow:null,PublishErrorNonZeroAddress:null,SuiMoveVerificationError:null,MovePrimitiveRuntimeError:o.option(_r),MoveAbort:o.tuple([_r,o.u64()]),VMVerificationOrDeserializationError:null,VMInvariantViolation:null,FunctionNotFound:null,ArityMismatch:null,TypeArityMismatch:null,NonEntryFunctionInvoked:null,CommandArgumentError:o.struct("CommandArgumentError",{argIdx:o.u16(),kind:Di}),TypeArgumentError:o.struct("TypeArgumentError",{argumentIdx:o.u16(),kind:Ni}),UnusedValueWithoutDrop:o.struct("UnusedValueWithoutDrop",{resultIdx:o.u16(),secondaryIdx:o.u16()}),InvalidPublicFunctionReturnType:o.struct("InvalidPublicFunctionReturnType",{idx:o.u16()}),InvalidTransferObject:null,EffectsTooLarge:o.struct("EffectsTooLarge",{currentSize:o.u64(),maxSize:o.u64()}),PublishUpgradeMissingDependency:null,PublishUpgradeDependencyDowngrade:null,PackageUpgradeError:o.struct("PackageUpgradeError",{upgradeError:Ri}),WrittenObjectsTooLarge:o.struct("WrittenObjectsTooLarge",{currentSize:o.u64(),maxSize:o.u64()}),CertificateDenied:null,SuiMoveVerificationTimedout:null,SharedObjectOperationNotAllowed:null,InputObjectDeleted:null,ExecutionCancelledDueToSharedObjectCongestion:o.struct("ExecutionCancelledDueToSharedObjectCongestion",{congestedObjects:o.vector(M)}),AddressDeniedForCoin:o.struct("AddressDeniedForCoin",{address:M,coinType:o.string()}),CoinTypeGlobalPause:o.struct("CoinTypeGlobalPause",{coinType:o.string()}),ExecutionCancelledDueToRandomnessUnavailable:null}),Cr=o.enum("ExecutionStatus",{Success:null,Failed:o.struct("ExecutionFailed",{error:Vi,command:o.option(o.u64())})}),Ar=o.struct("GasCostSummary",{computationCost:o.u64(),storageCost:o.u64(),storageRebate:o.u64(),nonRefundableStorageFee:o.u64()}),zi=o.struct("TransactionEffectsV1",{status:Cr,executedEpoch:o.u64(),gasUsed:Ar,modifiedAtVersions:o.vector(o.tuple([M,o.u64()])),sharedObjects:o.vector(ee),transactionDigest:ce,created:o.vector(o.tuple([ee,De])),mutated:o.vector(o.tuple([ee,De])),unwrapped:o.vector(o.tuple([ee,De])),deleted:o.vector(ee),unwrappedThenDeleted:o.vector(ee),wrapped:o.vector(ee),gasObject:o.tuple([ee,De]),eventsDigest:o.option(ce),dependencies:o.vector(ce)}),an=o.tuple([o.u64(),ce]),Fi=o.enum("ObjectIn",{NotExist:null,Exist:o.tuple([an,De])}),Li=o.enum("ObjectOut",{NotExist:null,ObjectWrite:o.tuple([ce,De]),PackageWrite:an}),Wi=o.enum("IDOperation",{None:null,Created:null,Deleted:null}),Gi=o.struct("EffectsObjectChange",{inputState:Fi,outputState:Li,idOperation:Wi}),Ki=o.enum("UnchangedSharedKind",{ReadOnlyRoot:an,MutateDeleted:o.u64(),ReadDeleted:o.u64(),Cancelled:o.u64(),PerEpochConfig:null}),qi=o.struct("TransactionEffectsV2",{status:Cr,executedEpoch:o.u64(),gasUsed:Ar,transactionDigest:ce,gasObjectIndex:o.option(o.u32()),eventsDigest:o.option(ce),dependencies:o.vector(ce),lamportVersion:o.u64(),changedObjects:o.vector(o.tuple([M,Gi])),unchangedSharedObjects:o.vector(o.tuple([M,Ki])),auxDataDigest:o.option(ce)}),Hi=o.enum("TransactionEffects",{V1:zi,V2:qi});function at(n){switch(n){case"u8":return o.u8();case"u16":return o.u16();case"u32":return o.u32();case"u64":return o.u64();case"u128":return o.u128();case"u256":return o.u256();case"bool":return o.bool();case"string":return o.string();case"id":case"address":return M}const e=n.match(/^(vector|option)<(.+)>$/);if(e){const[t,r]=e.slice(1);return t==="vector"?o.vector(at(r)):o.option(at(r))}throw new Error(`Invalid Pure type name: ${n}`)}const w={...o,U8:o.u8(),U16:o.u16(),U32:o.u32(),U64:o.u64(),U128:o.u128(),U256:o.u256(),ULEB128:o.uleb128(),Bool:o.bool(),String:o.string(),Address:M,AppId:Sr,Argument:pe,CallArg:ur,Command:dr,CompressedSignature:Er,GasData:mr,Intent:kr,IntentMessage:Or,IntentScope:wr,IntentVersion:vr,MultiSig:$i,MultiSigPkMap:Tr,MultiSigPublicKey:Ir,ObjectArg:cr,ObjectDigest:ce,Owner:De,PasskeyAuthenticator:Ui,ProgrammableMoveCall:lr,ProgrammableTransaction:hr,PublicKey:jr,SenderSignedData:Pi,SenderSignedTransaction:Mr,SharedObjectRef:or,StructTag:gr,SuiObjectRef:ee,TransactionData:br,TransactionDataV1:yr,TransactionEffects:Hi,TransactionExpiration:fr,TransactionKind:pr,TypeTag:sn};var on;function Ji(n){return{lang:n?.lang??on?.lang,message:n?.message,abortEarly:n?.abortEarly??on?.abortEarly,abortPipeEarly:n?.abortPipeEarly??on?.abortPipeEarly}}var Xi;function Zi(n){return Xi?.get(n)}var Yi;function Qi(n){return Yi?.get(n)}var ea;function ta(n,e){return ea?.get(n)?.get(e)}function $r(n){const e=typeof n;return e==="string"?`"${n}"`:e==="number"||e==="bigint"||e==="boolean"?`${n}`:e==="object"||e==="function"?(n&&Object.getPrototypeOf(n)?.constructor?.name)??"null":e}function X(n,e,t,r,s){const i=s&&"input"in s?s.input:t.value,a=s?.expected??n.expects??null,c=s?.received??$r(i),u={kind:n.kind,type:n.type,input:i,expected:a,received:c,message:`Invalid ${e}: ${a?`Expected ${a} but r`:"R"}eceived ${c}`,requirement:n.requirement,path:s?.path,issues:s?.issues,lang:r.lang,abortEarly:r.abortEarly,abortPipeEarly:r.abortPipeEarly},h=n.kind==="schema",l=s?.message??n.message??ta(n.reference,u.lang)??(h?Qi(u.lang):null)??r.message??Zi(u.lang);l&&(u.message=typeof l=="function"?l(u):l),h&&(t.typed=!1),t.issues?t.issues.push(u):t.issues=[u]}function na(n,e){return Object.hasOwn(n,e)&&e!=="__proto__"&&e!=="prototype"&&e!=="constructor"}var ra=class extends Error{issues;constructor(n){super(n[0].message),this.name="ValiError",this.issues=n}};function ot(n,e){return{kind:"validation",type:"check",reference:ot,async:!1,expects:null,requirement:n,message:e,_run(t,r){return t.typed&&!this.requirement(t.value)&&X(this,"input",t,r),t}}}function x(n){return{kind:"validation",type:"integer",reference:x,async:!1,expects:null,requirement:Number.isInteger,message:n,_run(e,t){return e.typed&&!this.requirement(e.value)&&X(this,"integer",e,t),e}}}function At(n){return{kind:"transformation",type:"transform",reference:At,async:!1,operation:n,_run(e){return e.value=this.operation(e.value),e}}}function cn(n,e,t){return typeof n.default=="function"?n.default(e,t):n.default}function un(n,e){return!n._run({typed:!1,value:e},{abortEarly:!0}).issues}function y(n,e){return{kind:"schema",type:"array",reference:y,expects:"Array",async:!1,item:n,message:e,_run(t,r){const s=t.value;if(Array.isArray(s)){t.typed=!0,t.value=[];for(let i=0;i<s.length;i++){const a=s[i],c=this.item._run({typed:!1,value:a},r);if(c.issues){const u={type:"array",origin:"value",input:s,key:i,value:a};for(const h of c.issues)h.path?h.path.unshift(u):h.path=[u],t.issues?.push(h);if(t.issues||(t.issues=c.issues),r.abortEarly){t.typed=!1;break}}c.typed||(t.typed=!1),t.value.push(c.value)}}else X(this,"type",t,r);return t}}}function ln(n){return{kind:"schema",type:"bigint",reference:ln,expects:"bigint",async:!1,message:n,_run(e,t){return typeof e.value=="bigint"?e.typed=!0:X(this,"type",e,t),e}}}function He(n){return{kind:"schema",type:"boolean",reference:He,expects:"boolean",async:!1,message:n,_run(e,t){return typeof e.value=="boolean"?e.typed=!0:X(this,"type",e,t),e}}}function ct(n){return{kind:"schema",type:"lazy",reference:ct,expects:"unknown",async:!1,getter:n,_run(e,t){return this.getter(e.value)._run(e,t)}}}function b(n,e){return{kind:"schema",type:"literal",reference:b,expects:$r(n),async:!1,literal:n,message:e,_run(t,r){return t.value===this.literal?t.typed=!0:X(this,"type",t,r),t}}}function O(n,...e){const t={kind:"schema",type:"nullable",reference:O,expects:`${n.expects} | null`,async:!1,wrapped:n,_run(r,s){return r.value===null&&("default"in this&&(r.value=cn(this,r,s)),r.value===null)?(r.typed=!0,r):this.wrapped._run(r,s)}};return 0 in e&&(t.default=e[0]),t}function Je(n,...e){const t={kind:"schema",type:"nullish",reference:Je,expects:`${n.expects} | null | undefined`,async:!1,wrapped:n,_run(r,s){return(r.value===null||r.value===void 0)&&("default"in this&&(r.value=cn(this,r,s)),r.value===null||r.value===void 0)?(r.typed=!0,r):this.wrapped._run(r,s)}};return 0 in e&&(t.default=e[0]),t}function $(n){return{kind:"schema",type:"number",reference:$,expects:"number",async:!1,message:n,_run(e,t){return typeof e.value=="number"&&!isNaN(e.value)?e.typed=!0:X(this,"type",e,t),e}}}function p(n,e){return{kind:"schema",type:"object",reference:p,expects:"Object",async:!1,entries:n,message:e,_run(t,r){const s=t.value;if(s&&typeof s=="object"){t.typed=!0,t.value={};for(const i in this.entries){const a=s[i],c=this.entries[i]._run({typed:!1,value:a},r);if(c.issues){const u={type:"object",origin:"value",input:s,key:i,value:a};for(const h of c.issues)h.path?h.path.unshift(u):h.path=[u],t.issues?.push(h);if(t.issues||(t.issues=c.issues),r.abortEarly){t.typed=!1;break}}c.typed||(t.typed=!1),(c.value!==void 0||i in s)&&(t.value[i]=c.value)}}else X(this,"type",t,r);return t}}}function R(n,...e){const t={kind:"schema",type:"optional",reference:R,expects:`${n.expects} | undefined`,async:!1,wrapped:n,_run(r,s){return r.value===void 0&&("default"in this&&(r.value=cn(this,r,s)),r.value===void 0)?(r.typed=!0,r):this.wrapped._run(r,s)}};return 0 in e&&(t.default=e[0]),t}function ut(n,e,t){return{kind:"schema",type:"record",reference:ut,expects:"Object",async:!1,key:n,value:e,message:t,_run(r,s){const i=r.value;if(i&&typeof i=="object"){r.typed=!0,r.value={};for(const a in i)if(na(i,a)){const c=i[a],u=this.key._run({typed:!1,value:a},s);if(u.issues){const l={type:"object",origin:"key",input:i,key:a,value:c};for(const g of u.issues)g.path=[l],r.issues?.push(g);if(r.issues||(r.issues=u.issues),s.abortEarly){r.typed=!1;break}}const h=this.value._run({typed:!1,value:c},s);if(h.issues){const l={type:"object",origin:"value",input:i,key:a,value:c};for(const g of h.issues)g.path?g.path.unshift(l):g.path=[l],r.issues?.push(g);if(r.issues||(r.issues=h.issues),s.abortEarly){r.typed=!1;break}}(!u.typed||!h.typed)&&(r.typed=!1),u.typed&&(r.value[u.value]=h.value)}}else X(this,"type",r,s);return r}}}function S(n){return{kind:"schema",type:"string",reference:S,expects:"string",async:!1,message:n,_run(e,t){return typeof e.value=="string"?e.typed=!0:X(this,"type",e,t),e}}}function dn(n,e){return{kind:"schema",type:"tuple",reference:dn,expects:"Array",async:!1,items:n,message:e,_run(t,r){const s=t.value;if(Array.isArray(s)){t.typed=!0,t.value=[];for(let i=0;i<this.items.length;i++){const a=s[i],c=this.items[i]._run({typed:!1,value:a},r);if(c.issues){const u={type:"array",origin:"value",input:s,key:i,value:a};for(const h of c.issues)h.path?h.path.unshift(u):h.path=[u],t.issues?.push(h);if(t.issues||(t.issues=c.issues),r.abortEarly){t.typed=!1;break}}c.typed||(t.typed=!1),t.value.push(c.value)}}else X(this,"type",t,r);return t}}}function xr(n){let e;if(n)for(const t of n)e?e.push(...t.issues):e=t.issues;return e}function V(n,e){return{kind:"schema",type:"union",reference:V,expects:[...new Set(n.map(t=>t.expects))].join(" | ")||"never",async:!1,options:n,message:e,_run(t,r){let s,i,a;for(const c of this.options){const u=c._run({typed:!1,value:t.value},r);if(u.typed)if(u.issues)i?i.push(u):i=[u];else{s=u;break}else a?a.push(u):a=[u]}if(s)return s;if(i){if(i.length===1)return i[0];X(this,"type",t,r,{issues:xr(i)}),t.typed=!0}else{if(a?.length===1)return a[0];X(this,"type",t,r,{issues:xr(a)})}return t}}}function Ne(){return{kind:"schema",type:"unknown",reference:Ne,expects:"unknown",async:!1,_run(n){return n.typed=!0,n}}}function P(n,e,t){const r=n._run({typed:!1,value:e},Ji(t));if(r.issues)throw new ra(r.issues);return r.value}function j(...n){return{...n[0],pipe:n,_run(e,t){for(let r=0;r<n.length;r++){if(e.issues&&(n[r].kind==="schema"||n[r].kind==="transformation")){e.typed=!1;break}(!e.issues||!t.abortEarly&&!t.abortPipeEarly)&&(e=n[r]._run(e,t))}return e}}}function Ve(n){const e=Object.entries(n).map(([t,r])=>p({[t]:r}));return j(V(e),At(t=>({...t,$kind:Object.keys(t)[0]})))}const Xe=j(S(),At(n=>E(n)),ot(ae)),Z=Xe,ze=S(),G=j(V([S(),j($(),x())]),ot(n=>{try{return BigInt(n),BigInt(n)>=0&&BigInt(n)<=18446744073709551615n}catch{return!1}},"Invalid u64")),Ie=p({objectId:Xe,version:G,digest:S()}),C=j(V([p({GasCoin:b(!0)}),p({Input:j($(),x()),type:R(b("pure"))}),p({Input:j($(),x()),type:R(b("object"))}),p({Result:j($(),x())}),p({NestedResult:dn([j($(),x()),j($(),x())])})]),At(n=>({...n,$kind:Object.keys(n)[0]}))),sa=p({budget:O(G),price:O(G),owner:O(Xe),payment:O(y(Ie))}),hn=V([b("address"),b("bool"),b("u8"),b("u16"),b("u32"),b("u64"),b("u128"),b("u256"),p({vector:ct(()=>hn)}),p({datatype:p({package:S(),module:S(),type:S(),typeParameters:y(ct(()=>hn))})}),p({typeParameter:j($(),x())})]),ia=p({ref:O(V([b("&"),b("&mut")])),body:hn}),aa=p({package:Z,module:S(),function:S(),typeArguments:y(S()),arguments:y(C),_argumentTypes:R(O(y(ia)))}),oa=p({name:S(),inputs:ut(S(),V([C,y(C)])),data:ut(S(),Ne())}),ca=Ve({MoveCall:aa,TransferObjects:p({objects:y(C),address:C}),SplitCoins:p({coin:C,amounts:y(C)}),MergeCoins:p({destination:C,sources:y(C)}),Publish:p({modules:y(ze),dependencies:y(Z)}),MakeMoveVec:p({type:O(S()),elements:y(C)}),Upgrade:p({modules:y(ze),dependencies:y(Z),package:Z,ticket:C}),$Intent:oa}),Pr=Ve({ImmOrOwnedObject:Ie,SharedObject:p({objectId:Z,initialSharedVersion:G,mutable:He()}),Receiving:Ie}),ua=Ve({Object:Pr,Pure:p({bytes:ze}),UnresolvedPure:p({value:Ne()}),UnresolvedObject:p({objectId:Z,version:R(O(G)),digest:R(O(S())),initialSharedVersion:R(O(G)),mutable:R(O(He()))})}),Ur=Ve({Object:Pr,Pure:p({bytes:ze})}),Rr=Ve({None:b(!0),Epoch:G}),$t=p({version:b(2),sender:Je(Xe),expiration:Je(Rr),gasData:sa,inputs:y(ua),commands:y(ca)}),Fe={MoveCall(n){const[e,t="",r=""]="target"in n?n.target.split("::"):[n.package,n.module,n.function];return{$kind:"MoveCall",MoveCall:{package:e,module:t,function:r,typeArguments:n.typeArguments??[],arguments:n.arguments??[]}}},TransferObjects(n,e){return{$kind:"TransferObjects",TransferObjects:{objects:n.map(t=>P(C,t)),address:P(C,e)}}},SplitCoins(n,e){return{$kind:"SplitCoins",SplitCoins:{coin:P(C,n),amounts:e.map(t=>P(C,t))}}},MergeCoins(n,e){return{$kind:"MergeCoins",MergeCoins:{destination:P(C,n),sources:e.map(t=>P(C,t))}}},Publish({modules:n,dependencies:e}){return{$kind:"Publish",Publish:{modules:n.map(t=>typeof t=="string"?t:z(new Uint8Array(t))),dependencies:e.map(t=>be(t))}}},Upgrade({modules:n,dependencies:e,package:t,ticket:r}){return{$kind:"Upgrade",Upgrade:{modules:n.map(s=>typeof s=="string"?s:z(new Uint8Array(s))),dependencies:e.map(s=>be(s)),package:t,ticket:P(C,r)}}},MakeMoveVec({type:n,elements:e}){return{$kind:"MakeMoveVec",MakeMoveVec:{type:n??null,elements:e.map(t=>P(C,t))}}},Intent({name:n,inputs:e={},data:t={}}){return{$kind:"$Intent",$Intent:{name:n,inputs:Object.fromEntries(Object.entries(e).map(([r,s])=>[r,Array.isArray(s)?s.map(i=>P(C,i)):P(C,s)])),data:t}}}},pn=p({digest:S(),objectId:S(),version:V([j($(),x()),S(),ln()])}),la=Ve({ImmOrOwned:pn,Shared:p({objectId:Z,initialSharedVersion:G,mutable:He()}),Receiving:pn}),Br=Ve({Object:la,Pure:y(j($(),x()))}),Dr=V([p({kind:b("Input"),index:j($(),x()),value:Ne(),type:R(b("object"))}),p({kind:b("Input"),index:j($(),x()),value:Ne(),type:b("pure")})]),da=V([p({Epoch:j($(),x())}),p({None:O(b(!0))})]),Nr=j(V([$(),S(),ln()]),ot(n=>{if(!["string","number","bigint"].includes(typeof n))return!1;try{return BigInt(n),!0}catch{return!1}})),fn=V([p({bool:O(b(!0))}),p({u8:O(b(!0))}),p({u64:O(b(!0))}),p({u128:O(b(!0))}),p({address:O(b(!0))}),p({signer:O(b(!0))}),p({vector:ct(()=>fn)}),p({struct:ct(()=>ha)}),p({u16:O(b(!0))}),p({u32:O(b(!0))}),p({u256:O(b(!0))})]),ha=p({address:S(),module:S(),name:S(),typeParams:y(fn)}),pa=p({budget:R(Nr),price:R(Nr),payment:R(y(pn)),owner:R(S())}),fa=[Dr,p({kind:b("GasCoin")}),p({kind:b("Result"),index:j($(),x())}),p({kind:b("NestedResult"),index:j($(),x()),resultIndex:j($(),x())})],we=V([...fa]),ga=p({kind:b("MoveCall"),target:j(S(),ot(n=>n.split("::").length===3)),typeArguments:y(S()),arguments:y(we)}),ma=p({kind:b("TransferObjects"),objects:y(we),address:we}),ya=p({kind:b("SplitCoins"),coin:we,amounts:y(we)}),ba=p({kind:b("MergeCoins"),destination:we,sources:y(we)}),wa=p({kind:b("MakeMoveVec"),type:V([p({Some:fn}),p({None:O(b(!0))})]),objects:y(we)}),va=p({kind:b("Publish"),modules:y(y(j($(),x()))),dependencies:y(S())}),Sa=p({kind:b("Upgrade"),modules:y(y(j($(),x()))),dependencies:y(S()),packageId:S(),ticket:we}),ka=V([...[ga,ma,ya,ba,va,Sa,wa]]);p({version:b(1),sender:R(S()),expiration:Je(da),gasConfig:pa,inputs:y(Dr),transactions:y(ka)});function Vr(n){const e=n.inputs.map((t,r)=>{if(t.Object)return{kind:"Input",index:r,value:{Object:t.Object.ImmOrOwnedObject?{ImmOrOwned:t.Object.ImmOrOwnedObject}:t.Object.Receiving?{Receiving:{digest:t.Object.Receiving.digest,version:t.Object.Receiving.version,objectId:t.Object.Receiving.objectId}}:{Shared:{mutable:t.Object.SharedObject.mutable,initialSharedVersion:t.Object.SharedObject.initialSharedVersion,objectId:t.Object.SharedObject.objectId}}},type:"object"};if(t.Pure)return{kind:"Input",index:r,value:{Pure:Array.from(H(t.Pure.bytes))},type:"pure"};if(t.UnresolvedPure)return{kind:"Input",type:"pure",index:r,value:t.UnresolvedPure.value};if(t.UnresolvedObject)return{kind:"Input",type:"object",index:r,value:t.UnresolvedObject.objectId};throw new Error("Invalid input")});return{version:1,sender:n.sender??void 0,expiration:n.expiration?.$kind==="Epoch"?{Epoch:Number(n.expiration.Epoch)}:n.expiration?{None:!0}:null,gasConfig:{owner:n.gasData.owner??void 0,budget:n.gasData.budget??void 0,price:n.gasData.price??void 0,payment:n.gasData.payment??void 0},inputs:e,transactions:n.commands.map(t=>{if(t.MakeMoveVec)return{kind:"MakeMoveVec",type:t.MakeMoveVec.type===null?{None:!0}:{Some:oe.parseFromStr(t.MakeMoveVec.type)},objects:t.MakeMoveVec.elements.map(r=>ve(r,e))};if(t.MergeCoins)return{kind:"MergeCoins",destination:ve(t.MergeCoins.destination,e),sources:t.MergeCoins.sources.map(r=>ve(r,e))};if(t.MoveCall)return{kind:"MoveCall",target:`${t.MoveCall.package}::${t.MoveCall.module}::${t.MoveCall.function}`,typeArguments:t.MoveCall.typeArguments,arguments:t.MoveCall.arguments.map(r=>ve(r,e))};if(t.Publish)return{kind:"Publish",modules:t.Publish.modules.map(r=>Array.from(H(r))),dependencies:t.Publish.dependencies};if(t.SplitCoins)return{kind:"SplitCoins",coin:ve(t.SplitCoins.coin,e),amounts:t.SplitCoins.amounts.map(r=>ve(r,e))};if(t.TransferObjects)return{kind:"TransferObjects",objects:t.TransferObjects.objects.map(r=>ve(r,e)),address:ve(t.TransferObjects.address,e)};if(t.Upgrade)return{kind:"Upgrade",modules:t.Upgrade.modules.map(r=>Array.from(H(r))),dependencies:t.Upgrade.dependencies,packageId:t.Upgrade.package,ticket:ve(t.Upgrade.ticket,e)};throw new Error(`Unknown transaction ${Object.keys(t)}`)})}}function ve(n,e){if(n.$kind==="GasCoin")return{kind:"GasCoin"};if(n.$kind==="Result")return{kind:"Result",index:n.Result};if(n.$kind==="NestedResult")return{kind:"NestedResult",index:n.NestedResult[0],resultIndex:n.NestedResult[1]};if(n.$kind==="Input")return e[n.Input];throw new Error(`Invalid argument ${Object.keys(n)}`)}function Oa(n){return P($t,{version:2,sender:n.sender??null,expiration:n.expiration?"Epoch"in n.expiration?{Epoch:n.expiration.Epoch}:{None:!0}:null,gasData:{owner:n.gasConfig.owner??null,budget:n.gasConfig.budget?.toString()??null,price:n.gasConfig.price?.toString()??null,payment:n.gasConfig.payment?.map(e=>({digest:e.digest,objectId:e.objectId,version:e.version.toString()}))??null},inputs:n.inputs.map(e=>{if(e.kind==="Input"){if(un(Br,e.value)){const t=P(Br,e.value);if(t.Object){if(t.Object.ImmOrOwned)return{Object:{ImmOrOwnedObject:{objectId:t.Object.ImmOrOwned.objectId,version:String(t.Object.ImmOrOwned.version),digest:t.Object.ImmOrOwned.digest}}};if(t.Object.Shared)return{Object:{SharedObject:{mutable:t.Object.Shared.mutable??null,initialSharedVersion:t.Object.Shared.initialSharedVersion,objectId:t.Object.Shared.objectId}}};if(t.Object.Receiving)return{Object:{Receiving:{digest:t.Object.Receiving.digest,version:String(t.Object.Receiving.version),objectId:t.Object.Receiving.objectId}}};throw new Error("Invalid object input")}return{Pure:{bytes:z(new Uint8Array(t.Pure))}}}return e.type==="object"?{UnresolvedObject:{objectId:e.value}}:{UnresolvedPure:{value:e.value}}}throw new Error("Invalid input")}),commands:n.transactions.map(e=>{switch(e.kind){case"MakeMoveVec":return{MakeMoveVec:{type:"Some"in e.type?oe.tagToString(e.type.Some):null,elements:e.objects.map(t=>Se(t))}};case"MergeCoins":return{MergeCoins:{destination:Se(e.destination),sources:e.sources.map(t=>Se(t))}};case"MoveCall":{const[t,r,s]=e.target.split("::");return{MoveCall:{package:t,module:r,function:s,typeArguments:e.typeArguments,arguments:e.arguments.map(i=>Se(i))}}}case"Publish":return{Publish:{modules:e.modules.map(t=>z(Uint8Array.from(t))),dependencies:e.dependencies}};case"SplitCoins":return{SplitCoins:{coin:Se(e.coin),amounts:e.amounts.map(t=>Se(t))}};case"TransferObjects":return{TransferObjects:{objects:e.objects.map(t=>Se(t)),address:Se(e.address)}};case"Upgrade":return{Upgrade:{modules:e.modules.map(t=>z(Uint8Array.from(t))),dependencies:e.dependencies,package:e.packageId,ticket:Se(e.ticket)}}}throw new Error(`Unknown transaction ${Object.keys(e)}`)})})}function Se(n){switch(n.kind){case"GasCoin":return{GasCoin:!0};case"Result":return{Result:n.index};case"NestedResult":return{NestedResult:[n.index,n.resultIndex]};case"Input":return{Input:n.index}}}function lt(n){return V(Object.entries(n).map(([e,t])=>p({[e]:t})))}const ue=lt({GasCoin:b(!0),Input:j($(),x()),Result:j($(),x()),NestedResult:dn([j($(),x()),j($(),x())])}),Ea=p({budget:O(G),price:O(G),owner:O(Xe),payment:O(y(Ie))}),ja=p({package:Z,module:S(),function:S(),typeArguments:y(S()),arguments:y(ue)}),Ta=p({name:S(),inputs:ut(S(),V([ue,y(ue)])),data:ut(S(),Ne())}),Ia=lt({MoveCall:ja,TransferObjects:p({objects:y(ue),address:ue}),SplitCoins:p({coin:ue,amounts:y(ue)}),MergeCoins:p({destination:ue,sources:y(ue)}),Publish:p({modules:y(ze),dependencies:y(Z)}),MakeMoveVec:p({type:O(S()),elements:y(ue)}),Upgrade:p({modules:y(ze),dependencies:y(Z),package:Z,ticket:ue}),$Intent:Ta}),Ma=lt({ImmOrOwnedObject:Ie,SharedObject:p({objectId:Z,initialSharedVersion:G,mutable:He()}),Receiving:Ie}),_a=lt({Object:Ma,Pure:p({bytes:ze}),UnresolvedPure:p({value:Ne()}),UnresolvedObject:p({objectId:Z,version:R(O(G)),digest:R(O(S())),initialSharedVersion:R(O(G)),mutable:R(O(He()))})}),Ca=lt({None:b(!0),Epoch:G}),Aa=p({version:b(2),sender:Je(Xe),expiration:Je(Ca),gasData:Ea,inputs:y(_a),commands:y(Ia),digest:R(O(S()))});function $a(n){return{$kind:"Pure",Pure:{bytes:n instanceof Uint8Array?z(n):n.toBase64()}}}const le={Pure:$a,ObjectRef({objectId:n,digest:e,version:t}){return{$kind:"Object",Object:{$kind:"ImmOrOwnedObject",ImmOrOwnedObject:{digest:e,version:t,objectId:E(n)}}}},SharedObjectRef({objectId:n,mutable:e,initialSharedVersion:t}){return{$kind:"Object",Object:{$kind:"SharedObject",SharedObject:{mutable:e,initialSharedVersion:t,objectId:E(n)}}}},ReceivingRef({objectId:n,digest:e,version:t}){return{$kind:"Object",Object:{$kind:"Receiving",Receiving:{digest:e,version:t,objectId:E(n)}}}}};BigInt(1e9);const xa="0x1",zr="0x2";be("0x6");const Pa=`${zr}::sui::SUI`;be("0x5");/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ua(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function gn(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function mn(n,...e){if(!Ua(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error("Uint8Array expected of length "+e+", got length="+n.length)}function Fr(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function Ra(n,e){mn(n);const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function xt(n){return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4))}function yn(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}const Lr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Wr(n){return n<<24&4278190080|n<<8&16711680|n>>>8&65280|n>>>24&255}const ke=Lr?n=>n:n=>Wr(n);function Ba(n){for(let e=0;e<n.length;e++)n[e]=Wr(n[e]);return n}const Ze=Lr?n=>n:Ba;function Da(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function dt(n){return typeof n=="string"&&(n=Da(n)),mn(n),n}class Na{}function Va(n){const e=(r,s)=>n(s).update(dt(r)).digest(),t=n({});return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=r=>n(r),e}const za=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9]),Pt=BigInt(2**32-1),Gr=BigInt(32);function Fa(n,e=!1){return e?{h:Number(n&Pt),l:Number(n>>Gr&Pt)}:{h:Number(n>>Gr&Pt)|0,l:Number(n&Pt)|0}}const Kr=(n,e,t)=>n>>>t|e<<32-t,qr=(n,e,t)=>n<<32-t|e>>>t,La=(n,e,t)=>n<<64-t|e>>>t-32,Wa=(n,e,t)=>n>>>t-32|e<<64-t,Ga=(n,e)=>e,Ka=(n,e)=>n;function Hr(n,e,t,r){const s=(e>>>0)+(r>>>0);return{h:n+t+(s/2**32|0)|0,l:s|0}}const Jr=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),Xr=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,B=Uint32Array.from([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),f=new Uint32Array(32);function Me(n,e,t,r,s,i){const a=s[i],c=s[i+1];let u=f[2*n],h=f[2*n+1],l=f[2*e],g=f[2*e+1],v=f[2*t],I=f[2*t+1],k=f[2*r],A=f[2*r+1],re=Jr(u,l,a);h=Xr(re,h,g,c),u=re|0,{Dh:A,Dl:k}={Dh:A^h,Dl:k^u},{Dh:A,Dl:k}={Dh:Ga(A,k),Dl:Ka(A)},{h:I,l:v}=Hr(I,v,A,k),{Bh:g,Bl:l}={Bh:g^I,Bl:l^v},{Bh:g,Bl:l}={Bh:Kr(g,l,24),Bl:qr(g,l,24)},f[2*n]=u,f[2*n+1]=h,f[2*e]=l,f[2*e+1]=g,f[2*t]=v,f[2*t+1]=I,f[2*r]=k,f[2*r+1]=A}function _e(n,e,t,r,s,i){const a=s[i],c=s[i+1];let u=f[2*n],h=f[2*n+1],l=f[2*e],g=f[2*e+1],v=f[2*t],I=f[2*t+1],k=f[2*r],A=f[2*r+1],re=Jr(u,l,a);h=Xr(re,h,g,c),u=re|0,{Dh:A,Dl:k}={Dh:A^h,Dl:k^u},{Dh:A,Dl:k}={Dh:Kr(A,k,16),Dl:qr(A,k,16)},{h:I,l:v}=Hr(I,v,A,k),{Bh:g,Bl:l}={Bh:g^I,Bl:l^v},{Bh:g,Bl:l}={Bh:La(g,l,63),Bl:Wa(g,l,63)},f[2*n]=u,f[2*n+1]=h,f[2*e]=l,f[2*e+1]=g,f[2*t]=v,f[2*t+1]=I,f[2*r]=k,f[2*r+1]=A}function qa(n,e={},t,r,s){if(gn(t),n<0||n>t)throw new Error("outputLen bigger than keyLen");const{key:i,salt:a,personalization:c}=e;if(i!==void 0&&(i.length<1||i.length>t))throw new Error("key length must be undefined or 1.."+t);if(a!==void 0&&a.length!==r)throw new Error("salt must be undefined or "+r);if(c!==void 0&&c.length!==s)throw new Error("personalization must be undefined or "+s)}class Ha extends Na{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,this.length=0,this.pos=0,gn(e),gn(t),this.blockLen=e,this.outputLen=t,this.buffer=new Uint8Array(e),this.buffer32=xt(this.buffer)}update(e){Fr(this),e=dt(e),mn(e);const{blockLen:t,buffer:r,buffer32:s}=this,i=e.length,a=e.byteOffset,c=e.buffer;for(let u=0;u<i;){this.pos===t&&(Ze(s),this.compress(s,0,!1),Ze(s),this.pos=0);const h=Math.min(t-this.pos,i-u),l=a+u;if(h===t&&!(l%4)&&u+h<i){const g=new Uint32Array(c,l,Math.floor((i-u)/4));Ze(g);for(let v=0;u+t<i;v+=s.length,u+=t)this.length+=t,this.compress(g,v,!1);Ze(g);continue}r.set(e.subarray(u,u+h),this.pos),this.pos+=h,this.length+=h,u+=h}return this}digestInto(e){Fr(this),Ra(e,this);const{pos:t,buffer32:r}=this;this.finished=!0,yn(this.buffer.subarray(t)),Ze(r),this.compress(r,0,!0),Ze(r);const s=xt(e);this.get().forEach((i,a)=>s[a]=ke(i))}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){const{buffer:t,length:r,finished:s,destroyed:i,outputLen:a,pos:c}=this;return e||(e=new this.constructor({dkLen:a})),e.set(...this.get()),e.buffer.set(t),e.destroyed=i,e.finished=s,e.length=r,e.pos=c,e.outputLen=a,e}clone(){return this._cloneInto()}}class Ja extends Ha{constructor(e={}){const t=e.dkLen===void 0?64:e.dkLen;super(128,t),this.v0l=B[0]|0,this.v0h=B[1]|0,this.v1l=B[2]|0,this.v1h=B[3]|0,this.v2l=B[4]|0,this.v2h=B[5]|0,this.v3l=B[6]|0,this.v3h=B[7]|0,this.v4l=B[8]|0,this.v4h=B[9]|0,this.v5l=B[10]|0,this.v5h=B[11]|0,this.v6l=B[12]|0,this.v6h=B[13]|0,this.v7l=B[14]|0,this.v7h=B[15]|0,qa(t,e,64,16,16);let{key:r,personalization:s,salt:i}=e,a=0;if(r!==void 0&&(r=dt(r),a=r.length),this.v0l^=this.outputLen|a<<8|65536|1<<24,i!==void 0){i=dt(i);const c=xt(i);this.v4l^=ke(c[0]),this.v4h^=ke(c[1]),this.v5l^=ke(c[2]),this.v5h^=ke(c[3])}if(s!==void 0){s=dt(s);const c=xt(s);this.v6l^=ke(c[0]),this.v6h^=ke(c[1]),this.v7l^=ke(c[2]),this.v7h^=ke(c[3])}if(r!==void 0){const c=new Uint8Array(this.blockLen);c.set(r),this.update(c)}}get(){let{v0l:e,v0h:t,v1l:r,v1h:s,v2l:i,v2h:a,v3l:c,v3h:u,v4l:h,v4h:l,v5l:g,v5h:v,v6l:I,v6h:k,v7l:A,v7h:re}=this;return[e,t,r,s,i,a,c,u,h,l,g,v,I,k,A,re]}set(e,t,r,s,i,a,c,u,h,l,g,v,I,k,A,re){this.v0l=e|0,this.v0h=t|0,this.v1l=r|0,this.v1h=s|0,this.v2l=i|0,this.v2h=a|0,this.v3l=c|0,this.v3h=u|0,this.v4l=h|0,this.v4h=l|0,this.v5l=g|0,this.v5h=v|0,this.v6l=I|0,this.v6h=k|0,this.v7l=A|0,this.v7h=re|0}compress(e,t,r){this.get().forEach((u,h)=>f[h]=u),f.set(B,16);let{h:s,l:i}=Fa(BigInt(this.length));f[24]=B[8]^i,f[25]=B[9]^s,r&&(f[28]=~f[28],f[29]=~f[29]);let a=0;const c=za;for(let u=0;u<12;u++)Me(0,4,8,12,e,t+2*c[a++]),_e(0,4,8,12,e,t+2*c[a++]),Me(1,5,9,13,e,t+2*c[a++]),_e(1,5,9,13,e,t+2*c[a++]),Me(2,6,10,14,e,t+2*c[a++]),_e(2,6,10,14,e,t+2*c[a++]),Me(3,7,11,15,e,t+2*c[a++]),_e(3,7,11,15,e,t+2*c[a++]),Me(0,5,10,15,e,t+2*c[a++]),_e(0,5,10,15,e,t+2*c[a++]),Me(1,6,11,12,e,t+2*c[a++]),_e(1,6,11,12,e,t+2*c[a++]),Me(2,7,8,13,e,t+2*c[a++]),_e(2,7,8,13,e,t+2*c[a++]),Me(3,4,9,14,e,t+2*c[a++]),_e(3,4,9,14,e,t+2*c[a++]);this.v0l^=f[0]^f[16],this.v0h^=f[1]^f[17],this.v1l^=f[2]^f[18],this.v1h^=f[3]^f[19],this.v2l^=f[4]^f[20],this.v2h^=f[5]^f[21],this.v3l^=f[6]^f[22],this.v3h^=f[7]^f[23],this.v4l^=f[8]^f[24],this.v4h^=f[9]^f[25],this.v5l^=f[10]^f[26],this.v5h^=f[11]^f[27],this.v6l^=f[12]^f[28],this.v6h^=f[13]^f[29],this.v7l^=f[14]^f[30],this.v7h^=f[15]^f[31],yn(f)}destroy(){this.destroyed=!0,yn(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Zr=Va(n=>new Ja(n));function Xa(n,e,t){const r=w.Address.serialize(n).toBytes(),s=w.TypeTag.serialize(e).toBytes(),i=w.u64().serialize(t.length).toBytes(),a=Zr.create({dkLen:32});return a.update(new Uint8Array([240])),a.update(r),a.update(i),a.update(t),a.update(s),`0x${Ke(a.digest().slice(0,32))}`}const Za="object",Ya="ID",Qa="ascii",eo="String",to="string",no="String",ro="option",so="Option";function io(n){const e=typeof n.body=="object"&&"datatype"in n.body?n.body.datatype:null;return!!e&&E(e.package)===E("0x2")&&e.module==="tx_context"&&e.type==="TxContext"}function bn(n){if(typeof n=="string")switch(n){case"address":return w.Address;case"bool":return w.Bool;case"u8":return w.U8;case"u16":return w.U16;case"u32":return w.U32;case"u64":return w.U64;case"u128":return w.U128;case"u256":return w.U256;default:throw new Error(`Unknown type signature ${n}`)}if("vector"in n){if(n.vector==="u8")return w.vector(w.U8).transform({input:t=>typeof t=="string"?new TextEncoder().encode(t):t,output:t=>t});const e=bn(n.vector);return e?w.vector(e):null}if("datatype"in n){const e=E(n.datatype.package);if(e===E(xa)){if(n.datatype.module===Qa&&n.datatype.type===eo||n.datatype.module===to&&n.datatype.type===no)return w.String;if(n.datatype.module===ro&&n.datatype.type===so){const t=bn(n.datatype.typeParameters[0]);return t?w.vector(t):null}}if(e===E(zr)&&n.datatype.module===Za&&n.datatype.type===Ya)return w.Address}return null}function ao(n){return typeof n=="object"&&"Reference"in n?{ref:"&",body:ht(n.Reference)}:typeof n=="object"&&"MutableReference"in n?{ref:"&mut",body:ht(n.MutableReference)}:{ref:null,body:ht(n)}}function ht(n){if(typeof n=="string")switch(n){case"Address":return"address";case"Bool":return"bool";case"U8":return"u8";case"U16":return"u16";case"U32":return"u32";case"U64":return"u64";case"U128":return"u128";case"U256":return"u256";default:throw new Error(`Unexpected type ${n}`)}if("Vector"in n)return{vector:ht(n.Vector)};if("Struct"in n)return{datatype:{package:n.Struct.address,module:n.Struct.module,type:n.Struct.name,typeParameters:n.Struct.typeArguments.map(ht)}};if("TypeParameter"in n)return{typeParameter:n.TypeParameter};throw new Error(`Unexpected type ${JSON.stringify(n)}`)}const oo=50,co=1000n,uo=5e10;function Yr(n){return async function(t,r,s){return await go(t,n),await fo(t,n),r.onlyTransactionKind||(await lo(t,n),await ho(t,n),await po(t,n)),await s()}}async function lo(n,e){n.gasConfig.price||(n.gasConfig.price=String(await e.getReferenceGasPrice()))}async function ho(n,e){if(n.gasConfig.budget)return;const t=await e.dryRunTransactionBlock({transactionBlock:n.build({overrides:{gasData:{budget:String(uo),payment:[]}}})});if(t.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=co*BigInt(n.gasConfig.price||1n),s=BigInt(t.effects.gasUsed.computationCost)+r,i=s+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);n.gasConfig.budget=String(i>s?i:s)}async function po(n,e){if(!n.gasConfig.payment){const r=(await e.getCoins({owner:n.gasConfig.owner||n.sender,coinType:Pa})).data.filter(s=>!n.inputs.find(a=>a.Object?.ImmOrOwnedObject?s.coinObjectId===a.Object.ImmOrOwnedObject.objectId:!1)).map(s=>({objectId:s.coinObjectId,digest:s.digest,version:s.version}));if(!r.length)throw new Error("No valid gas coins found for the transaction.");n.gasConfig.payment=r.map(s=>P(Ie,s))}}async function fo(n,e){const t=n.inputs.filter(l=>l.UnresolvedObject&&!(l.UnresolvedObject.version||l.UnresolvedObject?.initialSharedVersion)),r=[...new Set(t.map(l=>be(l.UnresolvedObject.objectId)))],s=r.length?kt(r,oo):[],i=(await Promise.all(s.map(l=>e.multiGetObjects({ids:l,options:{showOwner:!0}})))).flat(),a=new Map(r.map((l,g)=>[l,i[g]])),c=Array.from(a).filter(([l,g])=>g.error).map(([l,g])=>JSON.stringify(g.error));if(c.length)throw new Error(`The following input objects are invalid: ${c.join(", ")}`);const u=i.map(l=>{if(l.error||!l.data)throw new Error(`Failed to fetch object: ${l.error}`);const g=l.data.owner,v=g&&typeof g=="object"?"Shared"in g?g.Shared.initial_shared_version:"ConsensusAddressOwner"in g?g.ConsensusAddressOwner.start_version:null:null;return{objectId:l.data.objectId,digest:l.data.digest,version:l.data.version,initialSharedVersion:v}}),h=new Map(r.map((l,g)=>[l,u[g]]));for(const[l,g]of n.inputs.entries()){if(!g.UnresolvedObject)continue;let v;const I=E(g.UnresolvedObject.objectId),k=h.get(I);g.UnresolvedObject.initialSharedVersion??k?.initialSharedVersion?v=le.SharedObjectRef({objectId:I,initialSharedVersion:g.UnresolvedObject.initialSharedVersion||k?.initialSharedVersion,mutable:g.UnresolvedObject.mutable||mo(n,l)}):yo(n,l)&&(v=le.ReceivingRef({objectId:I,digest:g.UnresolvedObject.digest??k?.digest,version:g.UnresolvedObject.version??k?.version})),n.inputs[n.inputs.indexOf(g)]=v??le.ObjectRef({objectId:I,digest:g.UnresolvedObject.digest??k?.digest,version:g.UnresolvedObject.version??k?.version})}}async function go(n,e){const{inputs:t,commands:r}=n,s=[],i=new Set;r.forEach(c=>{if(c.MoveCall){if(c.MoveCall._argumentTypes)return;if(c.MoveCall.arguments.map(l=>l.$kind==="Input"?n.inputs[l.Input]:null).some(l=>l?.UnresolvedPure||l?.UnresolvedObject&&typeof l?.UnresolvedObject.mutable!="boolean")){const l=`${c.MoveCall.package}::${c.MoveCall.module}::${c.MoveCall.function}`;i.add(l),s.push(c.MoveCall)}}});const a=new Map;i.size>0&&await Promise.all([...i].map(async c=>{const[u,h,l]=c.split("::"),g=await e.getNormalizedMoveFunction({package:u,module:h,function:l});a.set(c,g.parameters.map(v=>ao(v)))})),s.length&&await Promise.all(s.map(async c=>{const u=a.get(`${c.package}::${c.module}::${c.function}`);if(!u)return;const l=u.length>0&&io(u.at(-1))?u.slice(0,u.length-1):u;c._argumentTypes=l})),r.forEach(c=>{if(!c.MoveCall)return;const u=c.MoveCall,h=`${u.package}::${u.module}::${u.function}`,l=u._argumentTypes;if(l){if(l.length!==c.MoveCall.arguments.length)throw new Error(`Incorrect number of arguments for ${h}`);l.forEach((g,v)=>{const I=u.arguments[v];if(I.$kind!=="Input")return;const k=t[I.Input];if(!k.UnresolvedPure&&!k.UnresolvedObject)return;const A=k.UnresolvedPure?.value??k.UnresolvedObject?.objectId,re=bn(g.body);if(re){I.type="pure",t[t.indexOf(k)]=le.Pure(re.serialize(A));return}if(typeof A!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(A,null,2)}`);I.type="object";const sc=k.UnresolvedPure?{$kind:"UnresolvedObject",UnresolvedObject:{objectId:A}}:k;t[I.Input]=sc})}})}function mo(n,e){let t=!1;return n.getInputUses(e,(r,s)=>{if(s.MoveCall&&s.MoveCall._argumentTypes){const i=s.MoveCall.arguments.indexOf(r);t=s.MoveCall._argumentTypes[i].ref!=="&"||t}(s.$kind==="MakeMoveVec"||s.$kind==="MergeCoins"||s.$kind==="SplitCoins"||s.$kind==="TransferObjects")&&(t=!0)}),t}function yo(n,e){let t=!1;return n.getInputUses(e,(r,s)=>{if(s.MoveCall&&s.MoveCall._argumentTypes){const i=s.MoveCall.arguments.indexOf(r);t=bo(s.MoveCall._argumentTypes[i])||t}}),t}function bo(n){return typeof n.body!="object"||!("datatype"in n.body)?!1:n.body.datatype.package==="0x2"&&n.body.datatype.module==="transfer"&&n.body.datatype.type==="Receiving"}function Qr(n,e){return!!(n.inputs.some(t=>t.UnresolvedObject||t.UnresolvedPure)||!e.onlyTransactionKind&&(!n.gasConfig.price||!n.gasConfig.budget||!n.gasConfig.payment))}async function wo(n,e,t){if(So(n),!Qr(n,e))return await es(n),t();const r=vo(e);return(r.core?.resolveTransactionPlugin()??Yr(r))(n,e,async()=>{await es(n),await t()})}function es(n){n.inputs.forEach((e,t)=>{if(e.$kind!=="Object"&&e.$kind!=="Pure")throw new Error(`Input at index ${t} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(e)}`)})}function vo(n){if(!n.client)throw new Error("No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.");return n.client}function So(n){for(const e of n.commands)switch(e.$kind){case"SplitCoins":e.SplitCoins.amounts.forEach(t=>{ts(t,w.U64,n)});break;case"TransferObjects":ts(e.TransferObjects.address,w.Address,n);break}}function ts(n,e,t){if(n.$kind!=="Input")return;const r=t.inputs[n.Input];r.$kind==="UnresolvedPure"&&(t.inputs[n.Input]=le.Pure(e.serialize(r.UnresolvedPure.value)))}function ko(n){function e(t){return n(t)}return e.system=t=>{const r=t?.mutable;return e(r!==void 0?le.SharedObjectRef({objectId:"0x5",initialSharedVersion:1,mutable:r}):{$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x5",initialSharedVersion:1}})},e.clock=()=>e(le.SharedObjectRef({objectId:"0x6",initialSharedVersion:1,mutable:!1})),e.random=()=>e({$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x8",mutable:!1}}),e.denyList=t=>e({$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x403",mutable:t?.mutable}}),e.option=({type:t,value:r})=>s=>s.moveCall({typeArguments:[t],target:`0x1::option::${r===null?"none":"some"}`,arguments:r===null?[]:[s.object(r)]}),e}function Oo(n){function e(t,r){if(typeof t=="string")return n(at(t).serialize(r));if(t instanceof Uint8Array||en(t))return n(t);throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value")}return e.u8=t=>n(w.U8.serialize(t)),e.u16=t=>n(w.U16.serialize(t)),e.u32=t=>n(w.U32.serialize(t)),e.u64=t=>n(w.U64.serialize(t)),e.u128=t=>n(w.U128.serialize(t)),e.u256=t=>n(w.U256.serialize(t)),e.bool=t=>n(w.Bool.serialize(t)),e.string=t=>n(w.String.serialize(t)),e.address=t=>n(w.Address.serialize(t)),e.id=e.address,e.vector=(t,r)=>n(w.vector(at(t)).serialize(r)),e.option=(t,r)=>n(w.option(at(t)).serialize(r)),e}function Eo(n,e){const t=Array.from(`${n}::`).map(s=>s.charCodeAt(0)),r=new Uint8Array(t.length+e.length);return r.set(t),r.set(e,t.length),Zr(r,{dkLen:32})}function ns(n){return E(n).replace("0x","")}class K{constructor(e){this.version=2,this.sender=e?.sender??null,this.expiration=e?.expiration??null,this.inputs=e?.inputs??[],this.commands=e?.commands??[],this.gasData=e?.gasData??{budget:null,price:null,owner:null,payment:null}}static fromKindBytes(e){const r=w.TransactionKind.parse(e).ProgrammableTransaction;if(!r)throw new Error("Unable to deserialize from bytes.");return K.restore({version:2,sender:null,expiration:null,gasData:{budget:null,owner:null,payment:null,price:null},inputs:r.inputs,commands:r.commands})}static fromBytes(e){const r=w.TransactionData.parse(e)?.V1,s=r.kind.ProgrammableTransaction;if(!r||!s)throw new Error("Unable to deserialize from bytes.");return K.restore({version:2,sender:r.sender,expiration:r.expiration,gasData:r.gasData,inputs:s.inputs,commands:s.commands})}static restore(e){return e.version===2?new K(P($t,e)):new K(P($t,Oa(e)))}static getDigestFromBytes(e){const t=Eo("TransactionData",e);return St(t)}get gasConfig(){return this.gasData}set gasConfig(e){this.gasData=e}build({maxSizeBytes:e=1/0,overrides:t,onlyTransactionKind:r}={}){const s=this.inputs,i=this.commands,a={ProgrammableTransaction:{inputs:s,commands:i}};if(r)return w.TransactionKind.serialize(a,{maxSize:e}).toBytes();const c=t?.expiration??this.expiration,u=t?.sender??this.sender,h={...this.gasData,...t?.gasConfig,...t?.gasData};if(!u)throw new Error("Missing transaction sender");if(!h.budget)throw new Error("Missing gas budget");if(!h.payment)throw new Error("Missing gas payment");if(!h.price)throw new Error("Missing gas price");const l={sender:ns(u),expiration:c||{None:!0},gasData:{payment:h.payment,owner:ns(this.gasData.owner??u),price:BigInt(h.price),budget:BigInt(h.budget)},kind:{ProgrammableTransaction:{inputs:s,commands:i}}};return w.TransactionData.serialize({V1:l},{maxSize:e}).toBytes()}addInput(e,t){const r=this.inputs.length;return this.inputs.push(t),{Input:r,type:e,$kind:"Input"}}getInputUses(e,t){this.mapArguments((r,s)=>(r.$kind==="Input"&&r.Input===e&&t(r,s),r))}mapCommandArguments(e,t){const r=this.commands[e];switch(r.$kind){case"MoveCall":r.MoveCall.arguments=r.MoveCall.arguments.map(i=>t(i,r,e));break;case"TransferObjects":r.TransferObjects.objects=r.TransferObjects.objects.map(i=>t(i,r,e)),r.TransferObjects.address=t(r.TransferObjects.address,r,e);break;case"SplitCoins":r.SplitCoins.coin=t(r.SplitCoins.coin,r,e),r.SplitCoins.amounts=r.SplitCoins.amounts.map(i=>t(i,r,e));break;case"MergeCoins":r.MergeCoins.destination=t(r.MergeCoins.destination,r,e),r.MergeCoins.sources=r.MergeCoins.sources.map(i=>t(i,r,e));break;case"MakeMoveVec":r.MakeMoveVec.elements=r.MakeMoveVec.elements.map(i=>t(i,r,e));break;case"Upgrade":r.Upgrade.ticket=t(r.Upgrade.ticket,r,e);break;case"$Intent":const s=r.$Intent.inputs;r.$Intent.inputs={};for(const[i,a]of Object.entries(s))r.$Intent.inputs[i]=Array.isArray(a)?a.map(c=>t(c,r,e)):t(a,r,e);break;case"Publish":break;default:throw new Error(`Unexpected transaction kind: ${r.$kind}`)}}mapArguments(e){for(const t of this.commands.keys())this.mapCommandArguments(t,e)}replaceCommand(e,t,r=e){if(!Array.isArray(t)){this.commands[e]=t;return}const s=t.length-1;this.commands.splice(e,1,...t),s!==0&&this.mapArguments((i,a,c)=>{if(c<e+t.length)return i;switch(i.$kind){case"Result":i.Result===e&&(i.Result=r),i.Result>e&&(i.Result+=s);break;case"NestedResult":i.NestedResult[0]===e&&(i.NestedResult[0]=r),i.NestedResult[0]>e&&(i.NestedResult[0]+=s);break}return i})}getDigest(){const e=this.build({onlyTransactionKind:!1});return K.getDigestFromBytes(e)}snapshot(){return P($t,this)}shallowClone(){return new K({version:this.version,sender:this.sender,expiration:this.expiration,gasData:{...this.gasData},inputs:[...this.inputs],commands:[...this.commands]})}}function rs(n){if(typeof n=="string")return E(n);if(n.Object)return n.Object.ImmOrOwnedObject?E(n.Object.ImmOrOwnedObject.objectId):n.Object.Receiving?E(n.Object.Receiving.objectId):E(n.Object.SharedObject.objectId);if(n.UnresolvedObject)return E(n.UnresolvedObject.objectId)}var ss=n=>{throw TypeError(n)},wn=(n,e,t)=>e.has(n)||ss("Cannot "+t),D=(n,e,t)=>(wn(n,e,"read from private field"),t?t.call(n):e.get(n)),pt=(n,e,t)=>e.has(n)?ss("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Ut=(n,e,t,r)=>(wn(n,e,"write to private field"),e.set(n,t),t),Rt=(n,e,t)=>(wn(n,e,"access private method"),t),ft,Oe,gt,Ce,fe,vn,Sn,is,as,kn;const jo="/",To={"Mvr-Source":`@mysten/sui@${An}`};class Io{constructor({cache:e,url:t,pageSize:r=50,overrides:s}){pt(this,fe),pt(this,ft),pt(this,Oe),pt(this,gt),pt(this,Ce),Ut(this,ft,e),Ut(this,Oe,t),Ut(this,gt,r),Ut(this,Ce,{packages:s?.packages,types:s?.types}),Mo(D(this,Ce))}async resolvePackage({package:e}){return{package:await D(this,fe,vn).load(e)}}async resolveType({type:e}){const t=[...On(e)],r=await D(this,fe,Sn).loadMany(t),s={};for(let i=0;i<t.length;i++){const a=r[i];if(a instanceof Error)throw a;s[t[i]]=a}return{type:En(e,s)}}async resolve({types:e=[],packages:t=[]}){const r=new Set;for(const l of e??[])On(l,r);const s=[...r],[i,a]=await Promise.all([s.length>0?D(this,fe,Sn).loadMany(s):[],t.length>0?D(this,fe,vn).loadMany(t):[]]),c={...D(this,Ce)?.types};for(const[l,g]of s.entries()){const v=i[l];if(v instanceof Error)throw v;c[g]=v}const u={};for(const l of e??[]){const g=En(l,c);u[l]={type:g}}const h={};for(const[l,g]of(t??[]).entries()){const v=D(this,Ce)?.packages?.[g]??a[l];if(v instanceof Error)throw v;h[g]={package:v}}return{types:u,packages:h}}}ft=new WeakMap,Oe=new WeakMap,gt=new WeakMap,Ce=new WeakMap,fe=new WeakSet,vn=function(){return D(this,ft).readSync(["#mvrPackageDataLoader",D(this,Oe)??""],()=>{const n=new Kn(async t=>{if(!D(this,Oe))throw new Error(`MVR Api URL is not set for the current client (resolving ${t.join(", ")})`);const r=await Rt(this,fe,is).call(this,t);return t.map(s=>r[s]??new Error(`Failed to resolve package: ${s}`))}),e=D(this,Ce)?.packages;if(e)for(const[t,r]of Object.entries(e))n.prime(t,r);return n})},Sn=function(){return D(this,ft).readSync(["#mvrTypeDataLoader",D(this,Oe)??""],()=>{const n=new Kn(async t=>{if(!D(this,Oe))throw new Error(`MVR Api URL is not set for the current client (resolving ${t.join(", ")})`);const r=await Rt(this,fe,as).call(this,t);return t.map(s=>r[s]??new Error(`Failed to resolve type: ${s}`))}),e=D(this,Ce)?.types;if(e)for(const[t,r]of Object.entries(e))n.prime(t,r);return n})},is=async function(n){if(n.length===0)return{};const e=kt(n,D(this,gt)),t={};return await Promise.all(e.map(async r=>{const s=await Rt(this,fe,kn).call(this,"/v1/resolution/bulk",{names:r});if(s?.resolution)for(const i of Object.keys(s?.resolution)){const a=s.resolution[i]?.package_id;a&&(t[i]=a)}})),t},as=async function(n){if(n.length===0)return{};const e=kt(n,D(this,gt)),t={};return await Promise.all(e.map(async r=>{const s=await Rt(this,fe,kn).call(this,"/v1/struct-definition/bulk",{types:r});if(s?.resolution)for(const i of Object.keys(s?.resolution)){const a=s.resolution[i]?.type_tag;a&&(t[i]=a)}})),t},kn=async function(n,e){if(!D(this,Oe))throw new Error("MVR Api URL is not set for the current client");const t=await fetch(`${D(this,Oe)}${n}`,{method:"POST",headers:{"Content-Type":"application/json",...To},body:JSON.stringify(e)});if(!t.ok){const r=await t.json().catch(()=>({}));throw new Error(`Failed to resolve types: ${r?.message}`)}return t.json()};function Mo(n){if(n?.packages)for(const[e,t]of Object.entries(n.packages)){if(!J(e))throw new Error(`Invalid package name: ${e}`);if(!ae(E(t)))throw new Error(`Invalid package ID: ${t}`)}if(n?.types)for(const[e,t]of Object.entries(n.types)){if(Be(e).typeParams.length>0)throw new Error("Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.");const r=Be(t);if(!ae(r.address))throw new Error(`Invalid type: ${t}`)}}function On(n,e=new Set){if(typeof n=="string"&&!q(n))return e;const t=os(n)?n:Be(n);q(t.address)&&e.add(`${t.address}::${t.module}::${t.name}`);for(const r of t.typeParams)On(r,e);return e}function En(n,e){const t=os(n)?n:Be(n),r=`${t.address}::${t.module}::${t.name}`,s=e[r];return Ct({...t,address:s?s.split("::")[0]:t.address,typeParams:t.typeParams.map(i=>En(i,e))})}function q(n){return n.includes(jo)||n.includes("@")||n.includes(".sui")}function os(n){return typeof n=="object"&&"address"in n&&"module"in n&&"name"in n&&"typeParams"in n}function _o(n){const e=new Set,t=new Set;for(const r of n.commands)switch(r.$kind){case"MakeMoveVec":r.MakeMoveVec.type&&cs([r.MakeMoveVec.type]).forEach(a=>{t.add(a)});break;case"MoveCall":const s=r.MoveCall,i=s.package.split("::")[0];if(q(i)){if(!J(i))throw new Error(`Invalid package name: ${i}`);e.add(i)}cs(s.typeArguments??[]).forEach(a=>{t.add(a)});break}return{packages:[...e],types:[...t]}}function Co(n,e){for(const t of n.commands){if(t.MakeMoveVec?.type){if(!q(t.MakeMoveVec.type))continue;if(!e.types[t.MakeMoveVec.type])throw new Error(`No resolution found for type: ${t.MakeMoveVec.type}`);t.MakeMoveVec.type=e.types[t.MakeMoveVec.type].type}const r=t.MoveCall;if(!r)continue;const s=r.package.split("::"),i=s[0];if(q(i)&&!e.packages[i])throw new Error(`No address found for package: ${i}`);q(i)&&(s[0]=e.packages[i].package,r.package=s.join("::"));const a=r.typeArguments;if(a){for(let c=0;c<a.length;c++)if(q(a[c])){if(!e.types[a[c]])throw new Error(`No resolution found for type: ${a[c]}`);a[c]=e.types[a[c]].type}r.typeArguments=a}}}function cs(n){const e=new Set;for(const t of n)if(q(t)){if(!Oi(t))throw new Error(`Invalid type with names: ${t}`);e.add(t)}return e}const Ao=n=>async(e,t,r)=>{const s=_o(e);if(s.types.length===0&&s.packages.length===0)return r();const i=await $o(t).core.mvr.resolve({types:s.types,packages:s.packages});Co(e,i),await r()};function $o(n){if(!n.client)throw new Error("No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.");return n.client}var us=n=>{throw TypeError(n)},jn=(n,e,t)=>e.has(n)||us("Cannot "+t),d=(n,e,t)=>(jn(n,e,"read from private field"),t?t.call(n):e.get(n)),ge=(n,e,t)=>e.has(n)?us("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),T=(n,e,t,r)=>(jn(n,e,"write to private field"),e.set(n,t),t),N=(n,e,t)=>(jn(n,e,"access private method"),t),Le,We,Ee,me,te,ne,de,Ae,m,U,ls,Bt,Dt,Nt,Vt,Tn,In,ds,hs;function Mn(n,e=1/0){const t={$kind:"Result",get Result(){return typeof n=="function"?n():n}},r=[],s=i=>r[i]??(r[i]={$kind:"NestedResult",get NestedResult(){return[typeof n=="function"?n():n,i]}});return new Proxy(t,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,a){if(a in i)return Reflect.get(i,a);if(a===Symbol.iterator)return function*(){let u=0;for(;u<e;)yield s(u),u++};if(typeof a=="symbol")return;const c=parseInt(a,10);if(!(Number.isNaN(c)||c<0))return s(c)}})}const ps=Symbol.for("@mysten/transaction");function fs(n){return!!n&&typeof n=="object"&&n[ps]===!0}const gs={buildPlugins:new Map,serializationPlugins:new Map},_n=Symbol.for("@mysten/transaction/registry");function mt(){try{const n=globalThis;return n[_n]||(n[_n]=gs),n[_n]}catch{return gs}}const ms=class Cn{constructor(){ge(this,U),ge(this,Le),ge(this,We),ge(this,Ee,new Map),ge(this,me,[]),ge(this,te,[]),ge(this,ne,new Set),ge(this,de,new Set),ge(this,Ae,new Map),ge(this,m),this.object=ko(t=>{if(typeof t=="function")return this.object(this.add(t));if(typeof t=="object"&&un(C,t))return t;const r=rs(t),s=d(this,m).inputs.find(i=>r===rs(i));return s?.Object?.SharedObject&&typeof t=="object"&&t.Object?.SharedObject&&(s.Object.SharedObject.mutable=s.Object.SharedObject.mutable||t.Object.SharedObject.mutable),s?{$kind:"Input",Input:d(this,m).inputs.indexOf(s),type:"object"}:N(this,U,Dt).call(this,"object",typeof t=="string"?{$kind:"UnresolvedObject",UnresolvedObject:{objectId:E(t)}}:t)});const e=mt();T(this,m,new K),T(this,We,[...e.buildPlugins.values()]),T(this,Le,[...e.serializationPlugins.values()])}static fromKind(e){const t=new Cn;return T(t,m,K.fromKindBytes(typeof e=="string"?H(e):e)),T(t,me,d(t,m).inputs.slice()),T(t,te,d(t,m).commands.slice()),T(t,ne,new Set(d(t,te).map((r,s)=>s))),t}static from(e){const t=new Cn;return fs(e)?T(t,m,new K(e.getData())):typeof e!="string"||!e.startsWith("{")?T(t,m,K.fromBytes(typeof e=="string"?H(e):e)):T(t,m,K.restore(JSON.parse(e))),T(t,me,d(t,m).inputs.slice()),T(t,te,d(t,m).commands.slice()),T(t,ne,new Set(d(t,te).map((r,s)=>s))),t}static registerGlobalSerializationPlugin(e,t){mt().serializationPlugins.set(e,t??e)}static unregisterGlobalSerializationPlugin(e){mt().serializationPlugins.delete(e)}static registerGlobalBuildPlugin(e,t){mt().buildPlugins.set(e,t??e)}static unregisterGlobalBuildPlugin(e){mt().buildPlugins.delete(e)}addSerializationPlugin(e){d(this,Le).push(e)}addBuildPlugin(e){d(this,We).push(e)}addIntentResolver(e,t){if(d(this,Ee).has(e)&&d(this,Ee).get(e)!==t)throw new Error(`Intent resolver for ${e} already exists`);d(this,Ee).set(e,t)}setSender(e){d(this,m).sender=e}setSenderIfNotSet(e){d(this,m).sender||(d(this,m).sender=e)}setExpiration(e){d(this,m).expiration=e?P(Rr,e):null}setGasPrice(e){d(this,m).gasConfig.price=String(e)}setGasBudget(e){d(this,m).gasConfig.budget=String(e)}setGasBudgetIfNotSet(e){d(this,m).gasData.budget==null&&(d(this,m).gasConfig.budget=String(e))}setGasOwner(e){d(this,m).gasConfig.owner=e}setGasPayment(e){d(this,m).gasConfig.payment=e.map(t=>P(Ie,t))}get blockData(){return Vr(d(this,m).snapshot())}getData(){return d(this,m).snapshot()}get[ps](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:Oo(e=>en(e)?N(this,U,Dt).call(this,"pure",{$kind:"Pure",Pure:{bytes:e.toBase64()}}):N(this,U,Dt).call(this,"pure",un(Ur,e)?P(Ur,e):e instanceof Uint8Array?le.Pure(e):{$kind:"UnresolvedPure",UnresolvedPure:{value:e}}))}),this.pure}get gas(){return{$kind:"GasCoin",GasCoin:!0}}objectRef(...e){return this.object(le.ObjectRef(...e))}receivingRef(...e){return this.object(le.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(le.SharedObjectRef(...e))}add(e){if(typeof e=="function"){if(d(this,Ae).has(e))return d(this,Ae).get(e);const t=N(this,U,ls).call(this),r=e(t);if(!(r&&typeof r=="object"&&"then"in r))return T(this,ne,d(t,ne)),d(this,Ae).set(e,r),r;const s=N(this,U,Bt).call(this,{$kind:"$Intent",$Intent:{name:"AsyncTransactionThunk",inputs:{},data:{resultIndex:d(this,m).commands.length,result:null}}});d(this,de).add(Promise.resolve(r).then(a=>{s.$Intent.data.result=a}));const i=Mn(()=>s.$Intent.data.resultIndex);return d(this,Ae).set(e,i),i}else N(this,U,Bt).call(this,e);return Mn(d(this,m).commands.length-1)}splitCoins(e,t){const r=Fe.SplitCoins(typeof e=="string"?this.object(e):N(this,U,Vt).call(this,e),t.map(s=>typeof s=="number"||typeof s=="bigint"||typeof s=="string"?this.pure.u64(s):N(this,U,Nt).call(this,s)));return N(this,U,Bt).call(this,r),Mn(d(this,m).commands.length-1,t.length)}mergeCoins(e,t){return this.add(Fe.MergeCoins(this.object(e),t.map(r=>this.object(r))))}publish({modules:e,dependencies:t}){return this.add(Fe.Publish({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,package:r,ticket:s}){return this.add(Fe.Upgrade({modules:e,dependencies:t,package:r,ticket:this.object(s)}))}moveCall({arguments:e,...t}){return this.add(Fe.MoveCall({...t,arguments:e?.map(r=>N(this,U,Nt).call(this,r))}))}transferObjects(e,t){return this.add(Fe.TransferObjects(e.map(r=>this.object(r)),typeof t=="string"?this.pure.address(t):N(this,U,Nt).call(this,t)))}makeMoveVec({type:e,elements:t}){return this.add(Fe.MakeMoveVec({type:e,elements:t.map(r=>this.object(r))}))}serialize(){return JSON.stringify(Vr(d(this,m).snapshot()))}async toJSON(e={}){await this.prepareForSerialization(e);const t=this.isFullyResolved();return JSON.stringify(P(Aa,t?{...d(this,m).snapshot(),digest:d(this,m).getDigest()}:d(this,m).snapshot()),(r,s)=>typeof s=="bigint"?s.toString():s,2)}async sign(e){const{signer:t,...r}=e,s=await this.build(r);return t.signTransaction(s)}isFullyResolved(){return!(!d(this,m).sender||d(this,de).size>0||d(this,m).commands.some(e=>e.$Intent)||Qr(d(this,m),{}))}async build(e={}){return await this.prepareForSerialization(e),await N(this,U,Tn).call(this,e),d(this,m).build({onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await this.prepareForSerialization(e),await N(this,U,Tn).call(this,e),d(this,m).getDigest()}async prepareForSerialization(e){await N(this,U,ds).call(this),N(this,U,hs).call(this);const t=new Set;for(const s of d(this,m).commands)s.$Intent&&t.add(s.$Intent.name);const r=[...d(this,Le)];for(const s of t)if(!e.supportedIntents?.includes(s)){if(!d(this,Ee).has(s))throw new Error(`Missing intent resolver for ${s}`);r.push(d(this,Ee).get(s))}r.push(Ao()),await N(this,U,In).call(this,r,e)}};Le=new WeakMap,We=new WeakMap,Ee=new WeakMap,me=new WeakMap,te=new WeakMap,ne=new WeakMap,de=new WeakMap,Ae=new WeakMap,m=new WeakMap,U=new WeakSet,ls=function(){const n=new ms;return T(n,m,d(this,m)),T(n,Le,d(this,Le)),T(n,We,d(this,We)),T(n,Ee,d(this,Ee)),T(n,de,d(this,de)),T(n,ne,new Set(d(this,ne))),T(n,Ae,d(this,Ae)),d(this,me).push(d(n,me)),d(this,te).push(d(n,te)),n},Bt=function(n){const e=d(this,m).commands.length;return d(this,te).push(n),d(this,ne).add(e),d(this,m).commands.push(n),d(this,m).mapCommandArguments(e,t=>{if(t.$kind==="Result"&&!d(this,ne).has(t.Result))throw new Error(`Result { Result: ${t.Result} } is not available to use the current transaction`);if(t.$kind==="NestedResult"&&!d(this,ne).has(t.NestedResult[0]))throw new Error(`Result { NestedResult: [${t.NestedResult[0]}, ${t.NestedResult[1]}] } is not available to use the current transaction`);if(t.$kind==="Input"&&t.Input>=d(this,m).inputs.length)throw new Error(`Input { Input: ${t.Input} } references an input that does not exist in the current transaction`);return t}),n},Dt=function(n,e){return d(this,me).push(e),d(this,m).addInput(n,e)},Nt=function(n){return en(n)?this.pure(n):N(this,U,Vt).call(this,n)},Vt=function(n){if(typeof n=="function"){const e=this.add(n);return typeof e=="function"?N(this,U,Vt).call(this,e):P(C,e)}return P(C,n)},Tn=async function(n){if(!n.onlyTransactionKind&&!d(this,m).sender)throw new Error("Missing transaction sender");await N(this,U,In).call(this,[...d(this,We),wo],n)},In=async function(n,e){try{const t=r=>{if(r>=n.length)return()=>{};const s=n[r];return async()=>{const i=t(r+1);let a=!1,c=!1;if(await s(d(this,m),e,async()=>{if(a)throw new Error(`next() was call multiple times in TransactionPlugin ${r}`);a=!0,await i(),c=!0}),!a)throw new Error(`next() was not called in TransactionPlugin ${r}`);if(!c)throw new Error(`next() was not awaited in TransactionPlugin ${r}`)}};await t(0)()}finally{T(this,me,d(this,m).inputs.slice()),T(this,te,d(this,m).commands.slice())}},ds=async function(){for(;d(this,de).size>0;){const n=Promise.all(d(this,de));d(this,de).clear(),d(this,de).add(n),await n,d(this,de).delete(n)}},hs=function(){const n=d(this,m).commands,e=d(this,m).inputs,t=d(this,te).flat(1/0),r=d(this,me).flat(1/0);if(t.length!==n.length)throw new Error("Unexpected number of commands found in transaction data");if(r.length!==e.length)throw new Error("Unexpected number of inputs found in transaction data");const s=t.filter(a=>a.$Intent?.name!=="AsyncTransactionThunk");d(this,m).commands=s,d(this,m).inputs=r,T(this,te,s),T(this,me,r),T(this,ne,new Set(s.map((a,c)=>c)));function i(a){const c=n[a];if(c.$Intent?.name==="AsyncTransactionThunk"){const h=c.$Intent.data.result;if(h==null)throw new Error("AsyncTransactionThunk has not been resolved");return i(h.Result)}const u=s.indexOf(c);if(u===-1)throw new Error("Unable to find original index for command");return u}d(this,m).mapArguments(a=>{if(a.$kind==="Input"){const c=r.indexOf(e[a.Input]);if(c===-1)throw new Error("Input has not been resolved");return{...a,Input:c}}else if(a.$kind==="Result"){const c=i(a.Result);return{...a,Result:c}}else if(a.$kind==="NestedResult"){const c=i(a.NestedResult[0]);return{...a,NestedResult:[c,a.NestedResult[1]]}}return a});for(const[a,c]of n.entries())if(c.$Intent?.name==="AsyncTransactionThunk")try{c.$Intent.data.resultIndex=i(a)}catch{}};let xo=ms;const Po={mainnet:"https://mainnet.mvr.mystenlabs.com",testnet:"https://testnet.mvr.mystenlabs.com"};class Uo extends nr{constructor(e){super(e),this.core=this,this.mvr=new Io({cache:this.cache.scope("core.mvr"),url:e.mvr?.url??Po[this.network],pageSize:e.mvr?.pageSize,overrides:e.mvr?.overrides})}async getObject(e){const{objectId:t}=e,{objects:[r]}=await this.getObjects({objectIds:[t],signal:e.signal});if(r instanceof Error)throw r;return{object:r}}async getDynamicField(e){const t=Xa(e.parentId,oe.parseFromStr(e.name.type),e.name.bcs),{objects:[r]}=await this.getObjects({objectIds:[t],signal:e.signal});if(r instanceof Error)throw r;const s=Be(r.type),i=await r.content;return{dynamicField:{id:r.id,digest:r.digest,version:r.version,type:r.type,name:{type:typeof s.typeParams[0]=="string"?s.typeParams[0]:Ct(s.typeParams[0]),bcs:e.name.bcs},value:{type:typeof s.typeParams[1]=="string"?s.typeParams[1]:Ct(s.typeParams[1]),bcs:i.slice(Mt+e.name.bcs.length)}}}}async waitForTransaction({signal:e,timeout:t=60*1e3,...r}){const s=e?AbortSignal.any([AbortSignal.timeout(t),e]):AbortSignal.timeout(t),i=new Promise((a,c)=>{s.addEventListener("abort",()=>c(s.reason))});for(i.catch(()=>{});;){s.throwIfAborted();try{return await this.getTransaction({...r,signal:s})}catch{await Promise.race([new Promise(c=>setTimeout(c,2e3)),i])}}}}class Ro extends Error{}class $e extends Ro{constructor(e,t){super(t),this.code=e}static fromResponse(e,t){switch(e.code){case"notExists":return new $e(e.code,`Object ${e.object_id} does not exist`);case"dynamicFieldNotFound":return new $e(e.code,`Dynamic field not found for object ${e.parent_object_id}`);case"deleted":return new $e(e.code,`Object ${e.object_id} has been deleted`);case"displayError":return new $e(e.code,`Display error: ${e.error}`);case"unknown":default:return new $e(e.code,`Unknown error while loading object${t?` ${t}`:""}`)}}}function Bo(n){return{...K.fromBytes(n).snapshot(),bcs:n}}function Do(n){const e=w.TransactionEffects.parse(n);switch(e.$kind){case"V1":return No();case"V2":return Vo({bytes:n,effects:e.V2});default:throw new Error(`Unknown transaction effects version: ${e.$kind}`)}}function No(n){throw new Error("V1 effects are not supported yet")}function Vo({bytes:n,effects:e}){const t=e.changedObjects.map(([r,s])=>({id:r,inputState:s.inputState.$kind==="Exist"?"Exists":"DoesNotExist",inputVersion:s.inputState.Exist?.[0][0]??null,inputDigest:s.inputState.Exist?.[0][1]??null,inputOwner:s.inputState.Exist?.[1]??null,outputState:s.outputState.$kind==="NotExist"?"DoesNotExist":s.outputState.$kind,outputVersion:s.outputState.$kind==="PackageWrite"?s.outputState.PackageWrite?.[0]:s.outputState.ObjectWrite?e.lamportVersion:null,outputDigest:s.outputState.$kind==="PackageWrite"?s.outputState.PackageWrite?.[1]:s.outputState.ObjectWrite?.[0]??null,outputOwner:s.outputState.ObjectWrite?s.outputState.ObjectWrite[1]:null,idOperation:s.idOperation.$kind}));return{bcs:n,digest:e.transactionDigest,version:2,status:e.status.$kind==="Success"?{success:!0,error:null}:{success:!1,error:e.status.Failed.error.$kind},gasUsed:e.gasUsed,transactionDigest:e.transactionDigest,gasObject:e.gasObjectIndex===null?null:t[e.gasObjectIndex]??null,eventsDigest:e.eventsDigest,dependencies:e.dependencies,lamportVersion:e.lamportVersion,changedObjects:t,unchangedSharedObjects:e.unchangedSharedObjects.map(([r,s])=>({kind:s.$kind==="MutateDeleted"?"MutateConsensusStreamEnded":s.$kind==="ReadDeleted"?"ReadConsensusStreamEnded":s.$kind,objectId:r,version:s.$kind==="ReadOnlyRoot"?s.ReadOnlyRoot[0]:s[s.$kind],digest:s.$kind==="ReadOnlyRoot"?s.ReadOnlyRoot[1]:null})),auxiliaryDataDigest:e.auxDataDigest}}var ys=n=>{throw TypeError(n)},bs=(n,e,t)=>e.has(n)||ys("Cannot "+t),Y=(n,e,t)=>(bs(n,e,"read from private field"),t?t.call(n):e.get(n)),zo=(n,e,t)=>e.has(n)?ys("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Fo=(n,e,t,r)=>(bs(n,e,"write to private field"),e.set(n,t),t),L;class Lo extends Uo{constructor({jsonRpcClient:e,mvr:t}){super({network:e.network,base:e,mvr:t}),zo(this,L),Fo(this,L,e)}async getObjects(e){const t=kt(e.objectIds,50),r=[];for(const s of t){const i=await Y(this,L).multiGetObjects({ids:s,options:{showOwner:!0,showType:!0,showBcs:!0},signal:e.signal});for(const[a,c]of i.entries())c.error?r.push($e.fromResponse(c.error,s[a])):r.push(ws(c.data))}return{objects:r}}async getOwnedObjects(e){const t=await Y(this,L).getOwnedObjects({owner:e.address,limit:e.limit,cursor:e.cursor,options:{showOwner:!0,showType:!0,showBcs:!0},filter:e.type?{StructType:e.type}:null,signal:e.signal});return{objects:t.data.map(r=>{if(r.error)throw $e.fromResponse(r.error);return ws(r.data)}),hasNextPage:t.hasNextPage,cursor:t.nextCursor??null}}async getCoins(e){const t=await Y(this,L).getCoins({owner:e.address,coinType:e.coinType,limit:e.limit,cursor:e.cursor,signal:e.signal});return{objects:t.data.map(r=>({id:r.coinObjectId,version:r.version,digest:r.digest,balance:r.balance,type:`0x2::coin::Coin<${r.coinType}>`,content:Promise.resolve(Ko.serialize({id:r.coinObjectId,balance:{value:r.balance}}).toBytes()),owner:{$kind:"ObjectOwner",ObjectOwner:e.address}})),hasNextPage:t.hasNextPage,cursor:t.nextCursor??null}}async getBalance(e){const t=await Y(this,L).getBalance({owner:e.address,coinType:e.coinType,signal:e.signal});return{balance:{coinType:t.coinType,balance:t.totalBalance}}}async getAllBalances(e){return{balances:(await Y(this,L).getAllBalances({owner:e.address,signal:e.signal})).map(r=>({coinType:r.coinType,balance:r.totalBalance})),hasNextPage:!1,cursor:null}}async getTransaction(e){const t=await Y(this,L).getTransactionBlock({digest:e.digest,options:{showRawInput:!0,showObjectChanges:!0,showRawEffects:!0,showEvents:!0,showEffects:!0},signal:e.signal});return{transaction:vs(t)}}async executeTransaction(e){const t=await Y(this,L).executeTransactionBlock({transactionBlock:e.transaction,signature:e.signatures,options:{showRawEffects:!0,showEvents:!0,showObjectChanges:!0,showRawInput:!0,showEffects:!0},signal:e.signal});return{transaction:vs(t)}}async dryRunTransaction(e){const t=xo.from(e.transaction),r=await Y(this,L).dryRunTransactionBlock({transactionBlock:e.transaction,signal:e.signal}),{effects:s,objectTypes:i}=Wo({effects:r.effects,objectChanges:r.objectChanges});return{transaction:{digest:await t.getDigest(),epoch:null,effects:s,objectTypes:Promise.resolve(i),signatures:[],transaction:Bo(e.transaction)}}}async getReferenceGasPrice(e){const t=await Y(this,L).getReferenceGasPrice({signal:e?.signal});return{referenceGasPrice:String(t)}}async getDynamicFields(e){const t=await Y(this,L).getDynamicFields({parentId:e.parentId,limit:e.limit,cursor:e.cursor});return{dynamicFields:t.data.map(r=>({id:r.objectId,type:r.objectType,name:{type:r.name.type,bcs:H(r.bcsName)}})),hasNextPage:t.hasNextPage,cursor:t.nextCursor}}async verifyZkLoginSignature(e){const t=await Y(this,L).verifyZkLoginSignature({bytes:e.bytes,signature:e.signature,intentScope:e.intentScope,author:e.author});return{success:t.success,errors:t.errors}}resolveNameServiceNames(e){return Y(this,L).resolveNameServiceNames(e)}resolveTransactionPlugin(){return Yr(Y(this,L))}}L=new WeakMap;function ws(n){return{id:n.objectId,version:n.version,digest:n.digest,type:n.type,content:Promise.resolve(n.bcs?.dataType==="moveObject"?H(n.bcs.bcsBytes):new Uint8Array),owner:Ye(n.owner)}}function Ye(n){if(n==="Immutable")return{$kind:"Immutable",Immutable:!0};if("ConsensusAddressOwner"in n)return{$kind:"ConsensusAddressOwner",ConsensusAddressOwner:{owner:n.ConsensusAddressOwner.owner,startVersion:n.ConsensusAddressOwner.start_version}};if("AddressOwner"in n)return{$kind:"AddressOwner",AddressOwner:n.AddressOwner};if("ObjectOwner"in n)return{$kind:"ObjectOwner",ObjectOwner:n.ObjectOwner};if("Shared"in n)return{$kind:"Shared",Shared:{initialSharedVersion:n.Shared.initial_shared_version}};throw new Error(`Unknown owner type: ${JSON.stringify(n)}`)}function vs(n){const e=w.SenderSignedData.parse(H(n.rawTransaction))[0],t={};n.objectChanges?.forEach(i=>{i.type!=="published"&&(t[i.objectId]=i.objectType)});const r=w.TransactionData.serialize(e.intentMessage.value).toBytes(),s=K.restore({version:2,sender:e.intentMessage.value.V1.sender,expiration:e.intentMessage.value.V1.expiration,gasData:e.intentMessage.value.V1.gasData,inputs:e.intentMessage.value.V1.kind.ProgrammableTransaction.inputs,commands:e.intentMessage.value.V1.kind.ProgrammableTransaction.commands});return{digest:n.digest,epoch:n.effects?.executedEpoch??null,effects:Do(new Uint8Array(n.rawEffects)),objectTypes:Promise.resolve(t),transaction:{...s,bcs:r},signatures:e.txSignatures}}function Wo({bytes:n,effects:e,objectChanges:t}){const r=[],s=[],i={};return t?.forEach(a=>{switch(a.type){case"published":r.push({id:a.packageId,inputState:"DoesNotExist",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"PackageWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:null,idOperation:"Created"});break;case"transferred":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:a.digest,inputOwner:{$kind:"AddressOwner",AddressOwner:a.sender},outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:Ye(a.recipient),idOperation:"None"}),i[a.objectId]=a.objectType;break;case"mutated":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.previousVersion,inputDigest:null,inputOwner:Ye(a.owner),outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:Ye(a.owner),idOperation:"None"}),i[a.objectId]=a.objectType;break;case"deleted":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:e.deleted?.find(c=>c.objectId===a.objectId)?.digest??null,inputOwner:null,outputState:"DoesNotExist",outputVersion:null,outputDigest:null,outputOwner:null,idOperation:"Deleted"}),i[a.objectId]=a.objectType;break;case"wrapped":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:null,inputOwner:{$kind:"AddressOwner",AddressOwner:a.sender},outputState:"ObjectWrite",outputVersion:a.version,outputDigest:e.wrapped?.find(c=>c.objectId===a.objectId)?.digest??null,outputOwner:{$kind:"ObjectOwner",ObjectOwner:a.sender},idOperation:"None"}),i[a.objectId]=a.objectType;break;case"created":r.push({id:a.objectId,inputState:"DoesNotExist",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:Ye(a.owner),idOperation:"Created"}),i[a.objectId]=a.objectType;break}}),{objectTypes:i,effects:{bcs:n??null,digest:e.transactionDigest,version:2,status:e.status.status==="success"?{success:!0,error:null}:{success:!1,error:e.status.error},gasUsed:e.gasUsed,transactionDigest:e.transactionDigest,gasObject:{id:e.gasObject?.reference.objectId,inputState:"Exists",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"ObjectWrite",outputVersion:e.gasObject.reference.version,outputDigest:e.gasObject.reference.digest,outputOwner:Ye(e.gasObject.owner),idOperation:"None"},eventsDigest:e.eventsDigest??null,dependencies:e.dependencies??[],lamportVersion:e.gasObject.reference.version,changedObjects:r,unchangedSharedObjects:s,auxiliaryDataDigest:null}}}const Go=w.struct("Balance",{value:w.u64()}),Ko=w.struct("Coin",{id:w.Address,balance:Go}),qo=Symbol.for("@mysten/SuiClient");class Ho extends nr{constructor(e){super({network:e.network??"unknown"}),this.jsonRpc=this,this.transport=e.transport??new Bs({url:e.url}),this.core=new Lo({jsonRpcClient:this,mvr:e.mvr})}get[qo](){return!0}async getRpcApiVersion({signal:e}={}){return(await this.transport.request({method:"rpc.discover",params:[],signal:e})).info.version}async getCoins({coinType:e,owner:t,cursor:r,limit:s,signal:i}){if(!t||!ae(E(t)))throw new Error("Invalid Sui address");return e&&q(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getCoins",params:[t,e,r,s],signal:i})}async getAllCoins(e){if(!e.owner||!ae(E(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllCoins",params:[e.owner,e.cursor,e.limit],signal:e.signal})}async getBalance({owner:e,coinType:t,signal:r}){if(!e||!ae(E(e)))throw new Error("Invalid Sui address");return t&&q(t)&&(t=(await this.core.mvr.resolveType({type:t})).type),await this.transport.request({method:"suix_getBalance",params:[e,t],signal:r})}async getAllBalances(e){if(!e.owner||!ae(E(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllBalances",params:[e.owner],signal:e.signal})}async getCoinMetadata({coinType:e,signal:t}){return e&&q(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getCoinMetadata",params:[e],signal:t})}async getTotalSupply({coinType:e,signal:t}){return e&&q(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getTotalSupply",params:[e],signal:t})}async call(e,t,{signal:r}={}){return await this.transport.request({method:e,params:t,signal:r})}async getMoveFunctionArgTypes({package:e,module:t,function:r,signal:s}){return e&&J(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getMoveFunctionArgTypes",params:[e,t,r],signal:s})}async getNormalizedMoveModulesByPackage({package:e,signal:t}){return e&&J(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveModulesByPackage",params:[e],signal:t})}async getNormalizedMoveModule({package:e,module:t,signal:r}){return e&&J(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveModule",params:[e,t],signal:r})}async getNormalizedMoveFunction({package:e,module:t,function:r,signal:s}){return e&&J(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveFunction",params:[e,t,r],signal:s})}async getNormalizedMoveStruct({package:e,module:t,struct:r,signal:s}){return e&&J(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveStruct",params:[e,t,r],signal:s})}async getOwnedObjects(e){if(!e.owner||!ae(E(e.owner)))throw new Error("Invalid Sui address");const t=e.filter?{...e.filter}:void 0;return t&&"MoveModule"in t&&J(t.MoveModule.package)?t.MoveModule={module:t.MoveModule.module,package:(await this.core.mvr.resolvePackage({package:t.MoveModule.package})).package}:t&&"StructType"in t&&q(t.StructType)&&(t.StructType=(await this.core.mvr.resolveType({type:t.StructType})).type),await this.transport.request({method:"suix_getOwnedObjects",params:[e.owner,{filter:t,options:e.options},e.cursor,e.limit],signal:e.signal})}async getObject(e){if(!e.id||!_t(be(e.id)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"sui_getObject",params:[e.id,e.options],signal:e.signal})}async tryGetPastObject(e){return await this.transport.request({method:"sui_tryGetPastObject",params:[e.id,e.version,e.options],signal:e.signal})}async multiGetObjects(e){if(e.ids.forEach(r=>{if(!r||!_t(be(r)))throw new Error(`Invalid Sui Object id ${r}`)}),e.ids.length!==new Set(e.ids).size)throw new Error(`Duplicate object ids in batch call ${e.ids}`);return await this.transport.request({method:"sui_multiGetObjects",params:[e.ids,e.options],signal:e.signal})}async queryTransactionBlocks({filter:e,options:t,cursor:r,limit:s,order:i,signal:a}){return e&&"MoveFunction"in e&&J(e.MoveFunction.package)&&(e={...e,MoveFunction:{package:(await this.core.mvr.resolvePackage({package:e.MoveFunction.package})).package}}),await this.transport.request({method:"suix_queryTransactionBlocks",params:[{filter:e,options:t},r,s,(i||"descending")==="descending"],signal:a})}async getTransactionBlock(e){if(!ar(e.digest))throw new Error("Invalid Transaction digest");return await this.transport.request({method:"sui_getTransactionBlock",params:[e.digest,e.options],signal:e.signal})}async multiGetTransactionBlocks(e){if(e.digests.forEach(r=>{if(!ar(r))throw new Error(`Invalid Transaction digest ${r}`)}),e.digests.length!==new Set(e.digests).size)throw new Error(`Duplicate digests in batch call ${e.digests}`);return await this.transport.request({method:"sui_multiGetTransactionBlocks",params:[e.digests,e.options],signal:e.signal})}async executeTransactionBlock({transactionBlock:e,signature:t,options:r,requestType:s,signal:i}){const a=await this.transport.request({method:"sui_executeTransactionBlock",params:[typeof e=="string"?e:z(e),Array.isArray(t)?t:[t],r],signal:i});if(s==="WaitForLocalExecution")try{await this.waitForTransaction({digest:a.digest})}catch{}return a}async signAndExecuteTransaction({transaction:e,signer:t,...r}){let s;e instanceof Uint8Array?s=e:(e.setSenderIfNotSet(t.toSuiAddress()),s=await e.build({client:this}));const{signature:i,bytes:a}=await t.signTransaction(s);return this.executeTransactionBlock({transactionBlock:a,signature:i,...r})}async getTotalTransactionBlocks({signal:e}={}){const t=await this.transport.request({method:"sui_getTotalTransactionBlocks",params:[],signal:e});return BigInt(t)}async getReferenceGasPrice({signal:e}={}){const t=await this.transport.request({method:"suix_getReferenceGasPrice",params:[],signal:e});return BigInt(t)}async getStakes(e){if(!e.owner||!ae(E(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getStakes",params:[e.owner],signal:e.signal})}async getStakesByIds(e){return e.stakedSuiIds.forEach(t=>{if(!t||!_t(be(t)))throw new Error(`Invalid Sui Stake id ${t}`)}),await this.transport.request({method:"suix_getStakesByIds",params:[e.stakedSuiIds],signal:e.signal})}async getLatestSuiSystemState({signal:e}={}){return await this.transport.request({method:"suix_getLatestSuiSystemState",params:[],signal:e})}async queryEvents({query:e,cursor:t,limit:r,order:s,signal:i}){return e&&"MoveEventType"in e&&q(e.MoveEventType)&&(e={...e,MoveEventType:(await this.core.mvr.resolveType({type:e.MoveEventType})).type}),e&&"MoveEventModule"in e&&J(e.MoveEventModule.package)&&(e={...e,MoveEventModule:{module:e.MoveEventModule.module,package:(await this.core.mvr.resolvePackage({package:e.MoveEventModule.package})).package}}),"MoveModule"in e&&J(e.MoveModule.package)&&(e={...e,MoveModule:{module:e.MoveModule.module,package:(await this.core.mvr.resolvePackage({package:e.MoveModule.package})).package}}),await this.transport.request({method:"suix_queryEvents",params:[e,t,r,(s||"descending")==="descending"],signal:i})}async subscribeEvent(e){return this.transport.subscribe({method:"suix_subscribeEvent",unsubscribe:"suix_unsubscribeEvent",params:[e.filter],onMessage:e.onMessage,signal:e.signal})}async subscribeTransaction(e){return this.transport.subscribe({method:"suix_subscribeTransaction",unsubscribe:"suix_unsubscribeTransaction",params:[e.filter],onMessage:e.onMessage,signal:e.signal})}async devInspectTransactionBlock(e){let t;if(fs(e.transactionBlock))e.transactionBlock.setSenderIfNotSet(e.sender),t=z(await e.transactionBlock.build({client:this,onlyTransactionKind:!0}));else if(typeof e.transactionBlock=="string")t=e.transactionBlock;else if(e.transactionBlock instanceof Uint8Array)t=z(e.transactionBlock);else throw new Error("Unknown transaction block format.");return e.signal?.throwIfAborted(),await this.transport.request({method:"sui_devInspectTransactionBlock",params:[e.sender,t,e.gasPrice?.toString(),e.epoch],signal:e.signal})}async dryRunTransactionBlock(e){return await this.transport.request({method:"sui_dryRunTransactionBlock",params:[typeof e.transactionBlock=="string"?e.transactionBlock:z(e.transactionBlock)]})}async getDynamicFields(e){if(!e.parentId||!_t(be(e.parentId)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"suix_getDynamicFields",params:[e.parentId,e.cursor,e.limit],signal:e.signal})}async getDynamicFieldObject(e){return await this.transport.request({method:"suix_getDynamicFieldObject",params:[e.parentId,e.name],signal:e.signal})}async getLatestCheckpointSequenceNumber({signal:e}={}){const t=await this.transport.request({method:"sui_getLatestCheckpointSequenceNumber",params:[],signal:e});return String(t)}async getCheckpoint(e){return await this.transport.request({method:"sui_getCheckpoint",params:[e.id],signal:e.signal})}async getCheckpoints(e){return await this.transport.request({method:"sui_getCheckpoints",params:[e.cursor,e?.limit,e.descendingOrder],signal:e.signal})}async getCommitteeInfo(e){return await this.transport.request({method:"suix_getCommitteeInfo",params:[e?.epoch],signal:e?.signal})}async getNetworkMetrics({signal:e}={}){return await this.transport.request({method:"suix_getNetworkMetrics",params:[],signal:e})}async getAddressMetrics({signal:e}={}){return await this.transport.request({method:"suix_getLatestAddressMetrics",params:[],signal:e})}async getEpochMetrics(e){return await this.transport.request({method:"suix_getEpochMetrics",params:[e?.cursor,e?.limit,e?.descendingOrder],signal:e?.signal})}async getAllEpochAddressMetrics(e){return await this.transport.request({method:"suix_getAllEpochAddressMetrics",params:[e?.descendingOrder],signal:e?.signal})}async getEpochs(e){return await this.transport.request({method:"suix_getEpochs",params:[e?.cursor,e?.limit,e?.descendingOrder],signal:e?.signal})}async getMoveCallMetrics({signal:e}={}){return await this.transport.request({method:"suix_getMoveCallMetrics",params:[],signal:e})}async getCurrentEpoch({signal:e}={}){return await this.transport.request({method:"suix_getCurrentEpoch",params:[],signal:e})}async getValidatorsApy({signal:e}={}){return await this.transport.request({method:"suix_getValidatorsApy",params:[],signal:e})}async getChainIdentifier({signal:e}={}){const t=await this.getCheckpoint({id:"0",signal:e}),r=st(t.digest);return Ke(r.slice(0,4))}async resolveNameServiceAddress(e){return await this.transport.request({method:"suix_resolveNameServiceAddress",params:[e.name],signal:e.signal})}async resolveNameServiceNames({format:e="dot",...t}){const{nextCursor:r,hasNextPage:s,data:i}=await this.transport.request({method:"suix_resolveNameServiceNames",params:[t.address,t.cursor,t.limit],signal:t.signal});return{hasNextPage:s,nextCursor:r,data:i.map(a=>wi(a,e))}}async getProtocolConfig(e){return await this.transport.request({method:"sui_getProtocolConfig",params:[e?.version],signal:e?.signal})}async verifyZkLoginSignature(e){return await this.transport.request({method:"sui_verifyZkLoginSignature",params:[e.bytes,e.signature,e.intentScope,e.author],signal:e.signal})}async waitForTransaction({signal:e,timeout:t=60*1e3,pollInterval:r=2*1e3,...s}){const i=AbortSignal.timeout(t),a=new Promise((c,u)=>{i.addEventListener("abort",()=>u(i.reason))});for(a.catch(()=>{});!i.aborted;){e?.throwIfAborted();try{return await this.getTransactionBlock(s)}catch{await Promise.race([new Promise(u=>setTimeout(u,r)),a])}}throw i.throwIfAborted(),new Error("Unexpected error while waiting for transaction block.")}experimental_asClientExtension(){return{name:"jsonRPC",register:()=>this}}}var Jo=function(n,e,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?n!==e||!r:!e.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(n):r?r.value:e.get(n)},Xo=function(n,e,t,r,s){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?n!==e||!s:!e.has(n))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?s.call(n,t):s?s.value=t:e.set(n,t),t},zt;let yt;const Ft=new Set;function Zo(n){bt=void 0,Ft.add(n)}function Yo(n){bt=void 0,Ft.delete(n)}const Qe={};function Qo(){if(yt||(yt=Object.freeze({register:Ss,get:ec,on:tc}),typeof window>"u"))return yt;const n=Object.freeze({register:Ss});try{window.addEventListener("wallet-standard:register-wallet",({detail:e})=>e(n))}catch(e){console.error(`wallet-standard:register-wallet event listener could not be added
`,e)}try{window.dispatchEvent(new nc(n))}catch(e){console.error(`wallet-standard:app-ready event could not be dispatched
`,e)}return yt}function Ss(...n){return n=n.filter(e=>!Ft.has(e)),n.length?(n.forEach(e=>Zo(e)),Qe.register?.forEach(e=>ks(()=>e(...n))),function(){n.forEach(t=>Yo(t)),Qe.unregister?.forEach(t=>ks(()=>t(...n)))}):()=>{}}let bt;function ec(){return bt||(bt=[...Ft]),bt}function tc(n,e){return Qe[n]?.push(e)||(Qe[n]=[e]),function(){Qe[n]=Qe[n]?.filter(r=>e!==r)}}function ks(n){try{n()}catch(e){console.error(e)}}class nc extends Event{get detail(){return Jo(this,zt,"f")}get type(){return"wallet-standard:app-ready"}constructor(e){super("wallet-standard:app-ready",{bubbles:!1,cancelable:!1,composed:!1}),zt.set(this,void 0),Xo(this,zt,e,"f")}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}}zt=new WeakMap;function rc(){const n=Array.from(document.querySelectorAll("img[data-src]"));if(!n.length)return;const e=t=>{const r=t.dataset.src;r&&(t.src=r,delete t.dataset.src)};if("IntersectionObserver"in window){const t=new IntersectionObserver((r,s)=>{for(const i of r){if(!i.isIntersecting)continue;const a=i.target;e(a),s.unobserve(a)}},{rootMargin:"64px"});n.forEach(r=>t.observe(r))}else n.forEach(e)}const Os={getFullnodeUrl:Ds,SuiClient:Ho,normalizeSuiAddress:E},Es={getWallets:Qo},js={lazyLoadImages:rc};window.SuiSDK?(window.SuiSDK.Sui={...window.SuiSDK.Sui,...Os},window.SuiSDK.WalletStandard={...window.SuiSDK.WalletStandard,...Es},window.SuiSDK.Utils={...window.SuiSDK.Utils||{},...js}):(console.warn("SuiSDK shell not found, creating core SDK directly"),window.SuiSDK={Sui:Os,WalletStandard:Es,Utils:js})})();
