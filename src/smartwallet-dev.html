<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmartWallet UI</title>

    <!-- Dev favicon: served from assets; injector may override in prod -->
    <link rel="icon" type="image/png" href="/assets/favicon-128.png">
    <script>
        // Optimized favicon loading - defer until critical content loads
        window.addEventListener('load',function(){
            const link=document.querySelector('link[rel="icon"]');
            if(link&&link.href){
                window.getSmartWalletIconUrl=function(){return link.href};
                const styleEl=document.createElement('style');
                styleEl.id='sw-favicon-var';
                styleEl.textContent=`:root{--sw-favicon-url:url("${link.href}")}`;
                (document.body||document.head).appendChild(styleEl);
            }
        });
    </script>
    <!-- Critical CSS for immediate rendering -->
    <style>
        html {
            height: 100%;
            overflow-y: auto;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a2332 0%, #2a3d52 100%);
            color: #f4f1ef;
            min-height: 100vh;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .container {
            background: linear-gradient(145deg, #1e3a52 0%, #2d4a66 100%);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            border: 1px solid rgba(69, 139, 189, 0.3);
        }
        h1 {
            color: #f4f1ef;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* Loading screen styles */
        .app-loading {
            text-align: center;
            margin-top: 50px;
            color: #c3d5e8;
        }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(69, 139, 189, 0.3);
            border-radius: 50%;
            border-top-color: #458BBD;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Loading screen transitions - very fast fade */
        #loading-screen {
            transition: opacity 0.1s ease-out;
        }
        
        /* Hide main content until loaded */
        .main-content {
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        .main-content.loaded {
            opacity: 1;
        }

        /* Sections fade in smoothly */
        .section {
            margin:20px 0;padding:20px;border:1px solid rgba(69,139,189,.4);border-radius:10px;background:linear-gradient(145deg,rgba(30,58,82,.6),rgba(45,74,102,.6));backdrop-filter:blur(10px);display:none;opacity:0;transition:opacity .5s ease-in;
        }
        .section.visible {
            opacity: 1;
        }
        
        /* Critical elements - optimized */
        body,.container,h1{visibility:visible!important}
        .section h3{margin-top:0;color:#c3d5e8;text-shadow:0 1px 2px rgba(0,0,0,.3)}
        :root{--sw-favicon-url:initial}
        .sw-icon{display:inline-block;width:1em;height:1em;background-image:var(--sw-favicon-url);background-size:contain;background-repeat:no-repeat;vertical-align:-.15em}
        button{background:linear-gradient(145deg,#458BBD,#5A9BD4);color:#f4f1ef;border:none;padding:10px 20px;border-radius:8px;cursor:pointer;margin:5px;font-size:14px;transition:all .3s ease;box-shadow:0 3px 8px rgba(0,0,0,.3);border:1px solid rgba(90,155,212,.3)}
        button:hover{background:linear-gradient(145deg,#5A9BD4,#6BB6FF);transform:translateY(-1px);box-shadow:0 6px 12px rgba(0,0,0,.4)}
        button:disabled{background:rgba(69,139,189,.4);cursor:not-allowed;transform:none;color:rgba(244,241,239,.5)}
        .primary-btn{border-radius:12px;padding:15px 25px;font-size:16px;font-weight:600;box-shadow:0 6px 15px rgba(0,0,0,.25);border:1px solid rgba(69,139,189,.5);cursor:pointer;transition:all .3s ease;background:linear-gradient(145deg,#2d4a66,#458BBD)}
        .primary-btn:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,.35);background:linear-gradient(145deg,#458BBD,#5A9BD4)}
        input[type="text"],input[type="number"],input[type="password"],textarea{padding:12px;border:1px solid rgba(69,139,189,.4);border-radius:8px;margin:5px;background:rgba(30,58,82,.3);color:#f4f1ef;backdrop-filter:blur(5px);font-size:14px}
        .copy-btn{margin:0 0 0 8px;padding:6px 10px;font-size:12px;line-height:1;border-radius:6px;background:rgba(69,139,189,.6);border:1px solid rgba(69,139,189,.5);box-shadow:none}
        .copy-btn:hover{background:rgba(90,155,212,.85)}
        .copy-btn:disabled{opacity:.6;cursor:not-allowed}
        .copy-btn[data-copied="true"]{background:#2e7d32;border-color:#2e7d32;color:#fff}
        .address-row,.address-display{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
        .address-value{font-family:'Courier New',monospace;font-size:13px;word-break:break-all}
        .wallet-heading{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:10px}
        .wallet-suins{display:inline-flex;align-items:center;gap:6px;padding:2px 6px;border-radius:6px;background:rgba(69,139,189,.2);font-size:12px;color:#aedaef}
        input[type="text"]:focus,input[type="number"]:focus,input[type="password"]:focus,textarea:focus{outline:none;border-color:#5A9BD4;box-shadow:0 0 10px rgba(90,155,212,.3)}
        input::placeholder,textarea::placeholder{color:rgba(244,241,239,.6)}
        #output{background:#2c3e50;color:#ecf0f1;padding:15px;border-radius:5px;font-family:'Courier New',monospace;font-size:12px;max-height:300px;overflow-y:auto;white-space:pre-wrap;margin-top:20px}
        .wallet-connection-header{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:12px;margin-bottom:12px}
        .wallet-connection-header h3{margin:0}
        .connect-wallet-inline{padding:8px 16px;font-size:14px;background:linear-gradient(145deg,#4CAF50,#45a049);box-shadow:0 4px 12px rgba(0,0,0,.25);}
        .connect-wallet-inline:hover{background:linear-gradient(145deg,#45a049,#3f8f44)}
        .connect-wallet-inline.disconnect{background:#dc3545;box-shadow:0 4px 12px rgba(0,0,0,.25);border:1px solid rgba(220,53,69,.6);}
        .connect-wallet-inline.disconnect:hover{background:#c82333}
        .balance-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
        .balance-value{font-family:'Courier New',monospace;}
        .balance-refresh{margin:0;padding:6px 10px;font-size:12px;line-height:1;border-radius:6px;background:rgba(69,139,189,.6);border:1px solid rgba(69,139,189,.5);color:#f4f1ef;cursor:pointer;transition:background .2s ease;box-shadow:none}
        .balance-refresh:hover{background:rgba(90,155,212,.85)}
        @media (max-width:600px){.wallet-connection-header{flex-direction:column;align-items:stretch}.wallet-connection-header h3{text-align:left}.connect-wallet-inline{width:100%}}
        .wallet-info{background:linear-gradient(145deg,#1f3b2f,#254836);border-left:4px solid #27ae60;padding:12px;margin:12px 0;border-radius:10px;color:#e6f2e6}
        .wallet-info strong{color:#f4fff4}
        .error{background:#fdf2f2;border-left:4px solid #e74c3c;padding:10px;margin:10px 0;color:#c0392b}
        .success{background:#d4edda;border-left:4px solid #28a745;padding:10px;margin:10px 0;color:#155724}
        
        /* Contract-specific styles */
        .contract-card {
            background: linear-gradient(145deg, rgba(45,74,102,.8), rgba(30,58,82,.8));
            border: 1px solid rgba(69,139,189,.5);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
        }
        .contract-card-group {
            margin-top: 20px;
            padding-top: 18px;
            border-top: 1px solid rgba(69,139,189,.28);
        }
        details.section-toggle {
            border: 1px solid rgba(69,139,189,.35);
            border-radius: 10px;
            background: linear-gradient(145deg, rgba(30,58,82,.65), rgba(45,74,102,.65));
            box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
        }
        details.section-toggle summary {
            cursor: pointer;
            font-weight: 600;
            color: #cfe4f7;
            font-size: 15px;
            padding: 14px 18px;
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        details.section-toggle summary .summary-status {
            font-size: 12px;
            color: #8fb9df;
            font-weight: 500;
        }
        details.section-toggle summary::-webkit-details-marker { display: none; }
        details.section-toggle summary::after {
            content: '‚ñæ';
            font-size: 14px;
            transition: transform .2s ease;
            color: #8fb9df;
        }
        details.section-toggle[open] summary::after {
            transform: rotate(180deg);
        }
        details.section-toggle[open] summary {
            border-bottom: 1px solid rgba(69,139,189,.25);
            background: rgba(69,139,189,.12);
        }
        details.section-toggle[data-connected="true"] summary {
            background: rgba(39, 174, 96, .12);
            border-bottom-color: rgba(39, 174, 96, .25);
            color: #bff5d6;
        }
        details.section-toggle[data-connected="true"] summary::after {
            color: #7edc8f;
        }
        details.section-toggle[data-connected="true"] summary .summary-status {
            color: #7edc8f;
        }
        details.section-toggle .contract-card {
            margin: 0;
            border: none;
            border-radius: 0 0 10px 10px;
        }
        .address-display {
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,.3);
            padding: 8px;
            border-radius: 5px;
            word-break: break-all;
            font-size: 12px;
        }
        .form-group {
            margin: 15px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #c3d5e8;
            font-weight: 500;
        }
        .form-group input, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }
        .proposal-card {
            background: rgba(69,139,189,.1);
            border: 1px solid rgba(69,139,189,.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .approval-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .approval-status.pending { background: #ffc107; color: #000; }
        .approval-status.approved { background: #28a745; color: #fff; }
        .approval-status.executed { background: #6c757d; color: #fff; }

        /* Modal styles */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; align-items: center; justify-content: center; z-index: 1000; }
        .modal-overlay.visible { display: flex; }
        .modal { width: min(600px, 92vw); max-height: 80vh; overflow: hidden; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 1px solid rgba(69,139,189,.4); background: linear-gradient(145deg, #1e3a52 0%, #2d4a66 100%); }
        .modal-header { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; border-bottom: 1px solid rgba(69,139,189,.3); }
        .modal-title { margin: 0; font-size: 16px; color: #cfe4f7; font-weight: 600; }
        .modal-close { background: transparent; border: none; color: #cfe4f7; font-size: 18px; cursor: pointer; padding: 6px 8px; }
        .modal-body { padding: 12px 16px; max-height: calc(80vh - 56px); overflow-y: auto; }
        .wallet-card { display: flex; align-items: center; justify-content: space-between; gap: 12px; border: 1px solid rgba(69,139,189,.3); border-radius: 8px; padding: 12px; background: rgba(69,139,189,.08); margin: 10px 0; width: 100%; cursor: pointer; text-align: left; color: inherit; font: inherit; transition: border-color .2s ease, background .2s ease, transform .1s ease; position: relative; }
        .wallet-card::after { content: '‚Üí'; font-size: 16px; color: #8fb9df; margin-left: auto; display: inline-flex; align-items: center; }
        .wallet-card:hover { border-color: rgba(90,155,212,.6); background: rgba(69,139,189,.15); transform: translateY(-1px); }
        .wallet-card:focus-visible { outline: 2px solid rgba(90,155,212,.8); outline-offset: 2px; }
        .wallet-card-icon-wrap { width: 42px; height: 42px; border-radius: 12px; overflow: hidden; flex-shrink: 0; display: flex; align-items: center; justify-content: center; background: rgba(69,139,189,.12); border: 1px solid rgba(69,139,189,.2); }
        .wallet-card-icon { width: 100%; height: 100%; object-fit: cover; display: block; }
        .wallet-card-content { flex: 1; min-width: 0; }
        .wallet-card-name { font-weight: 600; color: #cfe4f7; }

        /* zkLogin provider selection styles */
        .zklogin-providers { position: relative; display: inline-block; width: 100%; }
        .zklogin-providers .wallet-card { margin: 0; }
        .zklogin-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: linear-gradient(145deg, #1e3a52 0%, #2d4a66 100%); border: 1px solid rgba(69,139,189,.4); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1001; display: none; margin-top: 4px; }
        .zklogin-dropdown.visible { display: block; }
        .zklogin-provider { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border: none; background: transparent; color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; transition: background .2s ease; }
        .zklogin-provider:hover { background: rgba(69,139,189,.15); }
        .zklogin-provider:first-child { border-radius: 8px 8px 0 0; }
        .zklogin-provider:last-child { border-radius: 0 0 8px 8px; }
        .zklogin-provider:only-child { border-radius: 8px; }
        .zklogin-provider-icon { width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        .zklogin-provider-icon svg { width: 100%; height: 100%; }
        .zklogin-provider-name { font-weight: 500; }
    </style>
    
    <!-- BUNDLE_PLACEHOLDER -->
    <script>
        // Minimal dev bootstrap: ensure global and try to load IIFE bundle when developing.
        window.process={env:{NODE_ENV:'development'}};window.global=window.globalThis||window;
        (function ensureDevSdk(){
            if (window.SuiSDK) return; // Already injected (e.g., in production build)
            try {
                const s=document.createElement('script');
                s.src='/dist/sui-sdk-bundle.iife.js';
                s.async=false;
                s.onload=function(){console.log('Dev SDK bundle loaded');};
                s.onerror=function(){console.warn('Dev SDK bundle not found. Run "npm run build" or serve dist/.');};
                document.head.appendChild(s);
            } catch(e){console.warn('Failed to attach dev SDK loader:', e);}
        })();

        let zkLoginHelpersPromise=null;
        window.__SMARTWALLET_ZKLOGIN_BASE64=window.__SMARTWALLET_ZKLOGIN_BASE64||'';

        function decodeZkLoginBase64(value){
            if(!value) return '';
            const globalRef=typeof globalThis!=='undefined'?globalThis:window;
            if(typeof globalRef.atob==='function'){
                return globalRef.atob(value);
            }
            if(globalRef.Buffer&&typeof globalRef.Buffer.from==='function'){
                return globalRef.Buffer.from(value,'base64').toString('utf8');
            }
            throw new Error('Base64 decoder unavailable');
        }

        function evaluateZkLoginSource(source){
            const execute=new Function(source);
            execute();
        }

        window.loadZkLoginHelpers=function(){
            if(window.SuiSDK?.ZkLogin?.decodeJwt){
                return Promise.resolve();
            }
            if(zkLoginHelpersPromise){
                return zkLoginHelpersPromise;
            }
            zkLoginHelpersPromise=new Promise((resolve,reject)=>{
                const inlineBundle=window.__SMARTWALLET_ZKLOGIN_BASE64;
                if(inlineBundle){
                    try{
                        evaluateZkLoginSource(decodeZkLoginBase64(inlineBundle));
                        if(window.SuiSDK?.ZkLogin?.decodeJwt){
                            resolve();
                            return;
                        }
                        console.warn('zkLogin helpers inline bundle executed but decodeJwt missing; falling back to network fetch.');
                    }catch(error){
                        console.warn('Inline zkLogin helper load failed, falling back to network bundle.', error);
                    }
                }

                const script=document.createElement('script');
                script.src='/dist/zklogin-helpers.iife.js';
                script.async=true;
                script.onload=function(){
                    if(window.SuiSDK?.ZkLogin?.decodeJwt){
                        resolve();
                    }else{
                        reject(new Error('zkLogin helpers script executed but decodeJwt is unavailable'));
                    }
                };
                script.onerror=function(){
                    reject(new Error('Failed to load zkLogin helper bundle'));
                };
                document.head.appendChild(script);
            }).catch(error=>{
                zkLoginHelpersPromise=null;
                throw error;
            });

            return zkLoginHelpersPromise;
        };
    </script>
    
    <script type="module">
        // Contract Configuration
        const CONTRACT_CONFIG = {
            PACKAGE_IDS: {
                devnet: '',
                testnet: '0xe427ece956321d00164ada40d6d1f4ba7bb9313881dbd1e551ee0fd5e2379723',
                mainnet: ''
            },
            MODULES: {
                WALLET: 'core',
                ROSTER: 'roster',
                MULTISIG: 'multisig'
            }
        };

        function getPackageId() {
            try {
                const key = `vwallet:packageId:${currentNetwork}`;
                const override = localStorage.getItem(key);
                if (override && /^0x[0-9a-fA-F]{40,}$/.test(override)) return override;
            } catch (_) {}
            const ids = CONTRACT_CONFIG.PACKAGE_IDS || {};
            return ids[currentNetwork] || ids.testnet || ids.devnet || ids.mainnet || '';
        }

        // Roster discovery configuration
        const DISCOVERY_CONFIG = {
            // Optional: provide canonical roster IDs per network to avoid discovery
            // Fill these after deployment; leave empty strings to skip
            rosterIds: {
                devnet: '',
                testnet: '0x117a40896e2c86aa96b08206b8540f69240993d196ba35efb06746d9765e4614',
                mainnet: ''
            },
            // Optional: SuiNS name that carries a `roster_id` record in NameRecord.data
            // Example: 'roster.sui' ‚Üí NameRecord.data.roster_id = "0x..."
            suinsName: 'roster.sui'
        };

        const HEX_ADDRESS_RE = /^0x[0-9a-fA-F]{2,}$/;
        const HEX_STRING_RE = /^(0x)?[0-9a-fA-F]{2,}$/;
        const SUINS_NAME_RE = /^[a-z0-9]+(?:[-.][a-z0-9]+)*\.sui$/i;

        let currentWallet = null;
        let currentNetwork = 'testnet'; // Your contracts are on testnet
        let suiClient = null;
        let rosterId = null; // Will store the shared Roster object ID
        let connectedWalletStandard = null; // Will store connected wallet standard wallet
        let walletControlsCollapsed = false;
        let pendingManagementToggle = null;
        const suinsResolutionCache = new Map();
        const suinsReverseCache = new Map();
        let currentReverseLookupToken = 0;
        let sdkReadyPromise = null;
        let bootstrapPromise = null;
        let rosterLookupPromise = null;
        let rosterPrefetchDone = false;


        const ZKLOGIN_CONFIG = {
            GOOGLE_CLIENT_ID: '373405271144-kevesn5h18jt8grqh5cel7jcsu9si73t.apps.googleusercontent.com',
            REDIRECT_PATH: '/auth/callback.html',
            EPOCH_BUFFER: 5,
            KEY_CLAIM_NAME: 'sub',
            PROVER_URL: (typeof window !== 'undefined' && window.ZKLOGIN_PROVER_URL) ? String(window.ZKLOGIN_PROVER_URL) : ''
        };

        let pendingZkLoginContext = null;

        const ENOKI_STORAGE_KEYS = {
            API_KEY: 'smartwallet:enoki:apiKey',
            API_URL: 'smartwallet:enoki:apiUrl'
        };

        let cachedEnokiClient = null;
        let cachedEnokiClientConfig = null;

        function escapeHtml(value) {
            return String(value ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }



        function makeWalletIcon(label, bg, fg = '#ffffff') {
            const text = (label || 'W').toString().trim().slice(0, 2).toUpperCase() || 'W';
            const fontSize = text.length > 1 ? 18 : 22;
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48"><rect width="48" height="48" rx="12" fill="${bg}"/><text x="50%" y="50%" fill="${fg}" font-family="'Segoe UI', 'Inter', sans-serif" font-size="${fontSize}" font-weight="600" text-anchor="middle" dominant-baseline="central">${text}</text></svg>`;
            return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
        }

        function base64ToUint8Array(value) {
            try {
                let binary;
                if (typeof window !== 'undefined' && typeof window.atob === 'function') {
                    binary = window.atob(value);
                } else if (typeof Buffer !== 'undefined') {
                    binary = Buffer.from(value, 'base64').toString('binary');
                } else {
                    throw new Error('No base64 decoder available in this environment');
                }
                const len = binary.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes;
            } catch (error) {
                console.warn('Failed to decode base64 payload', error);
                return null;
            }
        }

        function bytesToHex(bytes) {
            return Array.from(bytes || [], (b) => b.toString(16).padStart(2, '0')).join('');
        }

        function decodeULEB(bytes, offset) {
            let value = 0;
            let shift = 0;
            let position = offset || 0;
            while (position < bytes.length) {
                const byte = bytes[position];
                value |= (byte & 0x7f) << shift;
                position += 1;
                if ((byte & 0x80) === 0) {
                    break;
                }
                shift += 7;
            }
            return { value, nextOffset: position };
        }

        function decodeAddressVector(bytes) {
            if (!(bytes instanceof Uint8Array) || !bytes.length) return [];
            const { value: length, nextOffset } = decodeULEB(bytes, 0);
            const addresses = [];
            let offset = nextOffset;
            for (let i = 0; i < length; i++) {
                const slice = bytes.slice(offset, offset + 32);
                if (slice.length < 32) break;
                addresses.push('0x' + bytesToHex(slice));
                offset += 32;
            }
            return addresses;
        }

        async function fetchRosterWalletMemberships(memberAddress) {
            if (!rosterId) return [];
            try {
                if (!suiClient) {
                    await initializeSuiClient();
                }
                const { Transaction, normalizeSuiAddress } = window.SuiSDK.Sui;
                const normalizedMember = normalizeSuiAddress(memberAddress);
                const tx = new Transaction();
                tx.moveCall({
                    target: `${getPackageId()}::${CONTRACT_CONFIG.MODULES.ROSTER}::wallets_of`,
                    arguments: [
                        tx.object(rosterId),
                        tx.pure.address(normalizedMember)
                    ]
                });

                const inspection = await suiClient.devInspectTransactionBlock({
                    sender: normalizedMember,
                    transactionBlock: tx
                });

                const results = inspection && inspection.results ? inspection.results : [];
                if (!results.length || !Array.isArray(results[0]?.returnValues)) {
                    return [];
                }

                const wallets = [];
                const returnValues = results[0].returnValues;
                for (const entry of returnValues) {
                    if (!entry || entry.length < 1) continue;
                    const raw = entry[0];
                    let bytes = null;
                    if (typeof raw === 'string') {
                        bytes = base64ToUint8Array(raw);
                    } else if (Array.isArray(raw)) {
                        bytes = Uint8Array.from(raw);
                    } else if (raw instanceof Uint8Array) {
                        bytes = raw;
                    }
                    if (!bytes || !bytes.length) continue;
                    const decoded = decodeAddressVector(bytes);
                    for (const addr of decoded) {
                        if (!addr) continue;
                        const normalizedAddr = (window.SuiSDK?.Sui?.normalizeSuiAddress)
                            ? window.SuiSDK.Sui.normalizeSuiAddress(addr)
                            : addr.toLowerCase();
                        if (!wallets.includes(normalizedAddr)) wallets.push(normalizedAddr);
                    }
                }
                return wallets;
            } catch (error) {
                logOutput('Roster membership lookup failed: ' + error.message, true);
                return [];
            }
        }

        function resolveEnokiNetwork(network) {
            switch ((network || '').toLowerCase()) {
                case 'mainnet':
                    return 'mainnet';
                case 'devnet':
                case 'localnet':
                    return 'devnet';
                case 'testnet':
                default:
                    return 'testnet';
            }
        }

        function getEnokiNamespace() {
            try {
                const sdk = window.SuiSDK || {};
                if (sdk.Enoki) return sdk.Enoki;
                if (sdk.EnokiClient) {
                    return { EnokiClient: sdk.EnokiClient };
                }
            } catch (_) {}
            try {
                if (window.EnokiSDK) return window.EnokiSDK;
                if (window.EnokiClient) {
                    return { EnokiClient: window.EnokiClient };
                }
            } catch (_) {}
            return null;
        }

        function getEnokiApiKey() {
            try {
                if (typeof window !== 'undefined' && window.ENOKI_API_KEY) {
                    const value = String(window.ENOKI_API_KEY || '').trim();
                    if (value) return value;
                }
            } catch (_) {}
            try {
                if (typeof localStorage !== 'undefined') {
                    const stored = localStorage.getItem(ENOKI_STORAGE_KEYS.API_KEY);
                    if (stored && stored.trim()) return stored.trim();
                }
            } catch (_) {}
            return '';
        }

        function setEnokiApiKey(apiKey) {
            const value = String(apiKey || '').trim();
            try {
                if (typeof localStorage !== 'undefined') {
                    if (value) {
                        localStorage.setItem(ENOKI_STORAGE_KEYS.API_KEY, value);
                    } else {
                        localStorage.removeItem(ENOKI_STORAGE_KEYS.API_KEY);
                    }
                }
            } catch (_) {}
            try { window.ENOKI_API_KEY = value; } catch (_) {}
            cachedEnokiClient = null;
            cachedEnokiClientConfig = null;
            return value;
        }

        function getEnokiApiUrl() {
            try {
                if (typeof window !== 'undefined' && window.ENOKI_API_URL) {
                    const value = String(window.ENOKI_API_URL || '').trim();
                    if (value) return value;
                }
            } catch (_) {}
            try {
                if (typeof localStorage !== 'undefined') {
                    const stored = localStorage.getItem(ENOKI_STORAGE_KEYS.API_URL);
                    if (stored && stored.trim()) return stored.trim();
                }
            } catch (_) {}
            return '';
        }

        function setEnokiApiUrl(apiUrl) {
            const value = String(apiUrl || '').trim();
            try {
                if (typeof localStorage !== 'undefined') {
                    if (value) {
                        localStorage.setItem(ENOKI_STORAGE_KEYS.API_URL, value);
                    } else {
                        localStorage.removeItem(ENOKI_STORAGE_KEYS.API_URL);
                    }
                }
            } catch (_) {}
            try { window.ENOKI_API_URL = value; } catch (_) {}
            cachedEnokiClient = null;
            cachedEnokiClientConfig = null;
            return value;
        }

        function getEnokiClient({ silent = false } = {}) {
            try {
                const EnokiNS = getEnokiNamespace();
                if (!EnokiNS) {
                    throw new Error('Enoki SDK is not available in the current bundle.');
                }
                const apiKey = getEnokiApiKey();
                if (!apiKey) {
                    throw new Error('Enoki API key not set. Call window.setEnokiApiKey("<API_KEY>") to enable zkLogin signing.');
                }
                const apiUrl = getEnokiApiUrl();
                const configKey = JSON.stringify({ apiKey, apiUrl });
                if (!cachedEnokiClient || cachedEnokiClientConfig !== configKey) {
                    cachedEnokiClient = new EnokiNS.EnokiClient({
                        apiKey,
                        apiUrl: apiUrl || undefined
                    });
                    cachedEnokiClientConfig = configKey;
                }
                return cachedEnokiClient;
            } catch (error) {
                if (!silent) logOutput('Failed to initialize Enoki client: ' + error.message, true);
                throw error;
            }
        }

        function getZkLoginRedirectUri() {
            try {
                if (!window.location || !window.location.origin) {
                    return ZKLOGIN_CONFIG.REDIRECT_PATH || '/auth/callback.html';
                }
                const url = new URL(ZKLOGIN_CONFIG.REDIRECT_PATH || '/auth/callback.html', window.location.origin);
                return url.toString();
            } catch (_) {
                return `${window.location.origin || ''}/auth/callback.html`;
            }
        }

        function mapIssuerToProvider(iss) {
            if (!iss) return 'Unknown Provider';
            const normalized = iss.replace(/^https?:\/\//, '');
            if (normalized.startsWith('accounts.google.com')) return 'Google';
            if (normalized.includes('apple')) return 'Apple';
            if (normalized.includes('facebook')) return 'Facebook';
            try {
                const url = new URL(iss);
                return url.hostname;
            } catch (_) {
                return normalized;
            }
        }

        function buildZkLoginAuthUrl(nonce) {
            const params = new URLSearchParams({
                client_id: ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID,
                redirect_uri: getZkLoginRedirectUri(),
                response_type: 'id_token',
                scope: 'openid email profile',
                nonce: nonce,
                prompt: 'select_account',
                state: 'zklogin_smartwallet'
            });
            return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
        }

        async function prepareZkLoginContext() {
            if (!window.SuiSDK || !window.SuiSDK.ZkLogin || !window.SuiSDK.Sui) {
                throw new Error('Sui SDK not loaded');
            }
            if (!suiClient) {
                await initializeSuiClient();
            }
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            const { getExtendedEphemeralPublicKey } = window.SuiSDK.ZkLogin;

            const enokiClient = getEnokiClient();
            if (!enokiClient) {
                throw new Error('Enoki API key not configured. Call window.setEnokiApiKey("<API_KEY>") before starting zkLogin.');
            }

            const ephemeralKeyPair = Ed25519Keypair.generate();
            const extendedPublicKey = getExtendedEphemeralPublicKey(ephemeralKeyPair.getPublicKey());

            const additionalEpochs = Number(ZKLOGIN_CONFIG.EPOCH_BUFFER ?? 5);
            const nonceResponse = await enokiClient.createZkLoginNonce({
                network: resolveEnokiNetwork(currentNetwork),
                ephemeralPublicKey: ephemeralKeyPair.getPublicKey(),
                additionalEpochs: Number.isFinite(additionalEpochs) ? additionalEpochs : undefined
            });

            return {
                ephemeralKeyPair,
                randomness: nonceResponse.randomness,
                nonce: nonceResponse.nonce,
                maxEpoch: String(nonceResponse.maxEpoch),
                extendedPublicKey,
                provider: 'enoki',
                expiresAt: nonceResponse.estimatedExpiration || null
            };
        }

        function openOAuthPopup(authUrl) {
            return new Promise((resolve, reject) => {
                const popup = window.open(
                    authUrl,
                    'zklogin_oauth',
                    'width=500,height=600,scrollbars=yes,resizable=yes'
                );

                if (!popup) {
                    reject(new Error('Failed to open popup - please allow popups'));
                    return;
                }

                let checkClosed = null;

                const cleanup = () => {
                    window.removeEventListener('message', messageHandler);
                    if (checkClosed) {
                        clearInterval(checkClosed);
                        checkClosed = null;
                    }
                };

                const messageHandler = (event) => {
                    if (event.origin !== window.location.origin) {
                        return;
                    }
                    if (event.data?.type === 'zklogin_oauth_success') {
                        cleanup();
                        resolve(event.data.idToken);
                    } else if (event.data?.type === 'zklogin_oauth_error') {
                        cleanup();
                        reject(new Error('OAuth error: ' + event.data.error));
                    }
                };

                window.addEventListener('message', messageHandler);

                checkClosed = setInterval(() => {
                    if (popup.closed) {
                        cleanup();
                        reject(new Error('OAuth popup was closed by user'));
                    }
                }, 800);
            });
        }

        function validateZkLoginJwt(decodedJwt, expectedNonce, expectedAud) {
            if (!decodedJwt) {
                throw new Error('Missing JWT payload');
            }
            if (!decodedJwt.sub) {
                throw new Error('JWT missing subject (sub)');
            }
            if (!decodedJwt.iss) {
                throw new Error('JWT missing issuer (iss)');
            }
            if (!decodedJwt.nonce) {
                throw new Error('JWT missing nonce');
            }
            if (decodedJwt.nonce !== expectedNonce) {
                throw new Error('Nonce mismatch between request and JWT');
            }
            if (decodedJwt.aud !== expectedAud) {
                throw new Error('Unexpected JWT audience');
            }
            return true;
        }

        // zkLogin provider configuration
        const ZKLOGIN_PROVIDERS = {
            google: {
                name: 'Google',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18A10.85 10.85 0 001 12c0 1.61.39 3.14 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC04"/><path d="M12 4.75c1.61 0 3.06.55 4.22 1.64l3.15-3.15C17.45 1.09 14.97 0 12 0 7.7 0 3.99 2.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>',
                clientId: 'GOOGLE_CLIENT_ID'
            },
            facebook: {
                name: 'Meta',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.927v-8.437H7.078v-3.49h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.49h-2.796v8.437C19.612 23.027 24 18.062 24 12.073z" fill="#1877F2"/></svg>',
                clientId: 'FACEBOOK_CLIENT_ID'
            },
            apple: {
                name: 'Apple',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.71 19.5c-.83 1.24-1.71 2.45-3.05 2.47-1.34.03-1.77-.79-3.29-.79-1.53 0-2 .77-3.27.82-1.31.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.39c.87-1.52 2.43-2.48 4.12-2.51 1.28-.02 2.5.87 3.29.87.78 0 2.26-1.07 3.81-.91.65.03 2.47.26 3.64 1.98-.09.06-2.17 1.28-2.15 3.81.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.19-.69.85-1.83 1.51-2.95 1.42-.15-1.15.41-2.35 1.05-3.11z" fill="#ffffff"/></svg>',
                clientId: 'APPLE_CLIENT_ID'
            }
        };

        function createZkLoginProviderIcon(provider) {
            return ZKLOGIN_PROVIDERS[provider]?.icon || makeWalletIcon('ZK', '#6c4bcc');
        }

        async function ensureZkLoginHelpers() {
            if (window.SuiSDK?.ZkLogin?.decodeJwt) {
                return;
            }
            if (typeof window.loadZkLoginHelpers !== 'function') {
                throw new Error('zkLogin helper loader is not available');
            }
            await window.loadZkLoginHelpers();
            if (!window.SuiSDK?.ZkLogin?.decodeJwt) {
                throw new Error('zkLogin helpers failed to load correctly');
            }
        }

        async function handleZkLoginConnect() {
            try {
                logOutput('üîê Starting zkLogin (Google)...');
                await waitForSDKs();
                if (!suiClient) {
                    await initializeSuiClient();
                }

                pendingZkLoginContext = await prepareZkLoginContext();
                logOutput(`ü™™ Opening Google OAuth... (nonce source: ${pendingZkLoginContext.provider || 'local'})`);

                const authUrl = buildZkLoginAuthUrl(pendingZkLoginContext.nonce);
                const jwt = await openOAuthPopup(authUrl);
                logOutput('‚úÖ Received id_token from provider');

                await ensureZkLoginHelpers();

                const { ZkLogin } = window.SuiSDK;
                if (!ZkLogin) {
                    throw new Error('ZkLogin utilities unavailable in SDK bundle');
                }

                const decodedJwt = ZkLogin.decodeJwt(jwt);
                validateZkLoginJwt(decodedJwt, pendingZkLoginContext.nonce, ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID);

                const enokiClient = getEnokiClient();
                if (!enokiClient) {
                    throw new Error('Enoki API key not configured. Call window.setEnokiApiKey("<API_KEY>") before starting zkLogin.');
                }
                let enokiProfile = null;
                try {
                    enokiProfile = await enokiClient.getZkLogin({ jwt });
                } catch (profileError) {
                    throw new Error('Enoki profile lookup failed: ' + profileError.message);
                }

                const claimName = ZKLOGIN_CONFIG.KEY_CLAIM_NAME || 'sub';
                const claimValue = decodedJwt[claimName] ?? decodedJwt.sub;

                if (!enokiProfile?.salt) {
                    throw new Error('Enoki profile did not return a salt for this login.');
                }
                const salt = enokiProfile.salt;

                const computedAddress = ZkLogin.jwtToAddress(jwt, salt, false);
                const enokiAddress = enokiProfile.address || '';
                const suiAddress = enokiAddress && enokiAddress.toLowerCase() === computedAddress.toLowerCase()
                    ? enokiAddress
                    : computedAddress;

                let addressSeed = ZkLogin.genAddressSeed(salt, claimName, claimValue, decodedJwt.aud);
                let publicIdentifier = ZkLogin.toZkLoginPublicIdentifier(addressSeed, decodedJwt.iss, { legacyAddress: false });

                let signatureInputs = null;
                const signatureMaxEpoch = pendingZkLoginContext.maxEpoch;
                let proverDetails = null;
                const enokiPublicKey = enokiProfile.publicKey || null;
                try {
                    const network = resolveEnokiNetwork(currentNetwork);
                    const zkp = await enokiClient.createZkLoginZkp({
                        network,
                        jwt,
                        maxEpoch: Number(pendingZkLoginContext.maxEpoch),
                        randomness: pendingZkLoginContext.randomness,
                        ephemeralPublicKey: pendingZkLoginContext.ephemeralKeyPair.getPublicKey()
                    });
                    signatureInputs = zkp;
                    proverDetails = {
                        provider: 'enoki',
                        network,
                        receivedAt: Date.now()
                    };
                } catch (proverError) {
                    throw new Error('Enoki proving error: ' + proverError.message);
                }

                currentWallet = {
                    address: suiAddress,
                    type: 'zkLogin',
                    provider: mapIssuerToProvider(decodedJwt.iss),
                    zkLogin: {
                        jwt,
                        payload: decodedJwt,
                        salt,
                        addressSeed: addressSeed.toString(),
                        publicIdentifier: publicIdentifier.toBase64(),
                        publicKey: enokiPublicKey,
                        nonce: pendingZkLoginContext.nonce,
                        randomness: pendingZkLoginContext.randomness,
                        maxEpoch: signatureMaxEpoch,
                        ephemeralPublicKey: pendingZkLoginContext.extendedPublicKey,
                        connectedAt: Date.now(),
                        expiresAt: pendingZkLoginContext.expiresAt || null,
                        signatureInputs,
                        prover: proverDetails,
                        ephemeralKeypair: pendingZkLoginContext.ephemeralKeyPair || null,
                        canSign: Boolean(signatureInputs)
                    }
                };
                connectedWalletStandard = null;

                showCurrentWalletAddress(suiAddress);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `zkLogin (${currentWallet.provider})`;


                // Store zkLogin proof in session storage
                try {
                    const zkLoginSessionData = {
                        address: suiAddress,
                        provider: mapIssuerToProvider(decodedJwt.iss),
                        jwt,
                        payload: decodedJwt,
                        salt,
                        addressSeed: addressSeed.toString(),
                        publicIdentifier: publicIdentifier.toBase64(),
                        publicKey: enokiPublicKey,
                        nonce: pendingZkLoginContext.nonce,
                        randomness: pendingZkLoginContext.randomness,
                        maxEpoch: signatureMaxEpoch,
                        ephemeralPublicKey: pendingZkLoginContext.extendedPublicKey,
                        connectedAt: Date.now(),
                        expiresAt: pendingZkLoginContext.expiresAt || null,
                        signatureInputs,
                        prover: proverDetails,
                        canSign: Boolean(signatureInputs)
                    };
                    sessionStorage.setItem('smartwallet:zkLogin', JSON.stringify(zkLoginSessionData));
                    logOutput('üîê zkLogin proof stored in session storage');
                } catch (storageError) {
                    logOutput('Warning: Failed to store zkLogin proof in session storage: ' + storageError.message, false);
                }

                logOutput(`üéâ zkLogin connected as ${suiAddress}`);
                if (signatureInputs) {
                    logOutput(`üîè Enoki zkLogin proof ready. Transactions can be signed until epoch ${signatureMaxEpoch || '(unknown)'}.`);
                } else {
                    logOutput('‚ö†Ô∏è zkLogin proving service not available; wallet remains read-only until Enoki configuration is complete.');
                }

                await getWalletBalance();
                try {
                    await findMyWallets();
                } catch (e) {
                    logOutput('Auto-discovery of smart wallets failed: ' + e.message, false);
                }
            } catch (error) {
                logOutput('zkLogin connection failed: ' + error.message, true);
                throw error;
            } finally {
                pendingZkLoginContext = null;
            }
        }

        async function restoreZkLoginFromSession() {
            try {
                const stored = sessionStorage.getItem('smartwallet:zkLogin');
                if (!stored) {
                    return false;
                }

                const sessionData = JSON.parse(stored);
                if (!sessionData || !sessionData.address) {
                    sessionStorage.removeItem('smartwallet:zkLogin');
                    return false;
                }

                // Check if the session data is still valid (not expired)
                const now = Date.now();
                if (sessionData.expiresAt && now > sessionData.expiresAt) {
                    sessionStorage.removeItem('smartwallet:zkLogin');
                    logOutput('zkLogin session expired, please reconnect');
                    return false;
                }

                // Check epoch validity if maxEpoch is available
                if (sessionData.maxEpoch) {
                    try {
                        if (!suiClient) await initializeSuiClient();
                        const epochInfo = await suiClient.getLatestSuiSystemState();
                        const currentEpoch = epochInfo?.epoch ? parseInt(epochInfo.epoch) : 0;
                        const maxEpoch = parseInt(sessionData.maxEpoch);

                        if (currentEpoch >= maxEpoch) {
                            sessionStorage.removeItem('smartwallet:zkLogin');
                            logOutput('zkLogin proof expired (epoch exceeded), please reconnect');
                            return false;
                        }
                    } catch (epochError) {
                        logOutput('Warning: Could not verify epoch validity: ' + epochError.message, false);
                    }
                }

                // Restore wallet from session data
                currentWallet = {
                    address: sessionData.address,
                    type: 'zkLogin',
                    provider: sessionData.provider,
                    zkLogin: {
                        jwt: sessionData.jwt,
                        payload: sessionData.payload,
                        salt: sessionData.salt,
                        addressSeed: sessionData.addressSeed,
                        publicIdentifier: sessionData.publicIdentifier,
                        publicKey: sessionData.publicKey,
                        nonce: sessionData.nonce,
                        randomness: sessionData.randomness,
                        maxEpoch: sessionData.maxEpoch,
                        ephemeralPublicKey: sessionData.ephemeralPublicKey,
                        connectedAt: sessionData.connectedAt,
                        expiresAt: sessionData.expiresAt,
                        signatureInputs: sessionData.signatureInputs,
                        prover: sessionData.prover,
                        ephemeralKeypair: null, // Keypair cannot be serialized, will need to regenerate if needed
                        canSign: Boolean(sessionData.signatureInputs)
                    }
                };
                connectedWalletStandard = null;

                showCurrentWalletAddress(sessionData.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `zkLogin (${currentWallet.provider})`;


                logOutput('üîê zkLogin session restored from storage');
                logOutput(`üéâ Reconnected as ${sessionData.address}`);
                if (sessionData.signatureInputs) {
                    logOutput(`üîè zkLogin proof valid until epoch ${sessionData.maxEpoch || '(unknown)'}`);
                } else {
                    logOutput('‚ö†Ô∏è Session restored but signing capability unavailable');
                }

                await getWalletBalance();
                try {
                    await findMyWallets();
                } catch (e) {
                    logOutput('Auto-discovery of smart wallets failed: ' + e.message, false);
                }

                return true;
            } catch (error) {
                logOutput('Failed to restore zkLogin session: ' + error.message, true);
                sessionStorage.removeItem('smartwallet:zkLogin');
                return false;
            }
        }

        function toggleZkLoginProviders(event, walletIndex) {
            event.stopPropagation();
            const dropdown = document.getElementById('zkloginDropdown' + walletIndex);
            if (!dropdown) return;

            // Close any other open dropdowns
            const allDropdowns = document.querySelectorAll('.zklogin-dropdown');
            allDropdowns.forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });

            // Toggle current dropdown
            dropdown.classList.toggle('visible');

            // Close dropdown when clicking outside
            const closeHandler = (e) => {
                if (!dropdown.contains(e.target) && !e.target.closest('.wallet-card')) {
                    dropdown.classList.remove('visible');
                    document.removeEventListener('click', closeHandler);
                }
            };

            if (dropdown.classList.contains('visible')) {
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            }
        }

        async function connectZkLoginProvider(provider) {
            try {
                // Close all dropdowns
                document.querySelectorAll('.zklogin-dropdown').forEach(d => d.classList.remove('visible'));

                // Close wallet modal
                closeWalletModal();

                if (provider === 'google') {
                    await handleZkLoginConnect();
                } else {
                    // For now, show a message that other providers are coming soon
                    logOutput(`üöß ${ZKLOGIN_PROVIDERS[provider]?.name || provider} zkLogin support coming soon. Using Google for now...`);
                    await handleZkLoginConnect();
                }
            } catch (error) {
                logOutput('zkLogin provider connection failed: ' + error.message, true);
            }
        }

        function buildPrimaryWalletEntries() {
            return [
                {
                    type: 'custom',
                    action: 'zkLogin',
                    name: 'zkLogin',
                    icon: makeWalletIcon('ZK', '#6c4bcc')
                },
                {
                    type: 'custom',
                    action: 'passkey',
                    name: 'Passkey (Preview)',
                    icon: makeWalletIcon('PK', '#1c858f')
                }
            ];
        }

        function getWalletIconForEntry(entry) {
            try {
                if (entry && typeof entry.icon === 'string') {
                    return entry.icon;
                }
                const wallet = entry && entry.wallet ? entry.wallet : null;
                const iconCandidates = [];
                if (wallet) {
                    if (typeof wallet.icon === 'string') iconCandidates.push(wallet.icon);
                    if (Array.isArray(wallet.icons)) {
                        for (const icon of wallet.icons) {
                            if (!icon) continue;
                            if (typeof icon === 'string') {
                                iconCandidates.push(icon);
                            } else if (typeof icon.url === 'string') {
                                iconCandidates.push(icon.url);
                            } else if (typeof icon.src === 'string') {
                                iconCandidates.push(icon.src);
                            } else if (typeof icon.data === 'string') {
                                iconCandidates.push(icon.data);
                            }
                        }
                    }
                }
                const dataIcon = iconCandidates.find(src => typeof src === 'string' && src.startsWith('data:image'));
                if (dataIcon) return dataIcon;
                const urlIcon = iconCandidates.find(src => typeof src === 'string');
                if (urlIcon) return urlIcon;

                return null;
            } catch (_) {
                return null;
            }
        }

        function scheduleSmartWalletManagementToggle(shouldShow) {
            const runToggle = () => {
                pendingManagementToggle = null;
                try {
                    setSmartWalletManagementVisible(shouldShow);
                } catch (error) {
                    console.warn('Failed to toggle smart wallet management visibility:', error.message || error);
                }
            };

            if (pendingManagementToggle && typeof pendingManagementToggle.cancel === 'function') {
                pendingManagementToggle.cancel();
                pendingManagementToggle = null;
            }

            if (typeof window !== 'undefined') {
                if (typeof window.requestAnimationFrame === 'function' && typeof window.cancelAnimationFrame === 'function') {
                    const frameId = window.requestAnimationFrame(runToggle);
                    pendingManagementToggle = { cancel: () => window.cancelAnimationFrame(frameId) };
                    return;
                }
                if (typeof window.setTimeout === 'function') {
                    const timeoutId = window.setTimeout(runToggle, 0);
                    pendingManagementToggle = { cancel: () => window.clearTimeout(timeoutId) };
                    return;
                }
            }

            runToggle();
        }

        function updateWalletConnectionControls(isConnected) {
            try {
                const controls = document.getElementById('walletConnectionControls');
                const statusEl = document.getElementById('walletConnectionStatus');
                const infoPanel = document.getElementById('walletInfo');
                const actionBtn = document.getElementById('walletHeaderAction');
                if (statusEl) {
                    let statusText = isConnected ? 'Connected' : 'Not connected';
                    if (isConnected && currentWallet?.type === 'view_only') {
                        statusText = 'View-only connected';
                    }
                    statusEl.textContent = statusText;
                }
                if (actionBtn) {
                    if (isConnected) {
                        actionBtn.textContent = 'Disconnect';
                        actionBtn.classList.add('disconnect');
                        actionBtn.onclick = () => disconnectWallet();
                    } else {
                        actionBtn.textContent = 'Connect';
                        actionBtn.classList.remove('disconnect');
                        actionBtn.onclick = () => connectWalletStandard();
                    }
                }
                if (!controls) {
                    return;
                }
                controls.dataset.connected = isConnected ? 'true' : 'false';
                if (isConnected) {
                    if (!walletControlsCollapsed) {
                        controls.open = false;
                        walletControlsCollapsed = true;
                    }
                    controls.style.display = 'none';
                    if (infoPanel) infoPanel.style.display = 'block';
                    const shouldShowManagement = Boolean(currentWallet && currentWallet.type !== 'view_only');
                    scheduleSmartWalletManagementToggle(shouldShowManagement);
                } else {
                    controls.open = false;
                    walletControlsCollapsed = true;
                    controls.style.display = '';
                    if (infoPanel) infoPanel.style.display = 'none';
                    if (pendingManagementToggle && typeof pendingManagementToggle.cancel === 'function') {
                        pendingManagementToggle.cancel();
                        pendingManagementToggle = null;
                    }
                    setSmartWalletManagementVisible(false);
                    hideSmartWalletOperations();
                }
            } catch (_) {}
        }

        async function resolveViewOnlyTarget(value) {
            const raw = (value || '').trim();
            if (!raw) {
                throw new Error('Enter a Sui address (0x...) or SuiNS name (example.sui).');
            }

            const { normalized } = normalizeAddressForDisplay(raw);
            if (normalized && HEX_ADDRESS_RE.test(normalized)) {
                return { address: normalized, source: 'address' };
            }

            const lower = raw.toLowerCase();
            if (!SUINS_NAME_RE.test(lower)) {
                throw new Error('Invalid input. Provide a valid Sui address (0x...) or a SuiNS name ending in .sui');
            }

            if (!suiClient) {
                await initializeSuiClient();
            }

            if (!suiClient || typeof suiClient.resolveNameServiceAddress !== 'function') {
                throw new Error('SuiNS resolution is not available in this SDK build.');
            }

            try {
                const result = await suiClient.resolveNameServiceAddress({ name: lower });
                let resolved = '';
                if (typeof result === 'string') {
                    resolved = result;
                } else if (result && typeof result === 'object') {
                    if (typeof result.address === 'string') resolved = result.address;
                    else if (typeof result.Address === 'string') resolved = result.Address;
                    else if (typeof result.value === 'string') resolved = result.value;
                    else if (result.data) {
                        if (typeof result.data === 'string') {
                            resolved = result.data;
                        } else if (typeof result.data === 'object' && typeof result.data.address === 'string') {
                            resolved = result.data.address;
                        }
                    }
                }

                const { normalized: resolvedAddress } = normalizeAddressForDisplay(resolved);
                if (!resolvedAddress || !HEX_ADDRESS_RE.test(resolvedAddress)) {
                    throw new Error(`No Sui address found for ${raw}`);
                }

                return { address: resolvedAddress, source: 'suins', name: lower };
            } catch (error) {
                throw new Error(`Failed to resolve ${raw}: ${error.message}`);
            }
        }

        async function copyText(value) {
            if (!value) return;
            if (navigator.clipboard?.writeText) {
                return navigator.clipboard.writeText(value);
            }
            const textarea = document.createElement('textarea');
            textarea.value = value;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try {
                document.execCommand('copy');
            } finally {
                document.body.removeChild(textarea);
            }
        }

        function setupCopyButtons() {
            const buttons = document.querySelectorAll('.copy-btn');
            buttons.forEach(button => {
                if (button.dataset.copySetup === 'done') return;
                button.dataset.copySetup = 'done';
                if (!button.dataset.copyLabel) {
                    button.dataset.copyLabel = button.textContent.trim() || 'Copy';
                }
                const targetId = button.dataset.copyTarget;
                const targetEl = targetId ? document.getElementById(targetId) : null;
                const allowAny = button.dataset.copyAllowAny === 'true';
                const getValue = () => {
                    if (button.dataset.copyValue !== undefined) {
                        return (button.dataset.copyValue || '').trim();
                    }
                    return targetEl ? targetEl.textContent.trim() : '';
                };
                if (!targetEl && button.dataset.copyValue === undefined) {
                    button.disabled = true;
                    return;
                }
                const updateState = () => {
                    const value = getValue();
                    button.disabled = allowAny ? !value : !HEX_ADDRESS_RE.test(value);
                };
                button.addEventListener('click', async () => {
                    const value = getValue();
                    if (!value) return;
                    if (!allowAny && !HEX_ADDRESS_RE.test(value)) return;
                    try {
                        await copyText(value);
                        button.dataset.copied = 'true';
                        button.textContent = 'Copied ‚úì';
                        setTimeout(() => {
                            button.textContent = button.dataset.copyLabel || 'Copy';
                            delete button.dataset.copied;
                        }, 1200);
                    } catch (error) {
                        console.warn('Copy failed', error);
                    }
                });
                if (targetEl) {
                    const observer = new MutationObserver(updateState);
                    observer.observe(targetEl, { subtree: true, childList: true, characterData: true });
                }
                updateState();
            });
        }

        if (typeof window !== 'undefined') {
            if (typeof window.requestIdleCallback === 'function') {
                window.requestIdleCallback(() => setupCopyButtons(), { timeout: 500 });
            } else {
                window.addEventListener('DOMContentLoaded', () => setTimeout(setupCopyButtons, 0));
            }
        }

        function waitForSDKs() {
            if (window.SuiSDK) {
                return Promise.resolve();
            }
            if (sdkReadyPromise) {
                return sdkReadyPromise;
            }
            sdkReadyPromise = new Promise((resolve) => {
                const poll = () => {
                    if (window.SuiSDK) {
                        resolve();
                    } else {
                        setTimeout(poll, 80);
                    }
                };
                poll();
            });
            return sdkReadyPromise;
        }

        function logOutput(message, isError = false) {
            const output = document.getElementById('output');
            const prefix = isError ? '[ERROR]' : '[INFO]';
            const line = isError ? `\n${prefix} ${message}` : `${prefix} ${message}`;
            output.textContent += `${line}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function normalizeAddressForDisplay(value) {
            if (!value && value !== 0) {
                return { normalized: '', display: '' };
            }
            const str = String(value).trim();
            if (!str) {
                return { normalized: '', display: '' };
            }
            if (HEX_STRING_RE.test(str)) {
                try {
                    const normalizer = window.SuiSDK?.Sui?.normalizeSuiAddress;
                    if (typeof normalizer === 'function') {
                        const normalized = normalizer(str.startsWith('0x') ? str : `0x${str}`);
                        return { normalized, display: normalized };
                    }
                } catch (_) {}
                const lower = str.startsWith('0x') ? str.toLowerCase() : `0x${str.toLowerCase()}`;
                return { normalized: lower, display: lower };
            }
            return { normalized: '', display: str };
        }

        function setCurrentWalletNameDisplay(name) {
            try {
                const container = document.getElementById('walletSuinsName');
                const valueEl = document.getElementById('walletSuinsValue');
                if (!container || !valueEl) return;
                if (name) {
                    valueEl.textContent = name;
                    container.style.display = 'inline-flex';
                } else {
                    valueEl.textContent = '';
                    container.style.display = 'none';
                }
            } catch (_) {}
        }

        async function resolveSuinsReverse(address, { silent = true } = {}) {
            const { normalized } = normalizeAddressForDisplay(address);
            if (!normalized) return null;
            const cacheKey = `${currentNetwork}:${normalized}`;
            if (suinsReverseCache.has(cacheKey)) {
                return suinsReverseCache.get(cacheKey);
            }

            try {
                if (!suiClient) {
                    await initializeSuiClient();
                }
                if (!suiClient?.resolveNameServiceNames) {
                    suinsReverseCache.set(cacheKey, null);
                    return null;
                }
                const response = await suiClient.resolveNameServiceNames({ address: normalized, limit: 5 });
                const names = Array.isArray(response?.data) ? response.data : [];
                const name = names.length ? names[0] : null;
                suinsReverseCache.set(cacheKey, name);
                return name;
            } catch (error) {
                suinsReverseCache.set(cacheKey, null);
                if (!silent) logOutput('Reverse SuiNS lookup failed: ' + error.message, true);
                return null;
            }
        }

        function showCurrentWalletAddress(address, { skipReverse = false } = {}) {
            const { normalized, display } = normalizeAddressForDisplay(address);
            const text = normalized || display;
            try {
                const addressEl = document.getElementById('currentAddress');
                if (addressEl) {
                    addressEl.textContent = text || '';
                }
                const copyBtn = document.querySelector('.copy-btn[data-copy-target="currentAddress"]');
                if (copyBtn) {
                    if (normalized) {
                        copyBtn.dataset.copyValue = normalized;
                        copyBtn.dataset.copyAllowAny = 'false';
                    } else {
                        copyBtn.dataset.copyValue = text || '';
                        copyBtn.dataset.copyAllowAny = 'true';
                    }
                    const value = copyBtn.dataset.copyValue || '';
                    const allowAny = copyBtn.dataset.copyAllowAny === 'true';
                    copyBtn.disabled = allowAny ? !value : !HEX_ADDRESS_RE.test(value);
                }
            } catch (_) {}

            if (!normalized) {
                currentReverseLookupToken += 1;
                setCurrentWalletNameDisplay(null);
                return;
            }

            if (skipReverse) return;

            const lookupToken = ++currentReverseLookupToken;
            setCurrentWalletNameDisplay(null);
            resolveSuinsReverse(normalized, { silent: true }).then(name => {
                if (lookupToken !== currentReverseLookupToken) return;
                setCurrentWalletNameDisplay(name);
            }).catch(() => {
                if (lookupToken !== currentReverseLookupToken) return;
                setCurrentWalletNameDisplay(null);
            });
        }



        // Derive member count from Move object fields; fall back to at least 1 (creator)
        function getMemberCountFromWalletFields(fields) {
            try {
                const members = fields && (fields.members || (fields.value && fields.value.members));
                const mf = members && (members.fields || (members.value && members.value.fields));
                if (!mf) return 1;
                if (typeof mf.size === 'number') {
                    const n = Number(mf.size) || 0;
                    return Math.max(1, n);
                }
                if (Array.isArray(mf.contents)) {
                    return Math.max(1, mf.contents.length);
                }
            } catch (e) {}
            return 1;
        }

        // Helper: try to extract a created objectId of a given type from a tx digest
        async function extractCreatedObjectIdFromDigest(digest, objectType, maxRetries = 8, delayMs = 800) {
            try {
                for (let i = 0; i < maxRetries; i++) {
                    if (!suiClient || typeof suiClient.getTransactionBlock !== 'function') {
                        break;
                    }
                    try {
                        const txb = await suiClient.getTransactionBlock({
                            digest,
                            options: { showEffects: true, showObjectChanges: true }
                        });
                        const oc = txb && txb.objectChanges ? txb.objectChanges : [];
                        if (Array.isArray(oc) && oc.length) {
                            const created = oc.find(c => c.type === 'created' && c.objectType === objectType);
                            if (created && created.objectId) return created.objectId;
                        }
                    } catch (e) {
                        // swallow and retry
                    }
                    await new Promise(r => setTimeout(r, delayMs));
                }
            } catch (_) {}
            return null;
        }

        // Initialize Sui client
        async function initializeSuiClient() {
            if (suiClient) return suiClient;
            if (!window.SuiSDK) {
                await waitForSDKs();
            }
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl } = window.SuiSDK.Sui;
            suiClient = new SuiClient({ url: getFullnodeUrl(currentNetwork) });
            logOutput(`Connected to Sui ${currentNetwork} network`);
            return suiClient;
        }

        async function ensureSdkReady() {
            await waitForSDKs();
            return initializeSuiClient();
        }

        function scheduleBootstrapWork() {
            if (bootstrapPromise) {
                return bootstrapPromise;
            }

            const runBootstrap = async () => {
                try {
                    await ensureSdkReady();
                } catch (error) {
                    logOutput('Failed to initialize SDK: ' + error.message, true);
                    return;
                }

                try {
                    const pidEl = document.getElementById('packageIdDisplay');
                    if (pidEl) pidEl.textContent = getPackageId() || '(unset)';
                    const pidInput = document.getElementById('packageIdInput');
                    if (pidInput) pidInput.value = getPackageId() || '';
                } catch (_) {}

                try {
                    await restoreZkLoginFromSession();
                } catch (error) {
                    logOutput('Failed to restore zkLogin session: ' + error.message, false);
                }
            };

            if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {
                bootstrapPromise = new Promise((resolve) => {
                    window.requestIdleCallback(() => {
                        runBootstrap().finally(resolve);
                    }, { timeout: 1200 });
                });
            } else {
                bootstrapPromise = new Promise((resolve) => {
                    setTimeout(() => {
                        runBootstrap().finally(resolve);
                    }, 120);
                });
            }

            return bootstrapPromise;
        }

        function queueRosterDiscovery() {
            if (rosterPrefetchDone) {
                return Promise.resolve();
            }
            if (rosterLookupPromise) {
                return rosterLookupPromise;
            }

            const execute = async () => {
                try {
                    await findRoster();
                } catch (error) {
                    logOutput('Roster lookup failed: ' + error.message, false);
                }
            };

            if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {
                rosterLookupPromise = new Promise((resolve) => {
                    const finalize = () => {
                        rosterPrefetchDone = true;
                        rosterLookupPromise = null;
                        resolve();
                    };
                    window.requestIdleCallback(() => {
                        execute().finally(finalize);
                    }, { timeout: 2000 });
                });
            } else {
                rosterLookupPromise = new Promise((resolve) => {
                    const finalize = () => {
                        rosterPrefetchDone = true;
                        rosterLookupPromise = null;
                        resolve();
                    };
                    setTimeout(() => {
                        execute().finally(finalize);
                    }, 200);
                });
            }

            return rosterLookupPromise;
        }

        // Wallet Management Functions
        async function createNewWallet() {
            try {
                await ensureSdkReady();
                logOutput('Creating new traditional wallet...');
                const { Ed25519Keypair } = window.SuiSDK.Sui;
                const keypair = Ed25519Keypair.generate();
                const address = keypair.toSuiAddress();
                
                currentWallet = { address, keypair, type: 'traditional' };
                showCurrentWalletAddress(address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                
                logOutput('Traditional wallet created successfully!');
                logOutput(`Address: ${address}`);
                await getWalletBalance();
            } catch (error) {
                logOutput('Error creating wallet: ' + error.message, true);
            }
        }

        async function restoreWallet() {
            const privateKey = document.getElementById('privateKeyInput').value.trim();
            if (!privateKey) {
                logOutput('Please enter a private key', true);
                return;
            }

            try {
                await ensureSdkReady();
                logOutput('Restoring wallet from private key...');
                const { Ed25519Keypair } = window.SuiSDK.Sui;
                const keypair = Ed25519Keypair.fromSecretKey(privateKey);
                const address = keypair.toSuiAddress();
                
                currentWallet = { address, keypair, type: 'traditional' };
                showCurrentWalletAddress(address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                
                logOutput('Wallet restored successfully!');
                logOutput(`Address: ${address}`);
                await getWalletBalance();
            } catch (error) {
                logOutput('Error restoring wallet: ' + error.message, true);
            }
        }

        async function getWalletBalance() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            try {
                if (!suiClient) {
                    await initializeSuiClient();
                }
                const balance = await suiClient.getBalance({ owner: currentWallet.address });
                const suiBalance = Number(balance.totalBalance) / 1_000_000_000;
                document.getElementById('currentBalance').textContent = `${suiBalance} SUI`;
                logOutput(`Balance: ${suiBalance} SUI`);
            } catch (error) {
                logOutput('Error getting balance: ' + error.message, true);
            }
        }

        // Wait for wallet extensions to load
        function waitForWalletExtensions(timeout = 3000) {
            return new Promise((resolve) => {
                const startTime = Date.now();
                const checkWallets = () => {
                    const walletFound = window.sui || window.suiWallet || window.ethos || window.slush || 
                                      (window.suiWallet && window.suiWallet.getWallets) ||
                                      Object.keys(window).some(key => key.toLowerCase().includes('sui'));
                    
                    if (walletFound || Date.now() - startTime > timeout) {
                        resolve(walletFound);
                    } else {
                        setTimeout(checkWallets, 100);
                    }
                };
                checkWallets();
            });
        }

        // Proper Sui Wallet Standard Connection using @mysten/wallet-standard
        async function connectWalletStandard() {
            try {
                await ensureSdkReady();
                
                // Wait for extensions to load
                await waitForWalletExtensions();
                
                // Method 1: Use @mysten/wallet-standard from SuiSDK bundle
                if (typeof window !== 'undefined' && window.SuiSDK) {
                    // Check for @mysten/wallet-standard in the SuiSDK bundle
                    if (window.SuiSDK.WalletStandard) {
                        try {
                            // Use proper Mysten wallet standard
                            const { getWallets } = window.SuiSDK.WalletStandard;
                            const walletsApi = getWallets();
                            const allWallets = walletsApi.get();
                            
                            // Filter for Sui-compatible wallets only
                            const suiWallets = allWallets.filter(wallet => {
                                // Check for Sui chains first (most reliable)
                                const supportsSui = wallet.chains && wallet.chains.some(chain =>
                                    chain.includes('sui:') || chain === 'sui'
                                );

                                // Check for Sui-specific features
                                const hasSuiConnect = wallet.features && (
                                    wallet.features['sui:connect'] ||
                                    wallet.features['sui:signAndExecuteTransaction']
                                );

                                // Only include if it explicitly supports Sui chains OR has Sui-specific features
                                // Exclude wallets that only have generic 'standard:connect' without Sui chain support
                                return supportsSui || hasSuiConnect;
                            });
                            
                                        openWalletModal(suiWallets);
                            return; // Stop here; user will choose a wallet
                        } catch (sdkError) {
                            logOutput('Mysten Wallet Standard detection failed: ' + sdkError.message, true);
                        }
                    }
                    
                    // Method 2: Direct window.sui detection (proper approach)
                    if (window.sui) {
                        logOutput('Found window.sui, attempting proper connection...');
                        try {
                            // Use the standard connection flow
                            const hasConnectFeature = window.sui.features && window.sui.features['standard:connect'];
                            const hasLegacyConnect = typeof window.sui.connect === 'function';
                            
                            if (hasConnectFeature) {
                                logOutput('Using standard:connect feature...');
                                await window.sui.features['standard:connect'].connect();
                            } else if (hasLegacyConnect) {
                                logOutput('Using legacy connect method...');
                                await window.sui.connect();
                            } else if (window.sui.requestPermissions) {
                                logOutput('Using requestPermissions method...');
                                await window.sui.requestPermissions();
                            }
                            
                            // Get accounts
                            let accounts = [];
                            if (window.sui.accounts) {
                                accounts = window.sui.accounts;
                            } else if (window.sui.getAccounts) {
                                accounts = await window.sui.getAccounts();
                            } else if (window.sui.features && window.sui.features['standard:connect'] && window.sui.features['standard:connect'].accounts) {
                                accounts = window.sui.features['standard:connect'].accounts;
                            }
                            
                            if (accounts && accounts.length > 0) {
                                const account = accounts[0];
                                currentWallet = { 
                                    address: account.address, 
                                    type: 'wallet_standard',
                                    wallet: window.sui
                                };
                                connectedWalletStandard = window.sui;
                                
                                showCurrentWalletAddress(account.address);
                                document.getElementById('walletInfo').style.display = 'block';
                                updateWalletConnectionControls(true);
                                document.getElementById('walletType').textContent = 'Sui Wallet Standard';
                                
                                logOutput('‚úÖ Successfully connected via window.sui!');
                                logOutput(`Address: ${account.address}`);
                                await getWalletBalance();
                                return;
                            }
                        } catch (suiError) {
                            logOutput('window.sui connection failed: ' + suiError.message, true);
                        }
                    }
                    
                    // Method 3: Check for wallet-specific globals
                    const knownWallets = ['suiWallet', 'ethos', 'slush', 'martian'];
                    for (const walletName of knownWallets) {
                        if (window[walletName]) {
                            logOutput(`Found ${walletName}, attempting connection...`);
                            try {
                                const wallet = window[walletName];
                                
                                // Try standard connect
                                if (wallet.features && wallet.features['standard:connect']) {
                                    await wallet.features['standard:connect'].connect();
                                    const accounts = wallet.features['standard:connect'].accounts;
                                    if (accounts && accounts.length > 0) {
                                        await handleSuccessfulConnection(accounts[0], wallet, walletName);
                                        return;
                                    }
                                }
                                
                                // Try legacy methods
                                if (wallet.connect) {
                                    await wallet.connect();
                                } else if (wallet.requestPermissions) {
                                    await wallet.requestPermissions();
                                }
                                
                                // Get accounts
                                let accounts = [];
                                if (wallet.getAccounts) {
                                    accounts = await wallet.getAccounts();
                                } else if (wallet.accounts) {
                                    accounts = wallet.accounts;
                                }
                                
                                if (accounts && accounts.length > 0) {
                                    await handleSuccessfulConnection(accounts[0], wallet, walletName);
                                    return;
                                }
                            } catch (walletError) {
                                logOutput(`${walletName} connection failed: ${walletError.message}`, true);
                            }
                        }
                    }
                }
                
                logOutput('‚ùå No compatible Sui wallets found', true);
                logOutput('Please ensure you have a Sui wallet extension installed (Slush, Sui Wallet, Ethos, etc.)', true);
                logOutput('After installing, please refresh the page and try again.', true);

            } catch (error) {
                logOutput('Wallet connection error: ' + error.message, true);
            }
        }
        
        // Helper function for successful wallet connection
        async function handleSuccessfulConnection(account, wallet, walletName) {
            currentWallet = {
                address: account.address,
                type: 'wallet_standard',
                wallet: wallet
            };
            connectedWalletStandard = wallet;

            showCurrentWalletAddress(account.address);
            document.getElementById('walletInfo').style.display = 'block';
            updateWalletConnectionControls(true);
            document.getElementById('walletType').textContent = walletName + ' Wallet';

            logOutput(`‚úÖ Connected to ${walletName}!`);
            logOutput(`Address: ${account.address}`);
            await getWalletBalance();

            // Automatically find wallets after successful connection
            try {
                await findMyWallets();
            } catch (e) {
                // Non-fatal error, just log it
                logOutput('Auto-discovery of smart wallets failed: ' + e.message, false);
            }
        }

        // Open modal with wallet selection (suiWallets are already filtered for Sui compatibility)
        function openWalletModal(suiWallets) {
            const overlay = document.getElementById('walletModal');
            const list = document.getElementById('walletModalList');
            if (!overlay || !list) return;
            
            // Start with the pre-filtered Sui wallets from @mysten/wallet-standard
            var entries = buildPrimaryWalletEntries();
            
            // Add wallet standard entries (already filtered for Sui compatibility)
            for (var i = 0; i < (suiWallets || []).length; i++) {
                var wallet = suiWallets[i];
                entries.push({ 
                    type: 'standard', 
                    wallet: wallet,
                    name: wallet.name || `${wallet.id || 'Wallet'} ${i + 1}`
                });
            }
            
            // Add fallback entries for directly injected providers (if not already in standard list)
            var fallbacks = [];
            if (window.sui) {
                // Check if this isn't already in the standard list
                var alreadyHasSui = entries.some(e => e.name && e.name.toLowerCase().includes('sui'));
                if (!alreadyHasSui) {
                    fallbacks.push({ 
                        type: 'windowSui', 
                        name: 'Sui Wallet (window.sui)'
                    });
                }
            }
            if (window.phantom && window.phantom.sui) {
                var alreadyHasPhantom = entries.some(e => e.name && e.name.toLowerCase().includes('phantom'));
                if (!alreadyHasPhantom) {
                    fallbacks.push({ 
                        type: 'phantomSui', 
                        name: 'Phantom (Sui)'
                    });
                }
            }
            
            // Add fallbacks to entries
            for (var fi = 0; fi < fallbacks.length; fi++) {
                entries.push(fallbacks[fi]);
            }

            window.availableSuiWallets = entries;

            var html = '';
            if (!entries.length) {
                html = '<p style="font-size: 13px; color: #a0b3c5;">No Sui wallets detected. Please install Slush, Sui Wallet, Ethos, or Phantom, then refresh this page.</p>';
            } else {
                for (var i = 0; i < entries.length; i++) {
                    var e = entries[i];
                    var name = e.name || (e.wallet && (e.wallet.name || e.wallet.id)) || `Wallet ${i + 1}`;
                    var iconSrc = getWalletIconForEntry(e);

                    var safeName = escapeHtml(name);
                    var safeIcon = escapeHtml(iconSrc);

                    // Special handling for zkLogin to show provider selection
                    if (e.type === 'custom' && e.action === 'zkLogin') {
                        html += '\n<div class="zklogin-providers">\n' +
                                '  <button type="button" class="wallet-card" onclick="toggleZkLoginProviders(event, ' + i + ')">\n' +
                                '    <div class="wallet-card-icon-wrap"><img src="' + safeIcon + '" alt="' + safeName + ' icon" class="wallet-card-icon" loading="lazy"></div>\n' +
                                '    <div class="wallet-card-content">\n' +
                                '      <div class="wallet-card-name">' + safeName + '</div>\n' +
                                '    </div>\n' +
                                '  </button>\n' +
                                '  <div class="zklogin-dropdown" id="zkloginDropdown' + i + '">\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'google\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.google.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Google</span>\n' +
                                '    </button>\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'facebook\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.facebook.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Meta</span>\n' +
                                '    </button>\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'apple\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.apple.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Apple</span>\n' +
                                '    </button>\n' +
                                '  </div>\n' +
                                '</div>';
                    } else {
                        html += '\n<button type="button" class="wallet-card" onclick="connectWalletByIndex(' + i + ')">\n' +
                                '  <div class="wallet-card-icon-wrap"><img src="' + safeIcon + '" alt="' + safeName + ' icon" class="wallet-card-icon" loading="lazy"></div>\n' +
                                '  <div class="wallet-card-content">\n' +
                                '    <div class="wallet-card-name">' + safeName + '</div>\n' +
                                '  </div>\n' +
                                '</button>';
                    }
                }
            }
            list.innerHTML = html;
            overlay.classList.add('visible');
            document.body.style.overflow = 'hidden';
            var closeBtn = document.getElementById('walletModalClose');
            if (closeBtn) try { closeBtn.focus(); } catch(e) {}
        }

        function closeWalletModal() {
            var overlay = document.getElementById('walletModal');
            if (!overlay) return;
            overlay.classList.remove('visible');
            document.body.style.overflow = '';
        }

        window.toggleZkLoginProviders = toggleZkLoginProviders;
        window.connectZkLoginProvider = connectZkLoginProvider;

        window.connectWalletByIndex = async function(i) {
            try {
                const entry = (window.availableSuiWallets && window.availableSuiWallets.length) ? window.availableSuiWallets[i] : null;
                if (!entry) throw new Error('Invalid wallet index');
                closeWalletModal();
                if (entry.type === 'standard' && entry.wallet) {
                    await connectToWallet(entry.wallet);
                } else if (entry.type === 'windowSui') {
                    await connectViaWindowSui();
                } else if (entry.type === 'phantomSui') {
                    await connectViaPhantomSui();
                } else if (entry.type === 'custom') {
                    if (entry.action === 'zkLogin') {
                        // zkLogin now uses provider selection dropdown instead of direct connection
                        throw new Error('zkLogin should use provider selection - this path should not be reached');
                    } else if (entry.action === 'passkey') {
                        await handlePasskeyStub();
                    } else {
                        throw new Error('Unsupported custom wallet entry');
                    }
                } else {
                    throw new Error('Unsupported wallet entry');
                }
            } catch (e) {
                logOutput('Wallet selection error: ' + e.message, true);
            }
        };

        async function handlePasskeyStub() {
            logOutput('üß™ Passkey flow coming soon. This option will use Mysten passkey helpers in the inline Sui SDK.');
        }

        async function connectToWallet(wallet) {
            try {
                logOutput(`Connecting to ${wallet.name || 'wallet'}...`);
                
                let connectFeature = null;
                let accountsFeature = null;
                
                // Find the correct connection feature
                if (wallet.features) {
                    // Priority order for connection features
                    if (wallet.features['standard:connect']) {
                        connectFeature = wallet.features['standard:connect'];
                        accountsFeature = wallet.features['standard:connect'];
                    } else if (wallet.features['sui:connect']) {
                        connectFeature = wallet.features['sui:connect'];
                        accountsFeature = wallet.features['sui:connect'];
                    } else if (wallet.features['sui:signAndExecuteTransaction']) {
                        // Some wallets only have signing features, try to get accounts directly
                        accountsFeature = wallet.features['sui:signAndExecuteTransaction'];
                    }
                }
                
                // Try to connect if we have a connect feature
                if (connectFeature && typeof connectFeature.connect === 'function') {
                    try { await connectFeature.disconnect?.(); } catch (_) {}
                    await connectFeature.connect({ silent: false });
                }
                
                // Try to get accounts
                let accounts = [];
                if (accountsFeature) {
                    if (typeof accountsFeature.getAccounts === 'function') {
                        accounts = await accountsFeature.getAccounts();
                    } else if (accountsFeature.accounts) {
                        accounts = accountsFeature.accounts;
                    }
                }
                
                // Fallback: try direct wallet properties
                if (!accounts || accounts.length === 0) {
                    if (wallet.accounts) {
                        accounts = wallet.accounts;
                    }
                }
                
                if (accounts && accounts.length > 0) {
                    const account = accounts[0];
                    currentWallet = {
                        address: account.address,
                        type: 'wallet_standard',
                        wallet: wallet
                    };
                    connectedWalletStandard = wallet;
                    attachWalletEvents(wallet);

                    showCurrentWalletAddress(account.address);
                    document.getElementById('walletInfo').style.display = 'block';
                    updateWalletConnectionControls(true);
                    document.getElementById('walletType').textContent = `${wallet.name || 'Wallet Standard'}`;

                    logOutput(`Connected to ${wallet.name || 'wallet'}!`);
                    logOutput(`Address: ${account.address}`);
                    await getWalletBalance();

                    // Automatically find wallets after successful connection
                    try {
                        await findMyWallets();
                    } catch (e) {
                        // Non-fatal error, just log it
                        logOutput('Auto-discovery of smart wallets failed: ' + e.message, false);
                    }
                } else {
                    throw new Error('No accounts found in wallet');
                }
            } catch (error) {
                throw new Error(`Failed to connect to wallet: ${error.message}`);
            }
        }


        async function connectViaWindowSui() {
            if (!window.sui) throw new Error('window.sui not detected');
            try {
                const hasConnectFeature = window.sui.features && window.sui.features['standard:connect'];
                const hasLegacyConnect = typeof window.sui.connect === 'function';
                if (hasConnectFeature) {
                    try { await window.sui.features['standard:connect'].disconnect?.(); } catch (_) {}
                    await window.sui.features['standard:connect'].connect({ silent: false });
                } else if (hasLegacyConnect) {
                    await window.sui.connect();
                } else if (window.sui.requestPermissions) {
                    await window.sui.requestPermissions();
                }
                let accounts = [];
                if (window.sui.accounts) accounts = window.sui.accounts;
                else if (window.sui.getAccounts) accounts = await window.sui.getAccounts();
                else if (window.sui.features && window.sui.features['standard:connect'] && window.sui.features['standard:connect'].accounts) {
                    accounts = window.sui.features['standard:connect'].accounts;
                }
                if (!accounts || !accounts.length) throw new Error('No accounts found in window.sui');
                const account = accounts[0];
                currentWallet = { address: account.address, type: 'wallet_standard', wallet: window.sui };
                connectedWalletStandard = window.sui;
                showCurrentWalletAddress(account.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = 'Sui Wallet (window.sui)';
                logOutput('‚úÖ Connected via window.sui');
                await getWalletBalance();

                // Automatically find wallets after successful connection
                try {
                    await findMyWallets();
                } catch (e) {
                    // Non-fatal error, just log it
                    logOutput('Auto-discovery of smart wallets failed: ' + e.message, false);
                }
            } catch (e) {
                throw new Error('window.sui connection failed: ' + e.message);
            }
        }

        async function connectViaPhantomSui() {
            if (!(window.phantom && window.phantom.sui)) throw new Error('Phantom Sui provider not detected');
            const phantomSui = window.phantom.sui;
            try {
                logOutput('Attempting to connect to Phantom Sui...');
                
                // For Phantom, we need to request connection first
                let connectResult;
                if (typeof phantomSui.connect === 'function') {
                    try { await phantomSui.disconnect?.(); } catch (_) {}
                    connectResult = await phantomSui.connect();
                    logOutput('Phantom connect() called successfully');
                } else {
                    logOutput('No connect() method found, trying direct account access');
                }
                
                // Try multiple ways to get accounts from Phantom Sui
                let accounts = [];
                
                // Method 1: Check connect result
                if (connectResult && connectResult.accounts) {
                    accounts = connectResult.accounts;
                    logOutput('Got accounts from connect result');
                }
                // Method 2: Check accounts property
                else if (phantomSui.accounts && phantomSui.accounts.length) {
                    accounts = phantomSui.accounts;
                    logOutput('Got accounts from phantomSui.accounts');
                }
                // Method 3: Try getAccounts method
                else if (typeof phantomSui.getAccounts === 'function') {
                    accounts = await phantomSui.getAccounts();
                    logOutput('Got accounts from getAccounts()');
                }
                // Method 4: Check for publicKey (legacy)
                else if (phantomSui.publicKey) {
                    if (typeof phantomSui.publicKey.toSuiAddress === 'function') {
                        accounts = [{ address: phantomSui.publicKey.toSuiAddress() }];
                        logOutput('Got address from publicKey.toSuiAddress()');
                    } else if (typeof phantomSui.publicKey.toBase58 === 'function') {
                        accounts = [{ address: phantomSui.publicKey.toBase58() }];
                        logOutput('Got address from publicKey.toBase58()');
                    }
                }
                
                logOutput(`Phantom Sui returned ${accounts ? accounts.length : 0} accounts`);
                
                if (!accounts || !accounts.length) {
                    throw new Error('No accounts returned by Phantom Sui. Please ensure Phantom is unlocked and has a Sui account configured.');
                }
                
                const account = accounts[0];
                logOutput(`Using account: ${account.address}`);
                
                currentWallet = { address: account.address, type: 'wallet_standard', wallet: phantomSui };
                connectedWalletStandard = phantomSui;
                
                showCurrentWalletAddress(account.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = 'Phantom (Sui)';
                
                logOutput('‚úÖ Connected via Phantom (Sui)');
                logOutput(`Address: ${account.address}`);
                await getWalletBalance();

                // Automatically find wallets after successful connection
                try {
                    await findMyWallets();
                } catch (e) {
                    // Non-fatal error, just log it
                    logOutput('Auto-discovery of smart wallets failed: ' + e.message, false);
                }

            } catch (e) {
                logOutput(`Phantom Sui connection error: ${e.message}`, true);
                throw new Error('Phantom Sui connection failed: ' + e.message);
            }
        }

        async function disconnectWallet() {
            try {
                if (connectedWalletStandard && connectedWalletStandard.features) {
                    if (
                        connectedWalletStandard.features['standard:connect'] &&
                        typeof connectedWalletStandard.features['standard:connect'].disconnect === 'function'
                    ) {
                        await connectedWalletStandard.features['standard:connect'].disconnect();
                    } else if (
                        connectedWalletStandard.features['sui:connect'] &&
                        typeof connectedWalletStandard.features['sui:connect'].disconnect === 'function'
                    ) {
                        await connectedWalletStandard.features['sui:connect'].disconnect();
                    } else if (typeof connectedWalletStandard.disconnect === 'function') {
                        await connectedWalletStandard.disconnect();
                    }
                }
                
                currentWallet = null;
                connectedWalletStandard = null;

                // Clear zkLogin session storage
                try {
                    sessionStorage.removeItem('smartwallet:zkLogin');
                } catch (_) {}
                
                document.getElementById('walletInfo').style.display = 'none';
                updateWalletConnectionControls(false);
                showCurrentWalletAddress('', { skipReverse: true });
                document.getElementById('currentBalance').textContent = 'Loading...';

                hideSmartWalletOperations();
                logOutput('Wallet disconnected');
            } catch (error) {
                logOutput('Error disconnecting wallet: ' + error.message, true);
            }
        }

        function attachWalletEvents(wallet) {
            try {
                if (wallet && wallet.features && wallet.features['standard:events'] && typeof wallet.features['standard:events'].on === 'function') {
                    wallet.features['standard:events'].on('change', async (e) => {
                        try {
                            if (e && e.accounts && e.accounts.length) {
                                const account = e.accounts[0];
                                currentWallet = { address: account.address, type: 'wallet_standard', wallet };
                                connectedWalletStandard = wallet;
                                showCurrentWalletAddress(account.address);
                                document.getElementById('walletInfo').style.display = 'block';
                                updateWalletConnectionControls(true);
                                await getWalletBalance();
                                logOutput(`Active account changed to: ${account.address}`);
                            }
                        } catch (err) {
                            logOutput('Error handling account change: ' + err.message, true);
                        }
                    });
                }
            } catch (_) {}
        }

        // Helper function to sign and execute transactions using proper Wallet Standard
        async function signAndExecuteTransaction(tx) {
            if (!currentWallet) {
                throw new Error('No wallet connected');
            }

            if (currentWallet.type === 'wallet_standard') {
                const wallet = connectedWalletStandard;
                
                // Build transaction data for wallet standard
                const transactionData = {
                    transaction: tx,
                    account: { address: currentWallet.address },
                    chain: `sui:${currentNetwork}`,
                    // Ask wallets to return rich response so we can read created object IDs
                    options: { showEffects: true, showObjectChanges: true }
                };
                
                // Try current Wallet Standard methods (preferred)
                if (wallet.features && wallet.features['sui:signAndExecuteTransaction']) {
                    logOutput('Using sui:signAndExecuteTransaction feature...');
                    return await wallet.features['sui:signAndExecuteTransaction'].signAndExecuteTransaction(transactionData);
                }
                
                // Try legacy methods (for backward compatibility)
                if (wallet.features && wallet.features['sui:signAndExecuteTransactionBlock']) {
                    logOutput('Using sui:signAndExecuteTransactionBlock feature...');
                    return await wallet.features['sui:signAndExecuteTransactionBlock'].signAndExecuteTransactionBlock({
                        transactionBlock: tx,
                        account: { address: currentWallet.address },
                        chain: `sui:${currentNetwork}`,
                        options: { showEffects: true, showObjectChanges: true }
                    });
                }
                
                // Try direct method access
                if (typeof wallet.signAndExecuteTransactionBlock === 'function') {
                    logOutput('Using direct signAndExecuteTransactionBlock method...');
                    return await wallet.signAndExecuteTransactionBlock({
                        transactionBlock: tx,
                        account: { address: currentWallet.address },
                        chain: `sui:${currentNetwork}`,
                        options: { showEffects: true, showObjectChanges: true }
                    });
                }
                
                if (typeof wallet.signAndExecuteTransaction === 'function') {
                    logOutput('Using direct signAndExecuteTransaction method...');
                    return await wallet.signAndExecuteTransaction(transactionData);
                }
                
                throw new Error('Wallet does not support transaction signing. Please ensure your wallet supports the Sui Wallet Standard.');
                
            } else if (currentWallet.type === 'zkLogin') {
                const zk = currentWallet.zkLogin || {};
                if (!zk.signatureInputs) {
                    throw new Error('zkLogin proving service not ready. Reconnect after configuring the prover URL.');
                }
                if (!zk.ephemeralKeypair) {
                    throw new Error('zkLogin session missing ephemeral keypair. Please reconnect via zkLogin before signing.');
                }

                const { Transaction } = window.SuiSDK.Sui;
                if (!(tx instanceof Transaction)) {
                    throw new Error('Unsupported transaction object for zkLogin signing.');
                }

                tx.setSenderIfNotSet(currentWallet.address);
                const txBytes = await tx.build({ client: suiClient });

                const { signature } = await zk.ephemeralKeypair.signTransaction(txBytes);
                const signatureBytes = window.SuiSDK.BCS.fromBase64(signature);
                if (!signatureBytes || signatureBytes.length < 65) {
                    throw new Error('Invalid zkLogin user signature produced.');
                }
                const rawUserSignature = signatureBytes.slice(1, 65);

                const maxEpochValue = zk.maxEpoch || pendingZkLoginContext?.maxEpoch;
                if (!maxEpochValue) {
                    throw new Error('Missing maxEpoch for zkLogin signature. Reconnect to refresh the session.');
                }
                let maxEpochBigInt;
                try {
                    maxEpochBigInt = BigInt(maxEpochValue);
                } catch (_) {
                    throw new Error('Invalid maxEpoch value returned by zkLogin proving service.');
                }

                const zkSignature = window.SuiSDK.ZkLogin.getZkLoginSignature({
                    inputs: zk.signatureInputs,
                    maxEpoch: maxEpochBigInt,
                    userSignature: rawUserSignature
                });

                logOutput('üîê Signing transaction with zkLogin...');
                const result = await suiClient.executeTransactionBlock({
                    transactionBlock: txBytes,
                    signature: [zkSignature],
                    options: { showEffects: true, showObjectChanges: true }
                });
                logOutput('‚úÖ zkLogin transaction executed successfully');
                return result;

            } else {
                // Use traditional keypair signing for non-wallet-standard connections
                return await suiClient.signAndExecuteTransaction({
                    signer: currentWallet.keypair,
                    transaction: tx
                });
            }
        }

        // Smart Contract Functions

        // Initialize Roster (call once after deployment)
        async function initRoster() {
            if (!currentWallet) {
                logOutput('No wallet connected', true);
                return;
            }

            try {
                await ensureSdkReady();
                logOutput('Initializing roster...');
                const { Transaction } = window.SuiSDK.Sui;
                const tx = new Transaction();

                tx.moveCall({
                    target: `${getPackageId()}::${CONTRACT_CONFIG.MODULES.ROSTER}::init_roster`,
                    arguments: []
                });

                const result = await signAndExecuteTransaction(tx);

                logOutput(`Roster initialized! Transaction: ${result.digest}`);

                // Persist digest for fallback discovery
                try { localStorage.setItem('lastRosterInitDigest', result.digest); } catch (_) {}

                // Try to extract the created shared Roster object ID directly from the response
                const ROSTER_TYPE = `${getPackageId()}::${CONTRACT_CONFIG.MODULES.ROSTER}::Roster`;
                let createdId = null;

                try {
                    const oc = result && result.objectChanges ? result.objectChanges : [];
                    if (Array.isArray(oc) && oc.length) {
                        const created = oc.find(c => c.type === 'created' && c.objectType === ROSTER_TYPE);
                        if (created && created.objectId) createdId = created.objectId;
                    }
                } catch (_) {}

                // If not present, wait for tx to finalize then fetch full details
                if (!createdId) {
                    const fetched = await extractCreatedObjectIdFromDigest(result.digest, ROSTER_TYPE);
                    if (fetched) createdId = fetched;
                    else logOutput('Note: could not fetch created Roster ID from digest yet', true);
                }

                if (createdId) {
                    rosterId = createdId;
                    try { localStorage.setItem('rosterId', rosterId); } catch (_) {}
                    document.getElementById('rosterId').textContent = rosterId;
                    logOutput(`Found roster: ${rosterId}`);
                } else {
                    // Fallback: search via indexer for any Roster objects (shared, global)
                    await findRoster();
                }
            } catch (error) {
                logOutput('Error initializing roster: ' + error.message, true);
            }
        }

        // Find the shared Roster object
        async function findRoster() {
            try {
                await ensureSdkReady();
                logOutput('Looking for roster...');

                // 0) Prefer configured canonical ID
                try {
                    const configured = (DISCOVERY_CONFIG && DISCOVERY_CONFIG.rosterIds && DISCOVERY_CONFIG.rosterIds[currentNetwork]) || '';
                    if (configured && /^0x[0-9a-fA-F]{40,}$/.test(configured)) {
                        rosterId = configured;
                        try { localStorage.setItem('rosterId', rosterId); } catch (_) {}
                        document.getElementById('rosterId').textContent = rosterId;
                        logOutput(`Found roster (configured): ${rosterId}`);
                        return;
                    }
                } catch (_) {}

                // 1) Try SuiNS if available and a name is configured (skip on devnet)
                try {
                    const name = DISCOVERY_CONFIG?.suinsName || '';
                    if (name && currentNetwork !== 'devnet' && window.SuiSDK?.SuiNS?.SuinsClient) {
                        const suinsNetwork = currentNetwork === 'mainnet' ? 'mainnet' : 'testnet';
                        const { SuinsClient } = window.SuiSDK.SuiNS;
                        const suins = new SuinsClient({ client: suiClient, network: suinsNetwork });
                        const rec = await suins.getNameRecord(name);
                        const rid = (rec && rec.data && rec.data.roster_id) || null;
                        if (rid && /^0x[0-9a-fA-F]{40,}$/.test(rid)) {
                            rosterId = rid;
                            try { localStorage.setItem('rosterId', rosterId); } catch (_) {}
                            document.getElementById('rosterId').textContent = rosterId;
                            logOutput(`Found roster (SuiNS: ${name}): ${rosterId}`);
                            return;
                        }
                    }
                } catch (e) {
                    // Non-fatal; continue with other discovery paths
                }

                // 2) Check local storage cache
                try {
                    const cached = localStorage.getItem('rosterId');
                    if (cached) {
                        rosterId = cached;
                        document.getElementById('rosterId').textContent = rosterId;
                        logOutput(`Found roster (cached): ${rosterId}`);
                        return;
                    }
                } catch (_) {}

                // 3) Fallback: if we have last init digest, try to fetch the created object id
                try {
                    const lastDigest = localStorage.getItem('lastRosterInitDigest');
                    if (lastDigest) {
                        const ROSTER_TYPE = `${getPackageId()}::${CONTRACT_CONFIG.MODULES.ROSTER}::Roster`;
                        const createdId = await extractCreatedObjectIdFromDigest(lastDigest, ROSTER_TYPE);
                        if (createdId) {
                            rosterId = createdId;
                            try { localStorage.setItem('rosterId', rosterId); } catch (_) {}
                            document.getElementById('rosterId').textContent = rosterId;
                            logOutput(`Found roster: ${rosterId}`);
                            return;
                        }
                    }
                } catch (_) {}

                // As a final fallback, inform user
                logOutput('No roster found - you may need to initialize one first', true);
            } catch (error) {
                logOutput('Error finding roster: ' + error.message, true);
            }
        }

        // Create a new Smart Wallet
        async function createSmartWallet() {
            if (!currentWallet) {
                logOutput('No wallet connected', true);
                return;
            }

            const walletName = document.getElementById('walletName').value.trim();
            const recoveryKey = document.getElementById('recoveryKey').value.trim() || currentWallet.address;

            if (!walletName) {
                logOutput('Please enter a wallet name', true);
                return;
            }

            try {
                logOutput('Creating smart wallet...');
                const { Transaction, Clock } = window.SuiSDK.Sui;
                const tx = new Transaction();

                // Get the shared Clock object (0x6)
                const clockId = '0x6';

                const smartWallet = tx.moveCall({
                    target: `${getPackageId()}::${CONTRACT_CONFIG.MODULES.WALLET}::create_wallet`,
                    arguments: [
                        tx.pure.address(currentWallet.address),
                        tx.pure.address(recoveryKey),
                        tx.pure.vector('u8', Array.from(new TextEncoder().encode(walletName))),
                        tx.object(clockId)
                    ]
                });

                // Transfer the created wallet to the sender
                tx.transferObjects([smartWallet], tx.pure.address(currentWallet.address));

                const result = await signAndExecuteTransaction(tx);

                logOutput(`Smart wallet created! Transaction: ${result.digest}`);
                await findMyWallets();
            } catch (error) {
                logOutput('Error creating smart wallet: ' + error.message, true);
            }
        }

        // Find wallets owned by current user
        async function findMyWallets() {
            if (!currentWallet) {
                logOutput('No wallet connected', true);
                return;
            }

            try {
                logOutput('Finding your smart wallets...');

                const walletMap = new Map();
                let rosterNewCount = 0;

                function registerWalletObject(obj, source) {
                    if (!obj || !obj.data || !obj.data.objectId) return;
                    const walletId = (window.SuiSDK?.Sui?.normalizeSuiAddress)
                        ? window.SuiSDK.Sui.normalizeSuiAddress(obj.data.objectId)
                        : String(obj.data.objectId).toLowerCase();
                    if (!walletMap.has(walletId)) {
                        walletMap.set(walletId, {
                            id: walletId,
                            object: obj,
                            sources: new Set([source])
                        });
                        if (source === 'roster') rosterNewCount += 1;
                    } else {
                        const entry = walletMap.get(walletId);
                        entry.sources.add(source);
                        if (!walletMap.get(walletId).object?.data?.content && obj.data?.content) {
                            entry.object = obj;
                        }
                    }
                }

                const ownedObjects = await suiClient.getOwnedObjects({
                    owner: currentWallet.address,
                    filter: {
                        StructType: `${getPackageId()}::${CONTRACT_CONFIG.MODULES.WALLET}::SmartWallet`
                    },
                    options: { showContent: true, showDisplay: true }
                });

                ownedObjects.data.forEach((obj) => registerWalletObject(obj, 'owned'));

                const rosterWalletIds = await fetchRosterWalletMemberships(currentWallet.address);
                const missingIds = [];
                for (const wid of rosterWalletIds) {
                    const normalized = (window.SuiSDK?.Sui?.normalizeSuiAddress)
                        ? window.SuiSDK.Sui.normalizeSuiAddress(wid)
                        : wid.toLowerCase();
                    if (!walletMap.has(normalized)) {
                        missingIds.push(normalized);
                    } else {
                        walletMap.get(normalized).sources.add('roster');
                    }
                }

                if (missingIds.length) {
                    try {
                        const rosterObjects = await suiClient.multiGetObjects({
                            ids: missingIds,
                            options: { showContent: true, showDisplay: true }
                        });
                        rosterObjects.forEach((obj, index) => {
                            if (obj?.data?.objectId) {
                                const walletId = obj.data.objectId;
                                registerWalletObject(obj, 'roster');
                            } else {
                                const fallbackId = missingIds[index];
                                if (!walletMap.has(fallbackId)) {
                                    walletMap.set(fallbackId, {
                                        id: fallbackId,
                                        object: obj,
                                        sources: new Set(['roster'])
                                    });
                                }
                            }
                        });
                    } catch (error) {
                        logOutput('Failed to fetch roster-linked wallets: ' + error.message, true);
                    }
                }

                const walletsList = document.getElementById('walletsList');
                walletsList.innerHTML = '';

                const walletEntries = Array.from(walletMap.values());

                if (!walletEntries.length) {
                    walletsList.innerHTML = '<p>No smart wallets found</p>';
                    hideSmartWalletOperations();
                    logOutput('No smart wallets found');
                    return;
                }

                walletEntries.sort((a, b) => {
                    const aRank = a.sources.has('owned') ? 0 : 1;
                    const bRank = b.sources.has('owned') ? 0 : 1;
                    if (aRank !== bRank) return aRank - bRank;
                    return a.id.localeCompare(b.id);
                });

                walletEntries.forEach(({ id, object, sources }) => {
                    const fields = object?.data?.content?.fields || {};
                    let nameBytes = null;
                    try {
                        if (fields.name instanceof Uint8Array) {
                            nameBytes = fields.name;
                        } else if (Array.isArray(fields.name)) {
                            nameBytes = new Uint8Array(fields.name);
                        } else if (fields.name && typeof fields.name === 'object' && 'bytes' in fields.name) {
                            nameBytes = new Uint8Array(fields.name.bytes);
                        } else if (typeof fields.name === 'string') {
                            nameBytes = new TextEncoder().encode(fields.name);
                        }
                    } catch (_) {}
                    let walletName = 'Unknown';
                    try {
                        if (nameBytes) {
                            walletName = new TextDecoder().decode(nameBytes);
                        }
                    } catch (_) {}
                    const memberCount = getMemberCountFromWalletFields(fields);
                    const balanceNumber = Number(fields.balance || 0) / 1_000_000_000;
                    let sourceLabel = 'Member';
                    if (sources.has('owned') && sources.has('roster')) {
                        sourceLabel = 'Owner & Member';
                    } else if (sources.has('owned')) {
                        sourceLabel = 'Owner';
                    }

                    const card = document.createElement('div');
                    card.className = 'contract-card';
                    card.innerHTML = `
                        <h4>Smart Wallet (${sourceLabel})</h4>
                        <div class="address-display">ID: ${id}</div>
                        <p><strong>Name:</strong> ${walletName}</p>
                        <p><strong>Version:</strong> ${fields.version ?? 'Unknown'}</p>
                        <p><strong>Balance:</strong> ${balanceNumber} SUI</p>
                        <p><strong>Members:</strong> ${memberCount}</p>
                        <button onclick="selectSmartWallet('${id}')">Select Wallet</button>
                        <button onclick="viewWalletDetails('${id}')">View Details</button>
                    `;
                    walletsList.appendChild(card);
                });

                logOutput(`Found ${walletEntries.length} smart wallet(s)`);

                if (rosterNewCount > 0) {
                    logOutput(`Roster lookup added ${rosterNewCount} wallet reference(s) for this member.`);
                }

                if (walletEntries.length === 1) {
                    const singleWalletId = walletEntries[0].id;
                    window.selectSmartWallet(singleWalletId);
                    logOutput(`Automatically selected the only available wallet: ${singleWalletId}`);
                }
            } catch (error) {
                logOutput('Error finding wallets: ' + error.message, true);
            }
        }

        function setSmartWalletManagementVisible(shouldShow) {
            const managementSection = document.getElementById('smartWalletManagementSection');
            if (managementSection) {
                managementSection.style.display = shouldShow ? 'block' : 'none';
                managementSection.classList.toggle('visible', Boolean(shouldShow));
            }
            if (shouldShow) {
                queueRosterDiscovery();
            }
        }

        function hideSmartWalletOperations() {
            const operationsSection = document.getElementById('smartWalletOperations');
            if (operationsSection) {
                operationsSection.style.display = 'none';
                operationsSection.classList.remove('visible');
            }

            const selectedWalletElement = document.getElementById('selectedWalletId');
            if (selectedWalletElement) {
                selectedWalletElement.textContent = 'None';
            }
        }

        function showSmartWalletOperations() {
            const operationsSection = document.getElementById('smartWalletOperations');
            if (operationsSection) {
                operationsSection.style.display = 'block';
                operationsSection.classList.add('visible');
            }
        }

        // Select a smart wallet for operations
        window.selectSmartWallet = function(walletId) {
            document.getElementById('selectedWalletId').textContent = walletId;
            showSmartWalletOperations();
            logOutput(`Selected smart wallet: ${walletId}`);
        }

        // View detailed wallet information
        window.viewWalletDetails = async function(walletId) {
            try {
                logOutput(`Getting details for wallet ${walletId}...`);
                const walletObj = await suiClient.getObject({
                    id: walletId,
                    options: { showContent: true }
                });

                const details = walletObj.data.content.fields;
                const memberCount = getMemberCountFromWalletFields(details);
                logOutput(`Wallet Name: ${details.name ? new TextDecoder().decode(new Uint8Array(details.name)) : 'Unknown'}`);
                logOutput(`Version: ${details.version}`);
                logOutput(`Created: ${new Date(Number(details.created_at)).toLocaleString()}`);
                logOutput(`Recovery Key: ${details.recovery_key}`);
                logOutput(`Members: ${memberCount}`);
                logOutput(`Proposals: ${((details.proposals && details.proposals.fields && details.proposals.fields.size) || 0)}`);
                logOutput(`Balance: ${Number(details.balance || 0) / 1_000_000_000} SUI`);
            } catch (error) {
                logOutput('Error getting wallet details: ' + error.message, true);
            }
        }

        // Add a new member to the smart wallet
        async function addMember() {
            const walletId = document.getElementById('selectedWalletId').textContent;
            const newMember = document.getElementById('newMemberAddress').value.trim();
            const roleName = document.getElementById('memberRole').value.trim() || 'member';
            const weight = parseInt(document.getElementById('memberWeight').value) || 1;
            const permissions = parseInt(document.getElementById('memberPermissions').value) || 7;

            if (!walletId || !newMember) {
                logOutput('Please select a wallet and enter member address', true);
                return;
            }

            if (newMember.toLowerCase() === currentWallet.address.toLowerCase()) {
                logOutput('This address is already a member (creator). Use a different address.', true);
                return;
            }

            if (!rosterId) {
                logOutput('No roster found - please initialize roster first', true);
                return;
            }

            try {
                logOutput(`Adding member ${newMember} to wallet ${walletId}...`);
                const { Transaction } = window.SuiSDK.Sui;
                const tx = new Transaction();

                tx.moveCall({
                    target: `${getPackageId()}::${CONTRACT_CONFIG.MODULES.WALLET}::add_member`,
                    arguments: [
                        tx.object(walletId),
                        tx.object(rosterId),
                        tx.pure.address(newMember),
                        tx.pure.vector('u8', Array.from(new TextEncoder().encode(roleName))),
                        tx.pure.u64(weight),
                        tx.pure.u64(permissions),
                        tx.pure.address(currentWallet.address)
                    ]
                });

                const result = await signAndExecuteTransaction(tx);

                logOutput(`Member added! Transaction: ${result.digest}`);
                
                // Clear form
                document.getElementById('newMemberAddress').value = '';
                document.getElementById('memberRole').value = '';
                document.getElementById('memberWeight').value = '';
                document.getElementById('memberPermissions').value = '';
            } catch (error) {
                logOutput('Error adding member: ' + error.message, true);
            }
        }

        // Create a new proposal
        async function createProposal() {
            const walletId = document.getElementById('selectedWalletId').textContent;
            const proposalId = parseInt(document.getElementById('proposalId').value) || Date.now();
            const actionKind = document.getElementById('actionKind').value.trim() || 'transfer';
            const targetAddress = document.getElementById('targetAddress').value.trim();
            const actionData = document.getElementById('actionData').value.trim();
            const threshold = parseInt(document.getElementById('proposalThreshold').value) || 1;
            const deadline = parseInt(document.getElementById('proposalDeadline').value) || 0;

            if (!walletId || !targetAddress || !actionData) {
                logOutput('Please fill in all required proposal fields', true);
                return;
            }

            try {
                logOutput(`Creating proposal ${proposalId} for wallet ${walletId}...`);
                const { Transaction } = window.SuiSDK.Sui;
                const tx = new Transaction();

                // Convert action data to bytes
                let dataBytes;
                if (actionKind === 'transfer') {
                    const amountInMist = Math.floor(parseFloat(actionData) * 1_000_000_000);
                    try {
                        const { bcs } = window.SuiSDK.BCS;
                        // Prefer ser API; fallback to builder style
                        const bytes = (bcs && typeof bcs.ser === 'function')
                            ? bcs.ser('u64', amountInMist).toBytes()
                            : bcs.u64().serialize(amountInMist).toBytes();
                        dataBytes = bytes;
                    } catch (_) {
                        throw new Error('BCS encoding unavailable for u64. Ensure @mysten/bcs is bundled.');
                    }
                } else {
                    dataBytes = new TextEncoder().encode(actionData);
                }

                const clockId = '0x6';

                tx.moveCall({
                    target: `${getPackageId()}::${CONTRACT_CONFIG.MODULES.WALLET}::propose_action`,
                    arguments: [
                        tx.object(walletId),
                        tx.pure.u64(proposalId),
                        tx.pure.vector('u8', Array.from(new TextEncoder().encode(actionKind))),
                        tx.pure.address(targetAddress),
                        tx.pure.vector('u8', Array.from(dataBytes)),
                        tx.pure.u64(threshold),
                        tx.pure.u64(deadline),
                        // Empty vector<Condition>: explicit element type using vector helper
                        tx.pure.vector(`${getPackageId()}::${CONTRACT_CONFIG.MODULES.WALLET}::Condition`, []),
                        tx.object(clockId)
                    ]
                });

                const result = await signAndExecuteTransaction(tx);

                logOutput(`Proposal created! Transaction: ${result.digest}`);
                
                // Clear form
                document.getElementById('proposalId').value = '';
                document.getElementById('actionKind').value = '';
                document.getElementById('targetAddress').value = '';
                document.getElementById('actionData').value = '';
                document.getElementById('proposalThreshold').value = '';
                document.getElementById('proposalDeadline').value = '';
            } catch (error) {
                logOutput('Error creating proposal: ' + error.message, true);
            }
        }

        // Approve a proposal
        async function approveProposal() {
            const walletId = document.getElementById('selectedWalletId').textContent;
            const proposalId = parseInt(document.getElementById('approveProposalId').value);

            if (!walletId || !proposalId) {
                logOutput('Please enter proposal ID', true);
                return;
            }

            try {
                logOutput(`Approving proposal ${proposalId} for wallet ${walletId}...`);
                const { Transaction } = window.SuiSDK.Sui;
                const tx = new Transaction();

                const clockId = '0x6';

                tx.moveCall({
                    target: `${getPackageId()}::${CONTRACT_CONFIG.MODULES.WALLET}::approve_proposal`,
                    arguments: [
                        tx.object(walletId),
                        tx.pure.u64(proposalId),
                        tx.object(clockId)
                    ]
                });

                const result = await signAndExecuteTransaction(tx);

                logOutput(`Proposal approved! Transaction: ${result.digest}`);
                document.getElementById('approveProposalId').value = '';
            } catch (error) {
                logOutput('Error approving proposal: ' + error.message, true);
            }
        }

        // Deposit SUI into smart wallet
        async function depositToWallet() {
            const walletId = document.getElementById('selectedWalletId').textContent;
            const amount = parseFloat(document.getElementById('depositAmount').value);

            if (!walletId || !amount || amount <= 0) {
                logOutput('Please enter valid deposit amount', true);
                return;
            }

            try {
                logOutput(`Depositing ${amount} SUI to wallet ${walletId}...`);
                const { Transaction } = window.SuiSDK.Sui;
                const tx = new Transaction();

                const amountInMist = Math.floor(amount * 1_000_000_000);
                const coin = tx.splitCoins(tx.gas, [tx.pure.u64(amountInMist)]);

                tx.moveCall({
                    target: `${getPackageId()}::${CONTRACT_CONFIG.MODULES.WALLET}::deposit`,
                    arguments: [
                        tx.object(walletId),
                        coin
                    ]
                });

                const result = await signAndExecuteTransaction(tx);

                logOutput(`Deposit successful! Transaction: ${result.digest}`);
                document.getElementById('depositAmount').value = '';
                await findMyWallets(); // Refresh wallet list
            } catch (error) {
                logOutput('Error depositing: ' + error.message, true);
            }
        }

        // Network change handler
        function changeNetwork() {
            const networkSelect = document.getElementById('networkSelect');
            currentNetwork = networkSelect.value;
            logOutput(`Network changed to: ${currentNetwork}`);
            try {
                const pidEl = document.getElementById('packageIdDisplay');
                if (pidEl) pidEl.textContent = getPackageId() || '(unset)';
                const inp = document.getElementById('packageIdInput');
                if (inp) inp.value = getPackageId() || '';
            } catch (_) {}
            
            // Reinitialize client
            initializeSuiClient().then(() => {
                if (currentWallet) {
                    getWalletBalance();
                }
            });
            rosterPrefetchDone = false;
            rosterLookupPromise = null;
            queueRosterDiscovery();
        }

        function savePackageIdOverride() {
            try {
                const inp = document.getElementById('packageIdInput');
                const val = (inp && inp.value || '').trim();
                if (!/^0x[0-9a-fA-F]{40,}$/.test(val)) {
                    logOutput('Invalid package ID format. Expect 0x-prefixed hex.', true);
                    return;
                }
                const key = `vwallet:packageId:${currentNetwork}`;
                localStorage.setItem(key, val);
                const pidEl = document.getElementById('packageIdDisplay');
                if (pidEl) pidEl.textContent = val;
                logOutput(`Saved package ID override for ${currentNetwork}.`);
            } catch (e) {
                logOutput('Failed to save package ID: ' + e.message, true);
            }
        }

        function clearPackageIdOverride() {
            try {
                const key = `vwallet:packageId:${currentNetwork}`;
                localStorage.removeItem(key);
                const pidEl = document.getElementById('packageIdDisplay');
                if (pidEl) pidEl.textContent = getPackageId() || '(unset)';
                const inp = document.getElementById('packageIdInput');
                if (inp) inp.value = getPackageId() || '';
                logOutput(`Cleared package ID override for ${currentNetwork}.`);
            } catch (e) {
                logOutput('Failed to clear package ID: ' + e.message, true);
            }
        }

        function clearOutput() {
            document.getElementById('output').textContent = '';
        }

        // View-only connection function that accepts Sui addresses or SuiNS names
        async function connectViewOnly(target) {
            try {
                const { address, source, name } = await resolveViewOnlyTarget(target);

                currentWallet = {
                    address,
                    type: 'view_only',
                    wallet: null
                };
                connectedWalletStandard = null;

                showCurrentWalletAddress(address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = source === 'suins' ? 'View Only (SuiNS)' : 'View Only (Address)';

                if (source === 'suins' && name) {
                    logOutput(`SuiNS ${name} resolved to: ${address}`);
                } else {
                    logOutput(`Viewing address: ${address}`);
                }
                logOutput('Note: This is view-only. You cannot sign transactions without a proper wallet connection.');

                try {
                    const inputEl = document.getElementById('viewOnlyTarget');
                    if (inputEl) inputEl.value = ''; // clear after successful connect
                } catch (_) {}

                await getWalletBalance();
            } catch (error) {
                logOutput('View-only connection error: ' + error.message, true);
            }
        }

        window.createNewWallet = createNewWallet;
        window.restoreWallet = restoreWallet;
        window.getWalletBalance = getWalletBalance;
        window.changeNetwork = changeNetwork;
        window.clearOutput = clearOutput;
        window.connectWalletStandard = connectWalletStandard;
        window.disconnectWallet = disconnectWallet;
        window.connectViewOnly = connectViewOnly;
        window.setEnokiApiKey = function(apiKey) {
            const value = setEnokiApiKey(apiKey);
            logOutput(`Enoki API key ${value ? 'set' : 'cleared'}.`);
            return value;
        };
        window.setEnokiApiUrl = function(apiUrl) {
            const value = setEnokiApiUrl(apiUrl);
            logOutput(`Enoki API URL ${value ? 'set to ' + value : 'cleared'}.`);
            return value;
        };
        window.initRoster = initRoster;
        window.findRoster = findRoster;
        // Backwards-compatible aliases removed to prefer roster naming
        window.createSmartWallet = createSmartWallet;
        window.findMyWallets = findMyWallets;
        window.addMember = addMember;
        window.createProposal = createProposal;
        window.approveProposal = approveProposal;
        window.depositToWallet = depositToWallet;
        window.clearZkLoginSession = function() {
            try {
                sessionStorage.removeItem('smartwallet:zkLogin');
                logOutput('zkLogin session storage cleared');
            } catch (e) {
                logOutput('Failed to clear zkLogin session: ' + e.message, true);
            }
        };

        (function initializeEnokiDefaults() {
            try {
                const defaultKey = typeof window !== 'undefined' && window.ENOKI_API_KEY ? String(window.ENOKI_API_KEY).trim() : '';
                if (defaultKey) setEnokiApiKey(defaultKey);
            } catch (_) {}
            try {
                const defaultUrl = typeof window !== 'undefined' && window.ENOKI_API_URL ? String(window.ENOKI_API_URL).trim() : '';
                if (defaultUrl) setEnokiApiUrl(defaultUrl);
            } catch (_) {}
        })();

        // App initialization
        function initializeApp() {
            const loadingScreen = document.getElementById('loading-screen');
            const mainContent = document.getElementById('main-content');

            updateWalletConnectionControls(false);
            setSmartWalletManagementVisible(false);
            hideSmartWalletOperations();

            if (mainContent) {
                mainContent.style.display = 'block';
            }

            requestAnimationFrame(() => {
                if (loadingScreen) {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 150);
                }

                const allSections = document.querySelectorAll('.section');
                const operationsSection = document.getElementById('smartWalletOperations');
                allSections.forEach(section => {
                    if (operationsSection && section === operationsSection) {
                        return;
                    }
                    section.style.display = 'block';
                    section.classList.add('visible');
                });
                setSmartWalletManagementVisible(false);
                hideSmartWalletOperations();
                if (mainContent) {
                    mainContent.classList.add('loaded');
                }
            });

            try {
                const overlay = document.getElementById('walletModal');
                if (overlay) {
                    overlay.addEventListener('click', function(ev){ if (ev.target === overlay) closeWalletModal(); });
                }
                const closeButton = document.getElementById('walletModalClose');
                if (closeButton) {
                    closeButton.addEventListener('click', () => closeWalletModal());
                }
                document.addEventListener('keydown', function(ev){ if (ev.key === 'Escape') closeWalletModal(); });
            } catch (e) {}

            scheduleBootstrapWork();
        }

        // Initialize when ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</head>
<body>
    <!-- Loading screen -->
    <div class="container" id="loading-screen">
        <h1><span class="sw-icon" aria-hidden="true"></span> SmartWallet</h1>
        <div class="app-loading">
            <p>Loading smart contract interface...</p>
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- Main content -->
    <div class="container main-content" id="main-content">
        <h1><span class="sw-icon" aria-hidden="true"></span> SmartWallet</h1>
        <p style="text-align: center; color: #c3d5e8; font-size: 16px; margin-top: -10px; margin-bottom: 30px;">
            Interface for deployed smart contracts
        </p>
        

        <div class="section">
            <div class="wallet-connection-header">
                <h3>Wallet Connection</h3>
                <button id="walletHeaderAction" class="primary-btn connect-wallet-inline">Connect</button>
            </div>

            <details id="walletConnectionControls" class="section-toggle">
                <summary>
                    <span>Wallet Connection Controls</span>
                    <span id="walletConnectionStatus" class="summary-status">Not connected</span>
                </summary>
                <div style="padding: 5px;">

                    <!-- Traditional Options -->
                    <details style="margin-top: 25px; border: 1px solid rgba(69,139,189,.3); border-radius: 8px; padding: 15px;">
                        <summary style="cursor: pointer; font-weight: 600; color: #c3d5e8; font-size: 13px;">‚öôÔ∏è Traditional Wallet Options</summary>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(69,139,189,.2);">
                            <button onclick="createNewWallet()">Create New Wallet</button>
                            <div class="form-group">
                                <input type="text" id="privateKeyInput" placeholder="Private key for import...">
                                <button onclick="restoreWallet()">Import Wallet</button>
                            </div>
                        </div>
                    </details>
                    
                    <!-- View-Only Connection -->
                    <details style="margin-top: 15px; border: 1px solid rgba(139,69,189,.3); border-radius: 8px; padding: 10px;">
                        <summary style="cursor: pointer; font-weight: 500; color: #c3d5e8; font-size: 12px;">üëÅÔ∏è View-Only Connection</summary>
                        <div style="margin-top: 10px;">
                            <p style="font-size: 11px; color: #a0b3c5; margin: 0 0 8px 0;">Enter a Sui address (0x...) or SuiNS name (example.sui) to view balances without signing.</p>
                            <input type="text" id="viewOnlyTarget" placeholder="0x... or name.sui" style="width: 70%; font-size: 12px;">
                            <button onclick="connectViewOnly(document.getElementById('viewOnlyTarget').value)" style="font-size: 12px; padding: 5px 10px;">Connect View-Only</button>
                        </div>
                    </details>
                </div>
            </details>

            <div id="walletInfo" class="wallet-info" style="display: none;">
                <h4 class="wallet-heading">Connected Wallet
                    <span id="walletSuinsName" class="wallet-suins" style="display:none;">
                        <span id="walletSuinsValue" class="address-value"></span>
                        <button type="button" class="copy-btn" data-copy-target="walletSuinsValue" data-copy-allow-any="true" aria-label="Copy SuiNS name" title="Copy SuiNS name">Copy</button>
                    </span>
                </h4>
                <p><strong>Type:</strong> <span id="walletType">Unknown</span></p>
                <p class="address-row"><strong>Address:</strong>
                    <span id="currentAddress" class="address-value"></span>
                    <button type="button" class="copy-btn" data-copy-target="currentAddress" aria-label="Copy address" title="Copy address">Copy</button>
                </p>
                <p class="balance-row"><strong>Balance:</strong>
                    <span id="currentBalance" class="balance-value">Loading...</span>
                    <button type="button" class="balance-refresh" onclick="getWalletBalance()" aria-label="Refresh balance">Refresh</button>
                </p>
                <button onclick="disconnectWallet()" style="background: #dc3545;">Disconnect</button>
            </div>
        </div>

        <div id="smartWalletManagementSection" class="section" style="display: none;">
            <h3>Smart Wallet Management</h3>
            <div class="form-group">
                <label>Wallet Name:</label>
                <input type="text" id="walletName" placeholder="My Smart Wallet">
            </div>
            <div class="form-group">
                <label>Recovery Key Address (optional):</label>
                <input type="text" id="recoveryKey" placeholder="Leave empty to use current wallet">
            </div>
            <button onclick="createSmartWallet()" class="primary-btn">Create Smart Wallet</button>
            <button onclick="findMyWallets()">Find My Wallets</button>
            
            <div id="walletsList"></div>
        </div>

        <div id="smartWalletOperations" class="section" style="display: none;">
            <h3>Smart Wallet Operations</h3>
            <div class="address-display">Selected Wallet:
                <span id="selectedWalletId" class="address-value">None</span>
                <button type="button" class="copy-btn" data-copy-target="selectedWalletId" aria-label="Copy selected wallet ID" title="Copy selected wallet ID">Copy</button>
            </div>
            
            <div class="contract-card">
                <h4>Add Member</h4>
                <div class="form-group">
                    <label>Member Address:</label>
                    <input type="text" id="newMemberAddress" placeholder="0x...">
                </div>
                <div class="form-group">
                    <label>Role Name:</label>
                    <input type="text" id="memberRole" placeholder="member" value="member">
                </div>
                <div class="form-group">
                    <label>Weight:</label>
                    <input type="number" id="memberWeight" placeholder="1" value="1" min="1">
                </div>
                <div class="form-group">
                    <label>Permissions (1=propose, 2=approve, 4=execute, 7=all):</label>
                    <input type="number" id="memberPermissions" placeholder="7" value="7" min="1" max="7">
                </div>
                <button onclick="addMember()">Add Member</button>
            </div>

            <div class="contract-card">
                <h4>Create Proposal</h4>
                <div class="form-group">
                    <label>Proposal ID:</label>
                    <input type="number" id="proposalId" placeholder="Auto-generated if empty">
                </div>
                <div class="form-group">
                    <label>Action Type:</label>
                    <input type="text" id="actionKind" placeholder="transfer" value="transfer">
                </div>
                <div class="form-group">
                    <label>Target Address:</label>
                    <input type="text" id="targetAddress" placeholder="0x...">
                </div>
                <div class="form-group">
                    <label>Action Data (for transfer: amount in SUI):</label>
                    <input type="text" id="actionData" placeholder="1.0">
                </div>
                <div class="form-group">
                    <label>Voting Threshold:</label>
                    <input type="number" id="proposalThreshold" placeholder="1" value="1" min="1">
                </div>
                <div class="form-group">
                    <label>Deadline (timestamp, 0 for no deadline):</label>
                    <input type="number" id="proposalDeadline" placeholder="0" value="0">
                </div>
                <button onclick="createProposal()">Create Proposal</button>
            </div>

            <div class="contract-card">
                <h4>Approve Proposal</h4>
                <div class="form-group">
                    <label>Proposal ID:</label>
                    <input type="number" id="approveProposalId" placeholder="Proposal ID">
                </div>
                <button onclick="approveProposal()">Approve Proposal</button>
            </div>

            <div class="contract-card">
                <h4>Deposit to Wallet</h4>
                <div class="form-group">
                    <label>Amount (SUI):</label>
                    <input type="number" id="depositAmount" placeholder="1.0" step="0.001" min="0.001">
                </div>
                <button onclick="depositToWallet()">Deposit SUI</button>
            </div>
        </div>

        <div id="contract-info" class="section">
            <details class="section-toggle" id="contractInfoToggle">
                <summary>üì¶ Contract Information</summary>
                <div class="contract-card">
                    <h4>Deployed Package</h4>
                    <div class="address-display">Package ID:
                        <span id="packageIdDisplay" class="address-value">Not set</span>
                        <button type="button" class="copy-btn" data-copy-target="packageIdDisplay" aria-label="Copy package ID" title="Copy package ID">Copy</button>
                    </div>
                    <div class="form-group">
                        <label for="packageIdInput">Set Package ID for current network</label>
                        <div style="display:flex; gap:8px; align-items:center;">
                            <input id="packageIdInput" type="text" placeholder="0x..." style="flex:1;" />
                            <button onclick="savePackageIdOverride()" style="white-space:nowrap;">Save</button>
                            <button onclick="clearPackageIdOverride()" style="white-space:nowrap; background:#6c757d;">Clear</button>
                        </div>
                        <div style="font-size:11px; color:#a0b3c5; margin-top:6px;">Overrides are stored in localStorage per network.</div>
                    </div>
                    <p><strong>Modules:</strong> core, roster, multisig</p>
                    <p><strong>Network:</strong> <span id="currentNetwork">testnet</span></p>
                    <div class="form-group">
                        <label>Network Selection:</label>
                        <select id="networkSelect" onchange="changeNetwork()">
                            <option value="devnet">Devnet</option>
                            <option value="testnet" selected>Testnet</option>
                            <option value="mainnet">Mainnet</option>
                        </select>
                    </div>
                    <div class="contract-card-group">
                        <h4>Roster Management</h4>
                        <p style="margin-top: 8px;">The roster tracks wallet memberships across the system.</p>
                        <div class="form-group" style="margin-top: 12px;">
                            <div class="address-display">Roster ID:
                                <span id="rosterId" class="address-value">Not found</span>
                                <button type="button" class="copy-btn" data-copy-target="rosterId" aria-label="Copy roster ID" title="Copy roster ID">Copy</button>
                            </div>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            <button onclick="initRoster()">Initialize Roster</button>
                            <button onclick="findRoster()">Find Roster</button>
                        </div>
                    </div>
                </div>
            </details>
        </div>

        <div class="section">
            <h3>Console Output</h3>
            <button onclick="clearOutput()">Clear Output</button>
            <div id="output">SmartWallet Contract Interface Ready

</div>
        </div>
    </div>
    <!-- Wallet Selection Modal -->
    <div id="walletModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="walletModalTitle">
      <div class="modal" role="document">
        <div class="modal-header">
          <h4 id="walletModalTitle" class="modal-title">Select a Sui Wallet</h4>
          <button id="walletModalClose" class="modal-close" aria-label="Close">‚úï</button>
        </div>
        <div id="walletModalBody" class="modal-body">
          <div id="walletModalList"></div>
        </div>
      </div>
    </div>
    
</body>
</html>
