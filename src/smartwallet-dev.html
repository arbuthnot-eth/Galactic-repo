<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Wallet</title>

    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://accounts.google.com blob:; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; connect-src 'self' https: wss:; worker-src 'self' blob:; child-src 'self' blob:; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">

    <!-- Dev favicon: served from assets; injector may override in prod -->
    <link rel="icon" type="image/png" href="/assets/favicon-128.png" onerror="this.onerror=null; this.href='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzQ1OEJCRCIvPgo8dGV4dCB4PSI1MCUiIHk9IjUwJSIgZmlsbD0iI0ZGRkZGRiIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIGZvbnQtd2VpZ2h0PSI2MDAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJjZW50cmFsIj5XPC90ZXh0Pgo8L3N2Zz4='">

    <!-- Google OAuth -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        // Optimized favicon loading - defer until critical content loads
        window.addEventListener('load',function(){
            const link=document.querySelector('link[rel="icon"]');
            if(link&&link.href){
                const styleEl=document.createElement('style');
                styleEl.id='sw-favicon-var';
                styleEl.textContent=`:root{--sw-favicon-url:url("${link.href}")}`;
                (document.body||document.head).appendChild(styleEl);
            }
        });
    </script>

    <!-- zk-Login dependencies -->
    <script>
        // zkLogin circuit runtime will be loaded via zklogin-helpers bundle
        // Static WASM assets should be available at /zklogin.wasm, /zklogin.zkey, /verification_key.json
    </script>
    <!-- Critical CSS for immediate rendering -->
    <style>
        html {
            height: 100%;
            overflow-y: auto;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a2332 0%, #2a3d52 100%);
            color: #f4f1ef;
            min-height: 100vh;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .container {
            background: linear-gradient(145deg, #1e3a52 0%, #2d4a66 100%);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            border: 1px solid rgba(69, 139, 189, 0.3);
        }
        h1 {
            color: #f4f1ef;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* Main content shows immediately */
        .main-content.loaded {
            opacity: 1;
        }

        /* Sections fade in smoothly */
        .section {
            margin:20px 0;padding:20px;border:1px solid rgba(69,139,189,.4);border-radius:10px;background:linear-gradient(145deg,rgba(30,58,82,.6),rgba(45,74,102,.6));backdrop-filter:blur(10px);display:none;opacity:0;transition:opacity .5s ease-in;
        }
        .section.visible {
            opacity: 1;
        }
        
        /* Critical elements - optimized */
        body,.container,h1{visibility:visible!important}
        .section h3{margin-top:0;color:#c3d5e8;text-shadow:0 1px 2px rgba(0,0,0,.3)}
        :root{--sw-favicon-url:initial;--sw-modal-surface:linear-gradient(145deg,#1e3a52 0%,#2d4a66 100%)}
        .sw-icon{display:inline-block;width:1em;height:1em;background-image:var(--sw-favicon-url);background-size:contain;background-repeat:no-repeat;vertical-align:-.15em}
        button{background:linear-gradient(145deg,#458BBD,#5A9BD4);color:#f4f1ef;border:none;padding:10px 20px;border-radius:8px;cursor:pointer;margin:5px;font-size:14px;transition:all .3s ease;box-shadow:0 3px 8px rgba(0,0,0,.3);border:1px solid rgba(90,155,212,.3)}
        button:hover{background:linear-gradient(145deg,#5A9BD4,#6BB6FF);transform:translateY(-1px);box-shadow:0 6px 12px rgba(0,0,0,.4)}
        button:disabled{background:rgba(69,139,189,.4);cursor:not-allowed;transform:none;color:rgba(244,241,239,.5)}
        .primary-btn{border-radius:12px;padding:15px 25px;font-size:16px;font-weight:600;box-shadow:0 6px 15px rgba(0,0,0,.25);border:1px solid rgba(69,139,189,.5);cursor:pointer;transition:all .3s ease;background:linear-gradient(145deg,#2d4a66,#458BBD)}
        .primary-btn:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,.35);background:linear-gradient(145deg,#458BBD,#5A9BD4)}
        input[type="text"],input[type="number"],input[type="password"],textarea{padding:12px;border:1px solid rgba(69,139,189,.4);border-radius:8px;margin:5px;background:rgba(30,58,82,.3);color:#f4f1ef;backdrop-filter:blur(5px);font-size:14px}
        .copy-btn{margin:0 0 0 8px;padding:6px 10px;font-size:12px;line-height:1;border-radius:6px;background:rgba(69,139,189,.6);border:1px solid rgba(69,139,189,.5);box-shadow:none}
        .copy-btn:hover{background:rgba(90,155,212,.85)}
        .copy-btn:disabled{opacity:.6;cursor:not-allowed}
        .copy-btn[data-copied="true"]{background:#2e7d32;border-color:#2e7d32;color:#fff}
        .address-row,.address-display{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
        .address-value{font-family:'Courier New',monospace;font-size:13px;word-break:break-all}
        .wallet-heading{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:10px}
        .wallet-suins{display:inline-flex;align-items:center;gap:6px;padding:2px 6px;border-radius:6px;background:rgba(69,139,189,.2);font-size:12px;color:#aedaef}
        input[type="text"]:focus,input[type="number"]:focus,input[type="password"]:focus,textarea:focus{outline:none;border-color:#5A9BD4;box-shadow:0 0 10px rgba(90,155,212,.3)}
        input::placeholder,textarea::placeholder{color:rgba(244,241,239,.6)}
        #output{background:#2c3e50;color:#ecf0f1;padding:15px;border-radius:5px;font-family:'Courier New',monospace;font-size:12px;max-height:300px;overflow-y:auto;white-space:pre-wrap;margin-top:20px}
        .wallet-connection-header{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:12px;margin-bottom:12px}
        .wallet-connection-header h3{margin:0}
        .connect-wallet-inline{padding:8px 16px;font-size:14px;background:linear-gradient(145deg,#4CAF50,#45a049);box-shadow:0 4px 12px rgba(0,0,0,.25);}
        .connect-wallet-inline:hover{background:linear-gradient(145deg,#45a049,#3f8f44)}
        .connect-wallet-inline.disconnect{background:#dc3545;box-shadow:0 4px 12px rgba(0,0,0,.25);border:1px solid rgba(220,53,69,.6);}
        .connect-wallet-inline.disconnect:hover{background:#c82333}
        .balance-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
        .balance-value{font-family:'Courier New',monospace;}
        .balance-refresh{margin:0;padding:6px 10px;font-size:12px;line-height:1;border-radius:6px;background:rgba(69,139,189,.6);border:1px solid rgba(69,139,189,.5);color:#f4f1ef;cursor:pointer;transition:background .2s ease;box-shadow:none}
        .balance-refresh:hover{background:rgba(90,155,212,.85)}
        @media (max-width:600px){.wallet-connection-header{flex-direction:column;align-items:stretch}.wallet-connection-header h3{text-align:left}.connect-wallet-inline{width:100%}}
        .wallet-info{background:linear-gradient(145deg,#1f3b2f,#254836);border-left:4px solid #27ae60;padding:12px;margin:12px 0;border-radius:10px;color:#e6f2e6}
        .wallet-info strong{color:#f4fff4}
        .error{background:#fdf2f2;border-left:4px solid #e74c3c;padding:10px;margin:10px 0;color:#c0392b}
        .success{background:#d4edda;border-left:4px solid #28a745;padding:10px;margin:10px 0;color:#155724}
        
        .address-display {
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,.3);
            padding: 8px;
            border-radius: 5px;
            word-break: break-all;
            font-size: 12px;
        }
        .form-group {
            margin: 15px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #c3d5e8;
            font-weight: 500;
        }
        .form-group input, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        /* Modal styles */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; align-items: center; justify-content: center; z-index: 1000; }
        .modal-overlay.visible { display: flex; }
        .modal { width: min(600px, 92vw); max-height: 80vh; display: flex; flex-direction: column; overflow: hidden; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 1px solid rgba(69,139,189,.4); background: var(--sw-modal-surface); }
        .modal-header { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; border-bottom: 1px solid rgba(69,139,189,.3); }
        .modal-title { margin: 0; font-size: 16px; color: #cfe4f7; font-weight: 600; }
        .modal-close { background: transparent; border: none; color: #cfe4f7; font-size: 18px; cursor: pointer; padding: 6px 8px; }
        .modal-body { flex: 1; min-height: 0; padding: 12px 16px 20px; overflow-y: auto; overflow-x: visible; background: linear-gradient(155deg, rgba(30,58,82,.95) 0%, rgba(41,70,96,.98) 100%); }
        .wallet-card { display: flex; align-items: center; justify-content: space-between; gap: 12px; border: 1px solid rgba(69,139,189,.3); border-radius: 8px; padding: 12px; background: rgba(69,139,189,.08); margin: 10px 0; width: 100%; cursor: pointer; text-align: left; color: inherit; font: inherit; transition: border-color .2s ease, background .2s ease, transform .1s ease; position: relative; }
        .wallet-card::after { content: '→'; font-size: 16px; color: #8fb9df; margin-left: auto; display: inline-flex; align-items: center; }
        .wallet-card:hover { border-color: rgba(90,155,212,.6); background: rgba(69,139,189,.15); transform: translateY(-1px); }
        .wallet-card:focus-visible { outline: 2px solid rgba(90,155,212,.8); outline-offset: 2px; }
        .wallet-card-icon-wrap { width: 48px; height: 48px; border-radius: 12px; overflow: hidden; flex-shrink: 0; display: flex; align-items: center; justify-content: center; background: rgba(69,139,189,.12); border: 1px solid rgba(69,139,189,.2); }
        .wallet-card-icon { width: 100%; height: 100%; object-fit: cover; display: block; }
        .wallet-card-icon.passkey-icon { width: 80%; height: 80%; object-fit: contain; }
        .wallet-card-content { flex: 1; min-width: 0; }
        .wallet-card-name { font-weight: 600; color: #cfe4f7; }

        /* zkLogin provider selection styles */
        .zklogin-providers { position: relative; display: inline-block; width: 100%; }
        .zklogin-providers .wallet-card { margin: 0; }
        .zklogin-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: var(--sw-modal-surface); border: 1px solid rgba(69,139,189,.4); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1001; display: none; margin-top: 4px; }
        .zklogin-dropdown.visible { display: block; }
        .zklogin-provider { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border: none; background: transparent; color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; transition: background .2s ease; }
        .zklogin-provider:hover { background: rgba(69,139,189,.15); }
        .zklogin-provider:first-child { border-radius: 8px 8px 0 0; }
        .zklogin-provider:last-child { border-radius: 0 0 8px 8px; }
        .zklogin-provider:only-child { border-radius: 8px; }

        /* Traditional wallet dropdown styles */
        .traditional-providers { position: relative; display: block; width: 100%; }
        .traditional-providers .wallet-card { margin: 0; }
        .traditional-dropdown { position: relative; background: var(--sw-modal-surface); border: 1px solid rgba(69,139,189,.4); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1; display: none; margin-top: 8px; max-width: 100%; overflow: hidden; }
        .traditional-dropdown.visible { display: block; }
        .traditional-provider { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border: none; background: transparent; color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; transition: background .2s ease; }
        .traditional-provider:hover { background: rgba(69,139,189,.15); }
        .traditional-provider:first-child { border-radius: 8px 8px 0 0; }
        .traditional-provider:last-child { border-radius: 0 0 8px 8px; }
        .traditional-provider:only-child { border-radius: 8px; }
        .traditional-provider-icon { width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 10px; }

        /* Traditional wallet form styles */
        .form-row input:focus { outline: none; border-color: rgba(90,155,212,.6); }
        .form-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
        .form-actions button { padding: 6px 12px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: transparent; color: #cfe4f7; cursor: pointer; font-size: 11px; }
        .form-actions .create-btn { background: #ff6b35; border-color: #ff6b35; color: white; font-weight: 600; }

        /* Create wallet dropdown styles */
        .create-wallet-container { position: relative; display: inline-block; width: 100%; }
        .create-wallet-dropdown { position: relative; background: var(--sw-modal-surface); border: 1px solid rgba(69,139,189,.4); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1; display: none; margin-top: 8px; max-height: none; overflow: visible; }
        .create-wallet-dropdown.visible { display: block; }
        .create-wallet-dropdown .traditional-provider-form { min-height: 210px; }

        /* Wallet item styles */
        .wallet-item:hover { background: rgba(69,139,189,.15); }
        .wallet-delete-btn { opacity: 0.7; transition: all 0.2s ease; }
        .wallet-delete-btn:hover { opacity: 1; color: #ff6666; transform: scale(1.1); }
        .wallet-list { max-height: 100px; overflow-y: auto; overflow-x: hidden; width: 100%; }
        .wallet-list::-webkit-scrollbar { width: 4px; }
        .wallet-list::-webkit-scrollbar-track { background: rgba(69,139,189,.1); }
        .wallet-list::-webkit-scrollbar-thumb { background: rgba(69,139,189,.3); border-radius: 2px; }
        .zklogin-provider-icon { width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        .zklogin-provider-icon svg { width: 100%; height: 100%; }
        .zklogin-provider-name { font-weight: 500; }
    </style>
    
    <!-- BUNDLE_PLACEHOLDER -->
    <script>
        // Shell dev bootstrap: ensure global and try to load IIFE bundle when developing.
        window.process={env:{NODE_ENV:'development'}};window.global=window.globalThis||window;
        (function ensureDevSdk(){
            if (window.SuiSDK) return; // Already injected (e.g., in production build)
            try {
                const s=document.createElement('script');
                s.src='/dist/sui-sdk-shell.iife.js';
                s.async=false;
                s.onload=function(){console.log('Dev SDK bundle loaded');};
                s.onerror=function(){console.warn('Dev SDK bundle not found. Run "npm run build" or serve dist/.');};
                document.head.appendChild(s);
            } catch(e){console.warn('Failed to attach dev SDK loader:', e);}
        })();

        let zkLoginHelpersPromise=null;
        window.__SMARTWALLET_ZKLOGIN_BASE64=window.__SMARTWALLET_ZKLOGIN_BASE64||'';

        function decodeZkLoginBase64(value){
            if(!value) return '';
            const globalRef=typeof globalThis!=='undefined'?globalThis:window;
            if(typeof globalRef.atob==='function'){
                return globalRef.atob(value);
            }
            if(globalRef.Buffer&&typeof globalRef.Buffer.from==='function'){
                return globalRef.Buffer.from(value,'base64').toString('utf8');
            }
            throw new Error('Base64 decoder unavailable');
        }

        function evaluateZkLoginSource(source){
            const execute=new Function(source);
            execute();
        }

        window.loadZkLoginHelpers=function(){
            if(window.WitnessCalculatorBuilder){
                return Promise.resolve();
            }
            if(zkLoginHelpersPromise){
                return zkLoginHelpersPromise;
            }
            zkLoginHelpersPromise=new Promise((resolve,reject)=>{
                const inlineBundle=window.__SMARTWALLET_ZKLOGIN_BASE64;
                if(inlineBundle){
                    try{
                        evaluateZkLoginSource(decodeZkLoginBase64(inlineBundle));
                        if(window.WitnessCalculatorBuilder){
                            resolve();
                            return;
                        }
                        console.warn('zkLogin helpers inline bundle executed but WitnessCalculatorBuilder missing; falling back to network fetch.');
                    }catch(error){
                        console.warn('Inline zkLogin helper load failed, falling back to network bundle.', error);
                    }
                }

                const script=document.createElement('script');
                script.src='/dist/zklogin-helpers.iife.js';
                script.async=true;
                script.onload=function(){
                    if(window.WitnessCalculatorBuilder){
                        resolve();
                    }else{
                        reject(new Error('zkLogin helpers script executed but WitnessCalculatorBuilder is unavailable'));
                    }
                };
                script.onerror=function(){
                    reject(new Error('Failed to load zkLogin helper bundle'));
                };
                document.head.appendChild(script);
            }).catch(error=>{
                zkLoginHelpersPromise=null;
                throw error;
            });

            return zkLoginHelpersPromise;
        };
    </script>
    
    <script type="module">

        const HEX_ADDRESS_RE = /^0x[0-9a-fA-F]{2,}$/;
        const HEX_STRING_RE = /^(0x)?[0-9a-fA-F]{2,}$/;
        const SUINS_NAME_RE = /^[a-z0-9]+(?:[-.][a-z0-9]+)*\.sui$/i;

        let currentWallet = null;
        let currentNetwork = 'testnet';
        let suiClient = null;
        let connectedWalletStandard = null; // Will store connected wallet standard wallet
        const suinsResolutionCache = new Map();
        const suinsReverseCache = new Map();
        let currentReverseLookupToken = 0;
        let sdkReadyPromise = null;
        let bootstrapPromise = null;


        const ZKLOGIN_CONFIG = {
            GOOGLE_CLIENT_ID: '373405271144-kevesn5h18jt8grqh5cel7jcsu9si73t.apps.googleusercontent.com',
            REDIRECT_PATH: '/auth/callback.html',
            EPOCH_BUFFER: 5,
            KEY_CLAIM_NAME: 'sub',
            PROVER_URL: (typeof window !== 'undefined' && window.ZKLOGIN_PROVER_URL) ? String(window.ZKLOGIN_PROVER_URL) : ''
        };

        let pendingZkLoginContext = null;


        function escapeHtml(value) {
            return String(value ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function makeWalletIcon(label, bg, fg = '#ffffff') {
            const text = (label || 'W').toString().trim().slice(0, 2).toUpperCase() || 'W';
            const fontSize = text.length > 1 ? 18 : 22;
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48"><rect width="48" height="48" rx="12" fill="${bg}"/><text x="50%" y="50%" fill="${fg}" font-family="'Segoe UI', 'Inter', sans-serif" font-size="${fontSize}" font-weight="600" text-anchor="middle" dominant-baseline="central">${text}</text></svg>`;
            return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
        }

        // Wallet encryption/decryption utilities
        async function encryptPrivateKey(privateKey, password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(privateKey);
            const passwordData = encoder.encode(password);

            // Derive key from password
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                passwordData,
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );

            const salt = crypto.getRandomValues(new Uint8Array(16));
            const key = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );

            // Encrypt the private key
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt(
                {
                    name: 'AES-GCM',
                    iv: iv
                },
                key,
                data
            );

            // Combine salt + iv + encrypted data
            const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
            result.set(salt, 0);
            result.set(iv, salt.length);
            result.set(new Uint8Array(encrypted), salt.length + iv.length);

            return btoa(String.fromCharCode.apply(null, result));
        }

        async function decryptPrivateKey(encryptedData, password) {
            try {
                const decoder = new TextDecoder();
                const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));

                const salt = data.slice(0, 16);
                const iv = data.slice(16, 28);
                const encrypted = data.slice(28);

                const passwordData = new TextEncoder().encode(password);

                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    passwordData,
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );

                const key = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );

                const decrypted = await crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    key,
                    encrypted
                );

                return decoder.decode(decrypted);
            } catch (error) {
                throw new Error('Invalid password or corrupted data');
            }
        }

        // Wallet storage management
        function getStoredWallets() {
            const wallets = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('galactic:wallet:')) {
                    try {
                        const walletData = JSON.parse(localStorage.getItem(key));
                        wallets.push(walletData);
                    } catch (e) {
                        // Skip corrupted entries
                    }
                }
            }
            return wallets.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        }

        function saveWallet(name, encryptedPrivateKey, address) {
            const walletData = {
                name,
                encryptedPrivateKey,
                address,
                createdAt: new Date().toISOString()
            };
            localStorage.setItem(`galactic:wallet:${name}`, JSON.stringify(walletData));
        }

        function deleteWallet(name) {
            if (confirm(`Are you sure you want to delete the wallet "${name}"? This action cannot be undone.`)) {
                localStorage.removeItem(`galactic:wallet:${name}`);
                logOutput(`Wallet "${name}" deleted successfully`);
                return true;
            }
            return false;
        }

        async function deleteWalletAndRefresh(walletName, walletIndex) {
            const success = deleteWallet(walletName);
            if (success) {
                // Check if any wallets remain
                const remainingWallets = getStoredWallets();

                if (remainingWallets.length === 0) {
                    // No wallets left, show create form
                    const dropdown = document.getElementById('traditionalDropdown' + walletIndex);
                    if (dropdown && dropdown.classList.contains('visible')) {
                        showCreateWalletForm(dropdown, walletIndex);
                    }
                } else {
                    // Refresh the dropdown to show updated wallet list
                    const dropdown = document.getElementById('traditionalDropdown' + walletIndex);
                    if (dropdown && dropdown.classList.contains('visible')) {
                        showTraditionalWalletOptions(dropdown, walletIndex);
                    }
                }
            }
        }



        function getZkLoginRedirectUri() {
            try {
                if (!window.location || !window.location.origin) {
                    return ZKLOGIN_CONFIG.REDIRECT_PATH || '/auth/callback.html';
                }
                const url = new URL(ZKLOGIN_CONFIG.REDIRECT_PATH || '/auth/callback.html', window.location.origin);
                return url.toString();
            } catch (_) {
                return `${window.location.origin || ''}/auth/callback.html`;
            }
        }

        function mapIssuerToProvider(iss) {
            if (!iss) return 'Unknown Provider';
            const normalized = iss.replace(/^https?:\/\//, '');
            if (normalized.startsWith('accounts.google.com')) return 'Google';
            if (normalized.includes('apple')) return 'Apple';
            if (normalized.includes('facebook')) return 'Facebook';
            try {
                const url = new URL(iss);
                return url.hostname;
            } catch (_) {
                return normalized;
            }
        }

        function buildZkLoginAuthUrl(nonce) {
            const params = new URLSearchParams({
                client_id: ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID,
                redirect_uri: getZkLoginRedirectUri(),
                response_type: 'id_token',
                scope: 'openid email profile',
                nonce: nonce,
                prompt: 'select_account',
                state: 'zklogin_galactic'
            });
            return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
        }

        async function prepareZkLoginContext() {
            // Ensure all required SDK tiers are loaded
            await ensureSDKTier('transaction', 'keypair generation');
            await ensureSDKTier('advanced', 'zkLogin support');

            if (!window.SuiSDK || !window.SuiSDK.ZkLogin || !window.SuiSDK.Sui) {
                throw new Error('Sui SDK not loaded');
            }
            if (!suiClient) {
                await initializeSuiClient();
            }
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            const { getExtendedEphemeralPublicKey, generateRandomness, generateNonce } = window.SuiSDK.ZkLogin;

            // Validate keypair generation capability
            if (!Ed25519Keypair || typeof Ed25519Keypair.generate !== 'function') {
                throw new Error('Ed25519Keypair.generate is not available - transaction tier may not be loaded');
            }

            const ephemeralKeyPair = Ed25519Keypair.generate();
            if (!ephemeralKeyPair) {
                throw new Error('Failed to generate ephemeral keypair');
            }
            const extendedPublicKey = getExtendedEphemeralPublicKey(ephemeralKeyPair.getPublicKey());

            // Generate local randomness and nonce
            const randomness = generateRandomness();
            const additionalEpochs = Number(ZKLOGIN_CONFIG.EPOCH_BUFFER ?? 5);

            // Fetch current epoch from Sui network
            const currentEpochInfo = await suiClient.getLatestSuiSystemState();
            const currentEpoch = Number(currentEpochInfo.epoch);
            // Set maxEpoch to currentEpoch + 1 for future-proofing as per zklogin2-instructions
            const maxEpoch = BigInt(currentEpoch + 1);
            const nonce = generateNonce(ephemeralKeyPair.getPublicKey(), maxEpoch, randomness);

            return {
                ephemeralKeyPair,
                randomness,
                nonce,
                maxEpoch: String(maxEpoch),
                currentEpoch: String(currentEpoch), // Store currentEpoch for consistent use during proof generation
                extendedPublicKey,
                provider: 'local',
                expiresAt: null // Local generation doesn't have predefined expiration
            };
        }

        function openOAuthPopup(authUrl) {
            return new Promise((resolve, reject) => {
                const popup = window.open(
                    authUrl,
                    'zklogin_oauth',
                    'width=500,height=600,scrollbars=yes,resizable=yes'
                );

                if (!popup) {
                    reject(new Error('Failed to open popup - please allow popups'));
                    return;
                }

                let checkClosed = null;

                const cleanup = () => {
                    window.removeEventListener('message', messageHandler);
                    if (checkClosed) {
                        clearInterval(checkClosed);
                        checkClosed = null;
                    }
                };

                const messageHandler = (event) => {
                    if (event.origin !== window.location.origin) {
                        return;
                    }
                    if (event.data?.type === 'zklogin_oauth_success') {
                        cleanup();
                        resolve(event.data.idToken);
                    } else if (event.data?.type === 'zklogin_oauth_error') {
                        cleanup();
                        reject(new Error('OAuth error: ' + event.data.error));
                    }
                };

                window.addEventListener('message', messageHandler);

                checkClosed = setInterval(() => {
                    try {
                        if (popup.closed) {
                            cleanup();
                            reject(new Error('OAuth popup was closed by user'));
                        }
                    } catch (error) {
                        // Cross-origin policy blocks popup.closed access - ignore silently
                        // The popup will still work via the message handler
                    }
                }, 800);
            });
        }

        function validateZkLoginJwt(decodedJwt, expectedNonce, expectedAud) {
            if (!decodedJwt) {
                throw new Error('Missing JWT payload');
            }
            if (!decodedJwt.sub) {
                throw new Error('JWT missing subject (sub)');
            }
            if (!decodedJwt.iss) {
                throw new Error('JWT missing issuer (iss)');
            }
            if (!decodedJwt.nonce) {
                throw new Error('JWT missing nonce');
            }
            if (decodedJwt.nonce !== expectedNonce) {
                throw new Error('Nonce mismatch between request and JWT');
            }
            if (decodedJwt.aud !== expectedAud) {
                throw new Error('Unexpected JWT audience');
            }
            return true;
        }

        // zkLogin provider configuration
        const ZKLOGIN_PROVIDERS = {
            google: {
                name: 'Google',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18A10.85 10.85 0 001 12c0 1.61.39 3.14 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC04"/><path d="M12 4.75c1.61 0 3.06.55 4.22 1.64l3.15-3.15C17.45 1.09 14.97 0 12 0 7.7 0 3.99 2.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>',
                clientId: 'GOOGLE_CLIENT_ID'
            },
            facebook: {
                name: 'Meta',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.927v-8.437H7.078v-3.49h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.49h-2.796v8.437C19.612 23.027 24 18.062 24 12.073z" fill="#1877F2"/></svg>',
                clientId: 'FACEBOOK_CLIENT_ID'
            },
            apple: {
                name: 'Apple',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.71 19.5c-.83 1.24-1.71 2.45-3.05 2.47-1.34.03-1.77-.79-3.29-.79-1.53 0-2 .77-3.27.82-1.31.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.39c.87-1.52 2.43-2.48 4.12-2.51 1.28-.02 2.5.87 3.29.87.78 0 2.26-1.07 3.81-.91.65.03 2.47.26 3.64 1.98-.09.06-2.17 1.28-2.15 3.81.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.19-.69.85-1.83 1.51-2.95 1.42-.15-1.15.41-2.35 1.05-3.11z" fill="#ffffff"/></svg>',
                clientId: 'APPLE_CLIENT_ID'
            }
        };

        function createZkLoginProviderIcon(provider) {
            return ZKLOGIN_PROVIDERS[provider]?.icon || makeWalletIcon('ZK', '#6c4bcc');
        }

        async function ensureZkLoginHelpers() {
            if (window.WitnessCalculatorBuilder) {
                return;
            }
            if (typeof window.loadZkLoginHelpers !== 'function') {
                throw new Error('zkLogin helper loader is not available');
            }
            await window.loadZkLoginHelpers();
            if (!window.WitnessCalculatorBuilder) {
                throw new Error('zkLogin helpers failed to load correctly - WitnessCalculatorBuilder missing');
            }
        }

        // Password prompt modal function
        function showPasswordPrompt(options = {}) {
            const { errorMessage = '' } = options;
            return new Promise((resolve, reject) => {
                const modal = document.createElement('div');
                modal.className = 'password-modal-overlay';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: linear-gradient(145deg, #1e3a52 0%, #2d4a66 100%);
                    border-radius: 15px;
                    padding: 30px;
                    box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
                    border: 1px solid rgba(69, 139, 189, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;

                const errorNotice = errorMessage
                    ? `<p id="passwordErrorMessage" style="color: #ff8888; margin-bottom: 12px; text-align: center;">${errorMessage}</p>`
                    : '';

                content.innerHTML = `
                    <h3 style="color: #f4f1ef; margin-top: 0; text-align: center;">zkLogin Password</h3>
                    <p style="color: #cfe4f7; margin-bottom: 20px;">Enter a password to derive your zkLogin salt. This password will be used to encrypt your session data.</p>
                    ${errorNotice}
                    <input type="password" id="zkLoginPasswordInput" placeholder="Password (8+ characters)"
                        style="width: 100%; padding: 12px; background: rgba(30,58,82,.3); border: 1px solid rgba(69,139,189,.4);
                        border-radius: 8px; color: #f4f1ef; font-size: 14px; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="passwordCancel" style="background: rgba(69,139,189,.4); color: #f4f1ef; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px;">Cancel</button>
                        <button id="passwordSubmit" style="background: linear-gradient(145deg,#458BBD,#5A9BD4); color: #f4f1ef; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">Continue</button>
                    </div>
                `;

                modal.appendChild(content);
                document.body.appendChild(modal);

                const passwordInput = document.getElementById('zkLoginPasswordInput');
                const submitBtn = document.getElementById('passwordSubmit');
                const cancelBtn = document.getElementById('passwordCancel');

                passwordInput.focus();
                if (errorMessage) {
                    passwordInput.style.border = '1px solid #ff4444';
                }

                const handleSubmit = () => {
                    const password = passwordInput.value.trim();
                    if (password.length < 8) {
                        passwordInput.style.border = '1px solid #ff4444';
                        passwordInput.focus();
                        return;
                    }
                    document.body.removeChild(modal);
                    resolve(password);
                };

                const handleCancel = () => {
                    document.body.removeChild(modal);
                    reject(new Error('Password prompt cancelled'));
                };

                submitBtn.addEventListener('click', handleSubmit);
                cancelBtn.addEventListener('click', handleCancel);
                passwordInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') handleSubmit();
                    if (e.key === 'Escape') handleCancel();
                });

                // Reset border color on input
                passwordInput.addEventListener('input', () => {
                    passwordInput.style.border = '1px solid rgba(69,139,189,.4)';
                });
            });
        }

        function formatAddressShort(address) {
            if (!address || address.length <= 12) return address || '';
            return `${address.slice(0, 8)}…${address.slice(-4)}`;
        }

        async function handleZkLoginConnect() {
            try {
                logOutput('Starting Google zkLogin…');
                await ensureSdkReady();
                if (!suiClient) {
                    await initializeSuiClient();
                }

                pendingZkLoginContext = await prepareZkLoginContext();
                const authUrl = buildZkLoginAuthUrl(pendingZkLoginContext.nonce);
                const jwt = await openOAuthPopup(authUrl);

                await ensureZkLoginHelpers();

                const { ZkLogin } = window.SuiSDK;
                if (!ZkLogin) {
                    throw new Error('ZkLogin utilities unavailable in SDK bundle');
                }

                const decodedJwt = window.SuiSDK.ZkLogin.decodeJwt(jwt);
                validateZkLoginJwt(decodedJwt, pendingZkLoginContext.nonce, ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID);
                logOutput('Google identity token verified.');

                // Prepare helper references for salt/proof handling
                let getSaltFromSessionStorageFunc;
                if (typeof window.getSaltFromSessionStorage === 'function') {
                    getSaltFromSessionStorageFunc = window.getSaltFromSessionStorage;
                } else {
                    const imports = await import('/src/zklogin-helpers.ts');
                    getSaltFromSessionStorageFunc = imports.getSaltFromSessionStorage;
                }

                let computeIdentityHashFunc;
                if (typeof window.computeZkLoginIdentityHash === 'function') {
                    computeIdentityHashFunc = window.computeZkLoginIdentityHash;
                } else {
                    const imports = await import('/src/zklogin-helpers.ts');
                    computeIdentityHashFunc = imports.computeIdentityHash;
                }

                // Store password-derived salt in session storage with idle timeout
                let identityHash = null;
                let passwordSalt = null;
                let passwordAttempts = 0;

                while ((!passwordSalt || !passwordSalt.length) || !identityHash) {
                    const password = await showPasswordPrompt(
                        passwordAttempts > 0
                            ? { errorMessage: 'Incorrect password. Please try again.' }
                            : {}
                    );

                    try {
                        let saltResult;
                        if (typeof window.storeSaltInSessionStorage === 'function') {
                            saltResult = await window.storeSaltInSessionStorage(password, decodedJwt);
                        } else {
                            const { storeSaltInSessionStorage } = await import('/src/zklogin-helpers.ts');
                            saltResult = await storeSaltInSessionStorage(password, decodedJwt);
                        }

                        if (!saltResult || !saltResult.salt || !saltResult.identityHash) {
                            throw new Error('Salt derivation returned no data');
                        }

                        identityHash = saltResult.identityHash;
                        passwordSalt = saltResult.salt;
                        if (passwordAttempts > 0) {
                            logOutput('Password accepted; session unlocked.');
                        }
                    } catch (error) {
                        const message = (error && error.message) ? error.message : String(error);
                        if (message.includes('Incorrect password')) {
                            passwordAttempts += 1;
                            logOutput('Password incorrect; try again.');
                            identityHash = null;
                            passwordSalt = null;
                            continue;
                        }

                        logOutput('❌ Failed to setup session storage: ' + message, true);
                        throw error;
                    }

                    if ((!passwordSalt || !passwordSalt.length) || !identityHash) {
                        if (!identityHash && computeIdentityHashFunc) {
                            try {
                                identityHash = await computeIdentityHashFunc(decodedJwt);
                            } catch (hashError) {
                                logOutput('⚠️ Failed to compute identity hash fallback: ' + hashError.message, false);
                            }
                        }

                        if (identityHash && getSaltFromSessionStorageFunc) {
                            try {
                                passwordSalt = await getSaltFromSessionStorageFunc(identityHash);
                            } catch (saltError) {
                                logOutput('⚠️ Unable to load stored salt for identity: ' + saltError.message, false);
                            }
                        }
                    }

                    if ((!passwordSalt || !passwordSalt.length) || !identityHash) {
                        logOutput('❌ Missing password material for zkLogin after derivation.', true);
                        throw new Error('Missing password material for zkLogin');
                    }
                }

                // Convert salt to BigInt for SDK compatibility
                const BN254_FIELD_MODULUS = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617');
                const saltHex = Array.from(passwordSalt).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 62);
                const salt = BigInt('0x' + saltHex) % BN254_FIELD_MODULUS;

                const computedAddress = window.SuiSDK.ZkLogin.jwtToAddress(jwt, salt, false);
                const suiAddress = computedAddress;

                let addressSeed = window.SuiSDK.ZkLogin.genAddressSeed(salt, 'sub', decodedJwt.sub, decodedJwt.aud);
                let publicIdentifier = window.SuiSDK.ZkLogin.toZkLoginPublicIdentifier(addressSeed, decodedJwt.iss, { legacyAddress: false });

                const signatureMaxEpoch = pendingZkLoginContext.maxEpoch;
                const randomnessValue = typeof pendingZkLoginContext.randomness === 'bigint'
                    ? pendingZkLoginContext.randomness.toString()
                    : (pendingZkLoginContext.randomness !== undefined && pendingZkLoginContext.randomness !== null
                        ? String(pendingZkLoginContext.randomness)
                        : '');

                // First establish wallet connection without proof
                currentWallet = {
                    address: suiAddress,
                    type: 'zkLogin',
                    provider: mapIssuerToProvider(decodedJwt.iss),
                    zkLogin: {
                        jwt,
                        payload: decodedJwt,
                        salt: salt.toString(),
                        addressSeed: addressSeed.toString(),
                        publicIdentifier: publicIdentifier.toBase64(),
                        publicKey: pendingZkLoginContext.ephemeralKeyPair?.getPublicKey()?.toBase64() || null,
                        nonce: pendingZkLoginContext.nonce,
                        randomness: randomnessValue,
                        maxEpoch: signatureMaxEpoch,
                        ephemeralPublicKey: pendingZkLoginContext.extendedPublicKey,
                        connectedAt: Date.now(),
                        expiresAt: pendingZkLoginContext.expiresAt || null,
                        signatureInputs: null, // Will be set after proof generation
                        prover: null, // Will be set after proof generation
                        ephemeralKeypair: pendingZkLoginContext.ephemeralKeyPair || null,
                        identityHash,
                        hasEncryptedProof: false,
                        canSign: false // Will be set to true after successful proof generation
                    }
                };
                connectedWalletStandard = null;
                showCurrentWalletAddress(suiAddress);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `zkLogin (${currentWallet.provider})`;
                logOutput(`zkLogin wallet connected (${formatAddressShort(suiAddress)}).`);
                await getWalletBalance();

                // Now generate the zkLogin proof after wallet connection is established
                // First check if we have a valid cached proof for this specific JWT and epoch
                let signatureInputs = null;
                let proverDetails = null;
                let cachedProofPayload = null;
                let proofLoadedFromCache = false;
                const cachedSession = sessionStorage.getItem('galactic:zkLogin');
                if (cachedSession) {
                    try {
                        const sessionData = JSON.parse(cachedSession);
                        if (sessionData &&
                            sessionData.identityHash === identityHash &&
                            sessionData.address === suiAddress &&
                            sessionData.hasEncryptedProof &&
                            Number(sessionData.maxEpoch) >= signatureMaxEpoch) {
                            let decryptProofFunc;
                            if (typeof window.decryptProof === 'function') {
                                decryptProofFunc = window.decryptProof;
                            } else {
                                const { decryptProof } = await import('/src/zklogin-helpers.ts');
                                decryptProofFunc = decryptProof;
                            }

                            try {
                                cachedProofPayload = await decryptProofFunc(identityHash);
                            } catch (decryptError) {
                                logOutput('⚠️ Stored proof could not be unlocked. Generating a fresh proof.');
                            }

                            if (cachedProofPayload && cachedProofPayload.signatureInputs) {
                                signatureInputs = cachedProofPayload.signatureInputs;
                                proverDetails = cachedProofPayload.prover || {
                                    provider: cachedProofPayload.provider || 'local-simplified',
                                    receivedAt: cachedProofPayload.receivedAt || Date.now(),
                                    durationMs: cachedProofPayload.durationMs || 0
                                };
                                currentWallet.zkLogin.signatureInputs = signatureInputs;
                                currentWallet.zkLogin.prover = proverDetails;
                                currentWallet.zkLogin.hasEncryptedProof = true;
                                currentWallet.zkLogin.canSign = true;
                                proofLoadedFromCache = true;
                                logOutput(`Cached zkLogin proof loaded (valid through epoch ${signatureMaxEpoch || '(unknown)'}).`);
                            }
                        }
                    } catch (parseError) {
                        // Invalid cached data, continue with fresh generation
                    }
                }

                if (!signatureInputs) {
                    // Generate fresh proof
                    try {
                        // Validate epoch before attempting proof generation
                        if (!suiClient) await initializeSuiClient();
                        const epochInfo = await suiClient.getLatestSuiSystemState();
                        const currentEpoch = epochInfo?.epoch ? parseInt(epochInfo.epoch) : 0;
                        const maxEpoch = parseInt(pendingZkLoginContext.maxEpoch);

                        if (currentEpoch >= maxEpoch) {
                            logOutput(`❌ zkLogin proof expired: current epoch ${currentEpoch} >= maxEpoch ${maxEpoch}. Please reconnect.`);
                            throw new Error(`zkLogin proof expired: current epoch ${currentEpoch} >= maxEpoch ${maxEpoch}. Please reconnect to generate a fresh proof.`);
                        }

                        const startTime = Date.now();

                        // Use the bundled approach for proof generation
                        let deriveEphemeralKey;
                        if (typeof window.deriveEphemeralKey === 'function') {
                            deriveEphemeralKey = window.deriveEphemeralKey;
                        } else {
                            const imports = await import('/src/zklogin-helpers.ts');
                            deriveEphemeralKey = imports.deriveEphemeralKey;
                        }

                        let freshProofResult = null;
                        try {
                            const proofComputation = await deriveEphemeralKey(
                                decodedJwt.sub,      // userId
                                decodedJwt.iss,      // issuer
                                maxEpoch             // maxEpoch (already currentEpoch + 1)
                            );

                            const signatureInputsPayload = {
                                proofPoints: {
                                    a: proofComputation.proof.pi_a,
                                    b: proofComputation.proof.pi_b,
                                    c: proofComputation.proof.pi_c
                                },
                                issBase64Details: {
                                    value: btoa(decodedJwt.iss).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, ''),
                                    indexMod4: btoa(decodedJwt.iss).length % 4
                                },
                                headerBase64: jwt.split('.')[0],
                                addressSeed: addressSeed.toString()
                            };

                            const durationMs = Date.now() - startTime;
                            const randomnessString = typeof pendingZkLoginContext.randomness === 'bigint'
                                ? pendingZkLoginContext.randomness.toString()
                                : (pendingZkLoginContext.randomness !== undefined && pendingZkLoginContext.randomness !== null
                                    ? String(pendingZkLoginContext.randomness)
                                    : '');

                            freshProofResult = {
                                signatureInputs: signatureInputsPayload,
                                prover: {
                                    provider: 'local-simplified',
                                    receivedAt: Date.now(),
                                    durationMs
                                },
                                durationMs,
                                nonce: pendingZkLoginContext.nonce,
                                randomness: randomnessString,
                                ephemeralKey: proofComputation.ephemeralKey
                            };
                        } catch (proofError) {
                            logOutput('❌ Simplified proof generation failed: ' + proofError.message, true);
                            throw proofError;
                        }

                        const actualDuration = freshProofResult?.durationMs ?? 0;
                        if (!freshProofResult || !freshProofResult.signatureInputs) {
                            logOutput('⚠️ Proof generation returned no signature inputs');
                        }

                        signatureInputs = freshProofResult?.signatureInputs || null;
                        proverDetails = freshProofResult?.prover || null;

                        if (signatureInputs) {
                            try {
                                let encryptProofFunc;
                                if (typeof window.encryptProof === 'function') {
                                    encryptProofFunc = window.encryptProof;
                                } else {
                                    const { encryptProof } = await import('/src/zklogin-helpers.ts');
                                    encryptProofFunc = encryptProof;
                                }
                                await encryptProofFunc(freshProofResult, identityHash);
                                cachedProofPayload = freshProofResult;
                            } catch (sealError) {
                                logOutput('Warning: Failed to seal zkLogin proof: ' + sealError.message, false);
                            }
                        }

                        // Update wallet with proof data
                        currentWallet.zkLogin.signatureInputs = signatureInputs;
                        currentWallet.zkLogin.prover = proverDetails;
                        currentWallet.zkLogin.hasEncryptedProof = Boolean(signatureInputs);
                        currentWallet.zkLogin.canSign = Boolean(signatureInputs);

                        // Update the success message based on whether it was cached or real generation
                        if (!proofLoadedFromCache) {
                            logOutput(`Generated zkLogin proof in ${actualDuration} ms (valid through epoch ${signatureMaxEpoch || '(unknown)'}).`);
                        }
                    } catch (proverError) {
                        logOutput(`⚠️ Local proof generation failed: ${proverError.message}`);
                        logOutput('📍 Wallet will be read-only without proof generation capability.');
                        // Continue without proof for read-only functionality
                    }
                }

                // Store zkLogin proof in session storage
                try {
                    const zkLoginSessionData = {
                        identityHash,
                        address: currentWallet.address,
                        provider: currentWallet.provider,
                        maxEpoch: currentWallet.zkLogin.maxEpoch,
                        connectedAt: currentWallet.zkLogin.connectedAt,
                        expiresAt: currentWallet.zkLogin.expiresAt,
                        hasEncryptedProof: Boolean(currentWallet.zkLogin.canSign),
                        proofUpdatedAt: currentWallet.zkLogin.prover?.receivedAt || Date.now(),
                        prover: currentWallet.zkLogin.prover ? {
                            provider: currentWallet.zkLogin.prover.provider,
                            durationMs: currentWallet.zkLogin.prover.durationMs,
                            receivedAt: currentWallet.zkLogin.prover.receivedAt
                        } : null
                    };
                    sessionStorage.setItem('galactic:zkLogin', JSON.stringify(zkLoginSessionData));
                } catch (storageError) {
                    logOutput('Warning: Failed to store zkLogin proof in session storage: ' + storageError.message, false);
                }

                if (!currentWallet.zkLogin.canSign) {
                    logOutput('⚠️ Local zkLogin proof generation failed; wallet is read-only.');
                }

                try {
                    await findMyWallets();
                } catch (e) {
                }
            } catch (error) {
                logOutput('zkLogin connection failed: ' + error.message, true);
                throw error;
            } finally {
                pendingZkLoginContext = null;
            }
        }

        async function restoreZkLoginFromSession() {
            try {
                const stored = sessionStorage.getItem('galactic:zkLogin');
                if (!stored) {
                    return false;
                }

                const sessionData = JSON.parse(stored);
                if (!sessionData || !sessionData.address) {
                    sessionStorage.removeItem('galactic:zkLogin');
                    return false;
                }

                // Check if the session data is still valid (not expired)
                const now = Date.now();
                if (sessionData.expiresAt && now > sessionData.expiresAt) {
                    sessionStorage.removeItem('galactic:zkLogin');
                    logOutput('zkLogin session expired, please reconnect');
                    return false;
                }

                // Check epoch validity if maxEpoch is available
                if (sessionData.maxEpoch) {
                    try {
                        if (!suiClient) await initializeSuiClient();
                        const epochInfo = await suiClient.getLatestSuiSystemState();
                        const currentEpoch = epochInfo?.epoch ? parseInt(epochInfo.epoch) : 0;
                        const maxEpoch = parseInt(sessionData.maxEpoch);

                        if (currentEpoch >= maxEpoch) {
                            sessionStorage.removeItem('galactic:zkLogin');
                            logOutput('zkLogin proof expired (epoch exceeded), please reconnect');
                            return false;
                        }
                    } catch (epochError) {
                        logOutput('Warning: Could not verify epoch validity: ' + epochError.message, false);
                    }
                }

                // Restore wallet from session data
                currentWallet = {
                    address: sessionData.address,
                    type: 'zkLogin',
                    provider: sessionData.provider,
                    zkLogin: {
                        jwt: null,
                        payload: null,
                        salt: null,
                        addressSeed: null,
                        publicIdentifier: null,
                        publicKey: null,
                        nonce: null,
                        randomness: null,
                        maxEpoch: sessionData.maxEpoch,
                        ephemeralPublicKey: null,
                        connectedAt: sessionData.connectedAt || Date.now(),
                        expiresAt: sessionData.expiresAt || null,
                        signatureInputs: null,
                        prover: sessionData.prover || null,
                        ephemeralKeypair: null, // Keypair cannot be serialized, will need to regenerate if needed
                        identityHash: sessionData.identityHash || null,
                        canSign: false,
                        hasEncryptedProof: Boolean(sessionData.hasEncryptedProof)
                    }
                };
                connectedWalletStandard = null;

                showCurrentWalletAddress(sessionData.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `zkLogin (${currentWallet.provider})`;


                logOutput('🔐 zkLogin session restored from storage');
                logOutput(`🎉 Reconnected as ${sessionData.address}`);
                if (sessionData.hasEncryptedProof) {
                    logOutput(`🔒 zkProof (password-protected) available. Unlock for signing (valid til epoch ${sessionData.maxEpoch || '(unknown)'}).`);
                } else {
                    logOutput('⚠️ Session restored but signing capability unavailable');
                }

                await getWalletBalance();
                try {
                    await findMyWallets();
                } catch (e) {
                }

                return true;
            } catch (error) {
                logOutput('Failed to restore zkLogin session: ' + error.message, true);
                sessionStorage.removeItem('galactic:zkLogin');
                return false;
            }
        }

        function toggleZkLoginProviders(event, walletIndex) {
            event.stopPropagation();
            const dropdown = document.getElementById('zkloginDropdown' + walletIndex);
            if (!dropdown) return;

            // Close any other open dropdowns
            const allDropdowns = document.querySelectorAll('.zklogin-dropdown');
            allDropdowns.forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });

            // Toggle current dropdown
            dropdown.classList.toggle('visible');

            // Close dropdown when clicking outside
            const closeHandler = (e) => {
                if (!dropdown.contains(e.target) && !e.target.closest('.wallet-card')) {
                    dropdown.classList.remove('visible');
                    document.removeEventListener('click', closeHandler);
                }
            };

            if (dropdown.classList.contains('visible')) {
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            }
        }

        // Helper function to ensure SDK tier is loaded
        async function ensureSDKTier(tier, description) {
            if (!window.SuiSDK) {
                throw new Error('SuiSDK not available');
            }

            if (window.SuiSDK._loading && window.SuiSDK._loading[tier]) {
                logOutput(`⏳ Waiting for ${description} to finish loading...`);
            }

            const startTime = Date.now();
            let loaded = false;

            if (tier === 'core' && !window.SuiSDK.Sui.SuiClient) {
                await window.SuiSDK.loadCore();
                loaded = true;
            } else if (tier === 'transaction' && (
                !window.SuiSDK.Sui.Ed25519Keypair ||
                typeof window.SuiSDK.Sui.Ed25519Keypair.generate !== 'function'
            )) {
                await window.SuiSDK.loadTransaction();
                loaded = true;
            } else if (tier === 'advanced' && (
                typeof window.SuiSDK.ZkLogin?.generateNonce !== 'function' ||
                typeof window.SuiSDK.ZkLogin?.getExtendedEphemeralPublicKey !== 'function'
            )) {
                await window.SuiSDK.loadAdvanced();
                loaded = true;
            }

            if (loaded) {
                const duration = Date.now() - startTime;
                logOutput(`✅ ${description} loaded in ${duration}ms`);
            }
        }

        async function connectZkLoginProvider(provider) {
            try {
                // Ensure advanced SDK tier is loaded for zkLogin
                await ensureSDKTier('advanced', 'zkLogin support');

                // Ensure zkLogin helpers are loaded (should already be loaded in background)
                if (!window.__zkLoginHelpersLoaded__) {
                    const startTime = Date.now();
                    try {
                        await window.loadZkLoginHelpers();
                        const duration = Date.now() - startTime;
                        logOutput(`✅ zkLogin helpers loaded in ${duration}ms`);
                    } catch (error) {
                        logOutput('❌ Failed to load zkLogin helpers: ' + error.message);
                        return;
                    }
                }

                // Close all dropdowns
                document.querySelectorAll('.zklogin-dropdown').forEach(d => d.classList.remove('visible'));

                // Close wallet modal
                closeWalletModal();

                if (provider === 'google') {
                    await handleZkLoginConnect();
                } else {
                    // For now, show a message that other providers are coming soon
                    logOutput(`🚧 ${ZKLOGIN_PROVIDERS[provider]?.name || provider} zkLogin support coming soon. Using Google for now...`);
                    await handleZkLoginConnect();
                }
            } catch (error) {
                logOutput('zkLogin provider connection failed: ' + error.message, true);
            }
        }

        function buildPrimaryWalletEntries() {
            const entries = [
                {
                    type: 'custom',
                    action: 'zkLogin',
                    name: 'zkLogin',
                    icon: makeWalletIcon('ZK', '#6c4bcc')
                },
                {
                    type: 'custom',
                    action: 'passkey',
                    name: 'Passkey (Preview)',
                    icon: window.__SMARTWALLET_PASSKEY_ICON__ || makeWalletIcon('PK', '#1c858f')
                },
                {
                    type: 'custom',
                    action: 'browserWallet',
                    name: 'Browser Wallet',
                    icon: makeWalletIcon('BW', '#5a7cff')
                }
            ];

            return entries;
        }

        function getWalletIconForEntry(entry) {
            try {
                if (entry && typeof entry.icon === 'string') {
                    return entry.icon;
                }

                const wallet = entry && entry.wallet ? entry.wallet : null;
                const iconCandidates = [];
                if (wallet) {
                    if (typeof wallet.icon === 'string') iconCandidates.push(wallet.icon);
                    if (Array.isArray(wallet.icons)) {
                        for (const icon of wallet.icons) {
                            if (!icon) continue;
                            if (typeof icon === 'string') {
                                iconCandidates.push(icon);
                            } else if (typeof icon.url === 'string') {
                                iconCandidates.push(icon.url);
                            } else if (typeof icon.src === 'string') {
                                iconCandidates.push(icon.src);
                            } else if (typeof icon.data === 'string') {
                                iconCandidates.push(icon.data);
                            }
                        }
                    }
                }
                const dataIcon = iconCandidates.find(src => typeof src === 'string' && src.startsWith('data:image'));
                if (dataIcon) return dataIcon;
                const urlIcon = iconCandidates.find(src => typeof src === 'string');
                if (urlIcon) return urlIcon;

                return null;
            } catch (_) {
                return null;
            }
        }


        function updateWalletConnectionControls(isConnected) {
            try {
                const controls = document.getElementById('walletConnectionControls');
                const statusEl = document.getElementById('walletConnectionStatus');
                const infoPanel = document.getElementById('walletInfo');
                const actionBtn = document.getElementById('walletHeaderAction');
                if (statusEl) {
                    let statusText = isConnected ? 'Connected' : 'Not connected';
                    if (isConnected && currentWallet?.type === 'view_only') {
                        statusText = 'View-only connected';
                    }
                    statusEl.textContent = statusText;
                }
                if (actionBtn) {
                    if (isConnected) {
                        actionBtn.textContent = 'Disconnect';
                        actionBtn.classList.add('disconnect');
                        actionBtn.onclick = () => disconnectWallet();
                    } else {
                        actionBtn.textContent = 'Connect';
                        actionBtn.classList.remove('disconnect');
                        actionBtn.onclick = () => connectWalletStandard();
                    }
                }
                if (!controls) {
                    return;
                }
                controls.dataset.connected = isConnected ? 'true' : 'false';
                if (isConnected) {
                    if (!walletControlsCollapsed) {
                        controls.open = false;
                        walletControlsCollapsed = true;
                    }
                    controls.style.display = 'none';
                    if (infoPanel) infoPanel.style.display = 'block';
                } else {
                    controls.open = false;
                    walletControlsCollapsed = true;
                    controls.style.display = '';
                    if (infoPanel) infoPanel.style.display = 'none';
                }
            } catch (_) {}
        }

        async function resolveViewOnlyTarget(value) {
            const raw = (value || '').trim();
            if (!raw) {
                throw new Error('Enter a Sui address (0x...) or SuiNS name (example.sui).');
            }

            const { normalized } = normalizeAddressForDisplay(raw);
            if (normalized && HEX_ADDRESS_RE.test(normalized)) {
                return { address: normalized, source: 'address' };
            }

            const lower = raw.toLowerCase();
            if (!SUINS_NAME_RE.test(lower)) {
                throw new Error('Invalid input. Provide a valid Sui address (0x...) or a SuiNS name ending in .sui');
            }

            if (!suiClient) {
                await initializeSuiClient();
            }

            if (!suiClient || typeof suiClient.resolveNameServiceAddress !== 'function') {
                throw new Error('SuiNS resolution is not available in this SDK build.');
            }

            try {
                const result = await suiClient.resolveNameServiceAddress({ name: lower });
                let resolved = '';
                if (typeof result === 'string') {
                    resolved = result;
                } else if (result && typeof result === 'object') {
                    if (typeof result.address === 'string') resolved = result.address;
                    else if (typeof result.Address === 'string') resolved = result.Address;
                    else if (typeof result.value === 'string') resolved = result.value;
                    else if (result.data) {
                        if (typeof result.data === 'string') {
                            resolved = result.data;
                        } else if (typeof result.data === 'object' && typeof result.data.address === 'string') {
                            resolved = result.data.address;
                        }
                    }
                }

                const { normalized: resolvedAddress } = normalizeAddressForDisplay(resolved);
                if (!resolvedAddress || !HEX_ADDRESS_RE.test(resolvedAddress)) {
                    throw new Error(`No Sui address found for ${raw}`);
                }

                return { address: resolvedAddress, source: 'suins', name: lower };
            } catch (error) {
                throw new Error(`Failed to resolve ${raw}: ${error.message}`);
            }
        }

        async function copyText(value) {
            if (!value) return;
            if (navigator.clipboard?.writeText) {
                return navigator.clipboard.writeText(value);
            }
            const textarea = document.createElement('textarea');
            textarea.value = value;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try {
                document.execCommand('copy');
            } finally {
                document.body.removeChild(textarea);
            }
        }

        function setupCopyButtons() {
            const buttons = document.querySelectorAll('.copy-btn');
            buttons.forEach(button => {
                if (button.dataset.copySetup === 'done') return;
                button.dataset.copySetup = 'done';
                if (!button.dataset.copyLabel) {
                    button.dataset.copyLabel = button.textContent.trim() || 'Copy';
                }
                const targetId = button.dataset.copyTarget;
                const targetEl = targetId ? document.getElementById(targetId) : null;
                const allowAny = button.dataset.copyAllowAny === 'true';
                const getValue = () => {
                    if (button.dataset.copyValue !== undefined) {
                        return (button.dataset.copyValue || '').trim();
                    }
                    return targetEl ? targetEl.textContent.trim() : '';
                };
                if (!targetEl && button.dataset.copyValue === undefined) {
                    button.disabled = true;
                    return;
                }
                const updateState = () => {
                    const value = getValue();
                    button.disabled = allowAny ? !value : !HEX_ADDRESS_RE.test(value);
                };
                button.addEventListener('click', async () => {
                    const value = getValue();
                    if (!value) return;
                    if (!allowAny && !HEX_ADDRESS_RE.test(value)) return;
                    try {
                        await copyText(value);
                        button.dataset.copied = 'true';
                        button.textContent = 'Copied ✓';
                        setTimeout(() => {
                            button.textContent = button.dataset.copyLabel || 'Copy';
                            delete button.dataset.copied;
                        }, 1200);
                    } catch (error) {
                        console.warn('Copy failed', error);
                    }
                });
                if (targetEl) {
                    const observer = new MutationObserver(updateState);
                    observer.observe(targetEl, { subtree: true, childList: true, characterData: true });
                }
                updateState();
            });
        }

        if (typeof window !== 'undefined') {
            if (typeof window.requestIdleCallback === 'function') {
                window.requestIdleCallback(() => setupCopyButtons(), { timeout: 500 });
            } else {
                window.addEventListener('DOMContentLoaded', () => setTimeout(setupCopyButtons, 0));
            }
        }

        // Optimized SDK loading - check synchronously first, then wait only if needed
        // PERFORMANCE: This prevents blocking the UI thread during SDK initialization
        // - Fast path: Immediate return if SDK already loaded (production builds)
        // - Timeout: Prevents infinite waiting if SDK fails to load
        // - Caching: Reuses existing promise if already waiting
        function waitForSDKs() {
            // Fast path: SDK already available (production build)
            if (window.SuiSDK) {
                return Promise.resolve();
            }

            // Check if we're already waiting
            if (sdkReadyPromise) {
                return sdkReadyPromise;
            }

            // Create promise with timeout to avoid infinite waiting
            sdkReadyPromise = new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50; // Max 4 seconds (50 * 80ms)

                const poll = () => {
                    attempts++;

                    if (window.SuiSDK) {
                        resolve();
                        return;
                    }

                    if (attempts >= maxAttempts) {
                        reject(new Error('SDK failed to load within timeout'));
                        return;
                    }

                    setTimeout(poll, 80);
                };

                // Start polling
                poll();
            });

            return sdkReadyPromise;
        }

        function logOutput(message, isError = false) {
            const output = document.getElementById('output');
            const prefix = isError ? '[ERROR]' : '[INFO]';
            const line = isError ? `\n${prefix} ${message}` : `${prefix} ${message}`;
            output.textContent += `${line}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function normalizeAddressForDisplay(value) {
            if (!value && value !== 0) {
                return { normalized: '', display: '' };
            }
            const str = String(value).trim();
            if (!str) {
                return { normalized: '', display: '' };
            }
            if (HEX_STRING_RE.test(str)) {
                try {
                    const normalizer = window.SuiSDK?.Sui?.normalizeSuiAddress;
                    if (typeof normalizer === 'function') {
                        const normalized = normalizer(str.startsWith('0x') ? str : `0x${str}`);
                        return { normalized, display: normalized };
                    }
                } catch (_) {}
                const lower = str.startsWith('0x') ? str.toLowerCase() : `0x${str.toLowerCase()}`;
                return { normalized: lower, display: lower };
            }
            return { normalized: '', display: str };
        }

        function setCurrentWalletNameDisplay(name) {
            try {
                const container = document.getElementById('walletSuinsName');
                const valueEl = document.getElementById('walletSuinsValue');
                if (!container || !valueEl) return;
                if (name) {
                    valueEl.textContent = name;
                    container.style.display = 'inline-flex';
                } else {
                    valueEl.textContent = '';
                    container.style.display = 'none';
                }
            } catch (_) {}
        }

        async function resolveSuinsReverse(address, { silent = true } = {}) {
            const { normalized } = normalizeAddressForDisplay(address);
            if (!normalized) return null;
            const cacheKey = `${currentNetwork}:${normalized}`;
            if (suinsReverseCache.has(cacheKey)) {
                return suinsReverseCache.get(cacheKey);
            }

            try {
                if (!suiClient) {
                    await initializeSuiClient();
                }
                if (!suiClient?.resolveNameServiceNames) {
                    suinsReverseCache.set(cacheKey, null);
                    return null;
                }
                const response = await suiClient.resolveNameServiceNames({ address: normalized, limit: 5 });
                const names = Array.isArray(response?.data) ? response.data : [];
                const name = names.length ? names[0] : null;
                suinsReverseCache.set(cacheKey, name);
                return name;
            } catch (error) {
                suinsReverseCache.set(cacheKey, null);
                if (!silent) logOutput('Reverse SuiNS lookup failed: ' + error.message, true);
                return null;
            }
        }

        function showCurrentWalletAddress(address, { skipReverse = false } = {}) {
            const { normalized, display } = normalizeAddressForDisplay(address);
            const text = normalized || display;
            try {
                const addressEl = document.getElementById('currentAddress');
                if (addressEl) {
                    addressEl.textContent = text || '';
                }
                const copyBtn = document.querySelector('.copy-btn[data-copy-target="currentAddress"]');
                if (copyBtn) {
                    if (normalized) {
                        copyBtn.dataset.copyValue = normalized;
                        copyBtn.dataset.copyAllowAny = 'false';
                    } else {
                        copyBtn.dataset.copyValue = text || '';
                        copyBtn.dataset.copyAllowAny = 'true';
                    }
                    const value = copyBtn.dataset.copyValue || '';
                    const allowAny = copyBtn.dataset.copyAllowAny === 'true';
                    copyBtn.disabled = allowAny ? !value : !HEX_ADDRESS_RE.test(value);
                }
            } catch (_) {}

            if (!normalized) {
                currentReverseLookupToken += 1;
                setCurrentWalletNameDisplay(null);
                return;
            }

            if (skipReverse) return;

            const lookupToken = ++currentReverseLookupToken;
            setCurrentWalletNameDisplay(null);
            resolveSuinsReverse(normalized, { silent: true }).then(name => {
                if (lookupToken !== currentReverseLookupToken) return;
                setCurrentWalletNameDisplay(name);
            }).catch(() => {
                if (lookupToken !== currentReverseLookupToken) return;
                setCurrentWalletNameDisplay(null);
            });
        }

        // Initialize Sui client - optimized for performance
        async function initializeSuiClient() {
            if (suiClient) return suiClient;

            // Ensure core SDK tier is loaded for network connection
            await ensureSDKTier('core', 'network connection');

            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl } = window.SuiSDK.Sui;
            suiClient = new SuiClient({ url: getFullnodeUrl(currentNetwork) });
            logOutput(`Connected to Sui ${currentNetwork} network`);
            return suiClient;
        }

        async function ensureSdkReady() {
            await waitForSDKs();
            return initializeSuiClient();
        }

        function scheduleBootstrapWork() {
            if (bootstrapPromise) {
                return bootstrapPromise;
            }

            const runBootstrap = async () => {
                try {
                    await ensureSdkReady();
                    // Preload advanced tier for zkLogin after basic connection is ready
                    ensureSDKTier('advanced', 'zkLogin support').catch(err =>
                        console.warn('Advanced tier preload failed:', err.message)
                    );
                } catch (error) {
                    logOutput('Failed to initialize SDK: ' + error.message, true);
                    return;
                }


                try {
                    await restoreZkLoginFromSession();
                } catch (error) {
                    logOutput('Failed to restore zkLogin session: ' + error.message, false);
                }
            };

            if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {
                bootstrapPromise = new Promise((resolve) => {
                    window.requestIdleCallback(() => {
                        runBootstrap().finally(resolve);
                    }, { timeout: 1200 });
                });
            } else {
                bootstrapPromise = new Promise((resolve) => {
                    setTimeout(() => {
                        runBootstrap().finally(resolve);
                    }, 120);
                });
            }

            return bootstrapPromise;
        }


        async function createOrImportWallet({ name, rawPrivateKey, password, confirmPassword }) {
            const trimmedName = (name || '').trim();
            if (!trimmedName) {
                throw new Error('Please enter a wallet name');
            }

            if (!password || password.length < 8) {
                throw new Error('Password must be at least 8 characters long');
            }

            if (password !== confirmPassword) {
                throw new Error('Passwords do not match');
            }

            const existingWallets = getStoredWallets();
            if (existingWallets.some(w => w.name === trimmedName)) {
                throw new Error('A wallet with this name already exists');
            }

            await ensureSdkReady();

            const normalizedPrivateKey = (rawPrivateKey || '').trim().replace(/\s+/g, '');
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            let keypair;
            let secretForStorage;
            let actionLabel;

            if (normalizedPrivateKey) {
                logOutput('Importing wallet...');
                try {
                    keypair = Ed25519Keypair.fromSecretKey(normalizedPrivateKey);
                } catch (error) {
                    throw new Error('Invalid private key format. Please verify and try again.');
                }
                secretForStorage = normalizedPrivateKey;
                actionLabel = 'imported';
            } else {
                logOutput('Creating new wallet...');
                keypair = Ed25519Keypair.generate();
                secretForStorage = keypair.getSecretKey();
                actionLabel = 'created';
            }

            const address = keypair.toSuiAddress();
            const encryptedPrivateKey = await encryptPrivateKey(secretForStorage, password);

            saveWallet(trimmedName, encryptedPrivateKey, address);

            currentWallet = { address, keypair, type: 'traditional', name: trimmedName };
            showCurrentWalletAddress(address);
            document.getElementById('walletInfo').style.display = 'block';
            updateWalletConnectionControls(true);

            logOutput(`Wallet "${trimmedName}" ${actionLabel} successfully!`);
            logOutput(`Address: ${address}`);
            await getWalletBalance();

            return { actionLabel, address };
        }

        async function handleCreateWalletForm(walletIndex) {
            const nameInput = document.getElementById('createWalletName');
            const privateKeyInput = document.getElementById('createWalletPrivateKey');
            const passwordInput = document.getElementById('createWalletPassword');
            const confirmInput = document.getElementById('createWalletConfirmPassword');

            if (!nameInput || !passwordInput || !confirmInput) {
                alert('Form inputs not found');
                return;
            }

            try {
                await createOrImportWallet({
                    name: nameInput.value,
                    rawPrivateKey: privateKeyInput ? privateKeyInput.value : '',
                    password: passwordInput.value,
                    confirmPassword: confirmInput.value
                });

                // Close the dropdown
                const dropdown = document.getElementById('traditionalDropdown' + walletIndex);
                if (dropdown) {
                    dropdown.classList.remove('visible');
                }

                // Close the wallet modal
                closeWalletModal();
            } catch (error) {
                logOutput('Error creating or importing wallet: ' + error.message, true);
                alert('Error creating or importing wallet: ' + error.message);
            }
        }

        async function getWalletBalance() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            try {
                if (!suiClient) {
                    await initializeSuiClient();
                }
                const balance = await suiClient.getBalance({ owner: currentWallet.address });
                const suiBalance = Number(balance.totalBalance) / 1_000_000_000;
                document.getElementById('currentBalance').textContent = `${suiBalance} SUI`;
            } catch (error) {
                logOutput('Error getting balance: ' + error.message, true);
            }
        }

        // Wait for wallet extensions to load
        function waitForWalletExtensions(timeout = 3000) {
            return new Promise((resolve) => {
                const startTime = Date.now();
                const checkWallets = () => {
                    const walletFound = window.sui || window.suiWallet || window.ethos || window.slush || 
                                      (window.suiWallet && window.suiWallet.getWallets) ||
                                      Object.keys(window).some(key => key.toLowerCase().includes('sui'));
                    
                    if (walletFound || Date.now() - startTime > timeout) {
                        resolve(walletFound);
                    } else {
                        setTimeout(checkWallets, 100);
                    }
                };
                checkWallets();
            });
        }

        // Proper Sui Wallet Standard Connection using @mysten/wallet-standard
        async function connectWalletStandard() {
            try {
                await ensureSdkReady();
                
                // Wait for extensions to load
                await waitForWalletExtensions();
                
                // Method 1: Use @mysten/wallet-standard from SuiSDK bundle
                if (typeof window !== 'undefined' && window.SuiSDK) {
                    // Check for @mysten/wallet-standard in the SuiSDK bundle
                    if (window.SuiSDK.WalletStandard) {
                        try {
                            // Use proper Mysten wallet standard
                            const { getWallets } = window.SuiSDK.WalletStandard;
                            const walletsApi = getWallets();
                            const allWallets = walletsApi.get();
                            
                            // Filter for Sui-compatible wallets only
                            const suiWallets = allWallets.filter(wallet => {
                                // Check for Sui chains first (most reliable)
                                const supportsSui = wallet.chains && wallet.chains.some(chain =>
                                    chain.includes('sui:') || chain === 'sui'
                                );

                                // Check for Sui-specific features
                                const hasSuiConnect = wallet.features && (
                                    wallet.features['sui:connect'] ||
                                    wallet.features['sui:signAndExecuteTransaction']
                                );

                                // Only include if it explicitly supports Sui chains OR has Sui-specific features
                                // Exclude wallets that only have generic 'standard:connect' without Sui chain support
                                return supportsSui || hasSuiConnect;
                            });
                            
                                        openWalletModal(suiWallets);
                            return; // Stop here; user will choose a wallet
                        } catch (sdkError) {
                            logOutput('Mysten Wallet Standard detection failed: ' + sdkError.message, true);
                        }
                    }
                    
                    // Method 2: Direct window.sui detection (proper approach)
                    if (window.sui) {
                        logOutput('Found window.sui, attempting proper connection...');
                        try {
                            // Use the standard connection flow
                            const hasConnectFeature = window.sui.features && window.sui.features['standard:connect'];
                            const hasLegacyConnect = typeof window.sui.connect === 'function';
                            
                            if (hasConnectFeature) {
                                logOutput('Using standard:connect feature...');
                                await window.sui.features['standard:connect'].connect();
                            } else if (hasLegacyConnect) {
                                logOutput('Using legacy connect method...');
                                await window.sui.connect();
                            } else if (window.sui.requestPermissions) {
                                logOutput('Using requestPermissions method...');
                                await window.sui.requestPermissions();
                            }
                            
                            // Get accounts
                            let accounts = [];
                            if (window.sui.accounts) {
                                accounts = window.sui.accounts;
                            } else if (window.sui.getAccounts) {
                                accounts = await window.sui.getAccounts();
                            } else if (window.sui.features && window.sui.features['standard:connect'] && window.sui.features['standard:connect'].accounts) {
                                accounts = window.sui.features['standard:connect'].accounts;
                            }
                            
                            if (accounts && accounts.length > 0) {
                                const account = accounts[0];
                                currentWallet = { 
                                    address: account.address, 
                                    type: 'wallet_standard',
                                    wallet: window.sui
                                };
                                connectedWalletStandard = window.sui;
                                
                                showCurrentWalletAddress(account.address);
                                document.getElementById('walletInfo').style.display = 'block';
                                updateWalletConnectionControls(true);
                                document.getElementById('walletType').textContent = 'Sui Wallet Standard';
                                
                                logOutput('✅ Successfully connected via window.sui!');
                                logOutput(`Address: ${account.address}`);
                                await getWalletBalance();
                                return;
                            }
                        } catch (suiError) {
                            logOutput('window.sui connection failed: ' + suiError.message, true);
                        }
                    }
                    
                    // Method 3: Check for wallet-specific globals
                    const knownWallets = ['suiWallet', 'ethos', 'slush', 'martian'];
                    for (const walletName of knownWallets) {
                        if (window[walletName]) {
                            logOutput(`Found ${walletName}, attempting connection...`);
                            try {
                                const wallet = window[walletName];
                                
                                // Try standard connect
                                if (wallet.features && wallet.features['standard:connect']) {
                                    await wallet.features['standard:connect'].connect();
                                    const accounts = wallet.features['standard:connect'].accounts;
                                    if (accounts && accounts.length > 0) {
                                        await handleSuccessfulConnection(accounts[0], wallet, walletName);
                                        return;
                                    }
                                }
                                
                                // Try legacy methods
                                if (wallet.connect) {
                                    await wallet.connect();
                                } else if (wallet.requestPermissions) {
                                    await wallet.requestPermissions();
                                }
                                
                                // Get accounts
                                let accounts = [];
                                if (wallet.getAccounts) {
                                    accounts = await wallet.getAccounts();
                                } else if (wallet.accounts) {
                                    accounts = wallet.accounts;
                                }
                                
                                if (accounts && accounts.length > 0) {
                                    await handleSuccessfulConnection(accounts[0], wallet, walletName);
                                    return;
                                }
                            } catch (walletError) {
                                logOutput(`${walletName} connection failed: ${walletError.message}`, true);
                            }
                        }
                    }
                }
                
                logOutput('❌ No compatible Sui wallets found', true);
                logOutput('Please ensure you have a Sui wallet extension installed (Slush, Sui Wallet, Ethos, etc.)', true);
                logOutput('After installing, please refresh the page and try again.', true);

            } catch (error) {
                logOutput('Wallet connection error: ' + error.message, true);
            }
        }
        
        // Helper function for successful wallet connection
        async function handleSuccessfulConnection(account, wallet, walletName) {
            currentWallet = {
                address: account.address,
                type: 'wallet_standard',
                wallet: wallet
            };
            connectedWalletStandard = wallet;

            showCurrentWalletAddress(account.address);
            document.getElementById('walletInfo').style.display = 'block';
            updateWalletConnectionControls(true);
            document.getElementById('walletType').textContent = walletName + ' Wallet';

            logOutput(`✅ Connected to ${walletName}!`);
            logOutput(`Address: ${account.address}`);
            await getWalletBalance();

        }

        // Open modal with wallet selection (suiWallets are already filtered for Sui compatibility)
        function openWalletModal(suiWallets) {
            const overlay = document.getElementById('walletModal');
            const list = document.getElementById('walletModalList');
            if (!overlay || !list) return;
            
            // Start with the pre-filtered Sui wallets from @mysten/wallet-standard
            var entries = buildPrimaryWalletEntries();
            
            // Add wallet standard entries (already filtered for Sui compatibility)
            for (var i = 0; i < (suiWallets || []).length; i++) {
                var wallet = suiWallets[i];
                entries.push({ 
                    type: 'standard', 
                    wallet: wallet,
                    name: wallet.name || `${wallet.id || 'Wallet'} ${i + 1}`
                });
            }
            
            // Add fallback entries for directly injected providers (if not already in standard list)
            var fallbacks = [];
            if (window.sui) {
                // Check if this isn't already in the standard list
                var alreadyHasSui = entries.some(e => e.name && e.name.toLowerCase().includes('sui'));
                if (!alreadyHasSui) {
                    fallbacks.push({ 
                        type: 'windowSui', 
                        name: 'Sui Wallet (window.sui)'
                    });
                }
            }
            if (window.phantom && window.phantom.sui) {
                var alreadyHasPhantom = entries.some(e => e.name && e.name.toLowerCase().includes('phantom'));
                if (!alreadyHasPhantom) {
                    fallbacks.push({ 
                        type: 'phantomSui', 
                        name: 'Phantom (Sui)'
                    });
                }
            }
            
            // Add fallbacks to entries
            for (var fi = 0; fi < fallbacks.length; fi++) {
                entries.push(fallbacks[fi]);
            }

            window.availableSuiWallets = entries;

            var html = '';
            if (!entries.length) {
                html = '<p style="font-size: 13px; color: #a0b3c5;">No Sui wallets detected. Please install Slush, Sui Wallet, Ethos, or Phantom, then refresh this page.</p>';
            } else {
                for (var i = 0; i < entries.length; i++) {
                    var e = entries[i];
                    var name = e.name || (e.wallet && (e.wallet.name || e.wallet.id)) || `Wallet ${i + 1}`;
                    var iconSrc = getWalletIconForEntry(e);

                    var safeName = escapeHtml(name);
                    var safeIcon = escapeHtml(iconSrc);


                    // Special handling for zkLogin to show provider selection
                    if (e.type === 'custom' && e.action === 'zkLogin') {
                        html += '\n<div class="zklogin-providers">\n' +
                                '  <button type="button" class="wallet-card" onclick="toggleZkLoginProviders(event, ' + i + ')">\n' +
                                '    <div class="wallet-card-icon-wrap"><img src="' + safeIcon + '" alt="' + safeName + ' icon" class="wallet-card-icon" loading="lazy"></div>\n' +
                                '    <div class="wallet-card-content">\n' +
                                '      <div class="wallet-card-name">' + safeName + '</div>\n' +
                                '    </div>\n' +
                                '  </button>\n' +
                                '  <div class="zklogin-dropdown" id="zkloginDropdown' + i + '">\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'google\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.google.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Google</span>\n' +
                                '    </button>\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'facebook\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.facebook.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Meta</span>\n' +
                                '    </button>\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'apple\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.apple.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Apple</span>\n' +
                                '    </button>\n' +
                                '  </div>\n' +
                                '</div>';
                    } else if (e.type === 'custom' && e.action === 'browserWallet') {
                        // Special handling for browser wallet to show create/unlock options
                        html += '\n<div class="traditional-providers">\n' +
                                '  <button type="button" class="wallet-card" onclick="toggleTraditionalWalletOptions(event, ' + i + ')">\n' +
                                '    <div class="wallet-card-icon-wrap"><img src="' + safeIcon + '" alt="' + safeName + ' icon" class="wallet-card-icon" loading="lazy"></div>\n' +
                                '    <div class="wallet-card-content">\n' +
                                '      <div class="wallet-card-name">' + safeName + '</div>\n' +
                                '    </div>\n' +
                                '  </button>\n' +
                                '  <div class="traditional-dropdown" id="traditionalDropdown' + i + '"></div>\n' +
                                '</div>';
                    } else {
                        // Add passkey-icon class for passkey entries to handle scaling
                        var iconClass = (e.type === 'custom' && e.action === 'passkey') ? 'wallet-card-icon passkey-icon' : 'wallet-card-icon';
                        html += '\n<button type="button" class="wallet-card" onclick="connectWalletByIndex(' + i + ')">\n' +
                                '  <div class="wallet-card-icon-wrap"><img src="' + safeIcon + '" alt="' + safeName + ' icon" class="' + iconClass + '" loading="lazy"></div>\n' +
                                '  <div class="wallet-card-content">\n' +
                                '    <div class="wallet-card-name">' + safeName + '</div>\n' +
                                '  </div>\n' +
                                '</button>';
                    }
                }
            }
            list.innerHTML = html;
            overlay.classList.add('visible');
            document.body.style.overflow = 'hidden';
            var closeBtn = document.getElementById('walletModalClose');
            if (closeBtn) try { closeBtn.focus(); } catch(e) {}
        }

        function closeWalletModal() {
            var overlay = document.getElementById('walletModal');
            if (!overlay) return;
            overlay.classList.remove('visible');
            document.body.style.overflow = '';
        }

        function toggleTraditionalWalletOptions(event, walletIndex) {
            event.stopPropagation();

            const dropdown = document.getElementById('traditionalDropdown' + walletIndex);

            if (!dropdown) {
                console.error('Dropdown element not found for walletIndex:', walletIndex);
                return;
            }

            // Close any other open dropdowns
            const allDropdowns = document.querySelectorAll('.traditional-dropdown');

            allDropdowns.forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });

            // Show the dropdown content based on whether wallets exist
            showTraditionalWalletOptions(dropdown, walletIndex);
        }

        function showTraditionalWalletOptions(dropdown, walletIndex) {
            // Always get fresh wallet list when showing options
            const storedWallets = getStoredWallets();

            // Always show the same dropdown structure
            showExistingWallets(dropdown, storedWallets, walletIndex);

            // Make sure the dropdown is visible
            dropdown.classList.add('visible');
        }

        function showExistingWallets(dropdown, storedWallets, walletIndex) {
            // Generate wallet list (empty if no wallets)
            const walletOptions = storedWallets.map(wallet => `
                <div class="wallet-item" style="display: flex; align-items: center; gap: 8px; padding: 2px 12px; margin: 0; border: none; background: transparent; color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; transition: background .2s ease;">
                    <button type="button" class="wallet-unlock-btn" onclick="unlockSpecificWallet('${wallet.name}'); closeAllTraditionalDropdowns();" style="display: flex; align-items: center; gap: 8px; border: none; background: transparent; color: #cfe4f7; cursor: pointer; flex: 1; text-align: left; max-width: calc(100%);">
                        <div class="traditional-provider-icon" style="background: #2e7d32; width: 20px; height: 20px; font-size: 9px; flex-shrink: 0;">UW</div>
                        <span class="traditional-provider-name" style="font-size: 18px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${wallet.name}</span>
                    </button>
                    <button type="button" class="wallet-delete-btn" onclick="deleteWalletAndRefresh('${wallet.name}', ${walletIndex})" style="border: none; background: transparent; color: #ff4444; cursor: pointer; padding: 4px; flex-shrink: 0; margin-left: 8px; margin-right: 24px;">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                        </svg>
                    </button>
                </div>
            `).join('');

            dropdown.innerHTML = `
                ${storedWallets.length > 0 ? `
                    <div class="existing-wallets-header" style="padding: 4px 12px; font-size: 16px; color: #cfe4f7; font-weight: 600; border-bottom: 1px solid rgba(69,139,189,.3); margin-bottom: 2px;">
                        Select wallet to unlock:
                    </div>
                    <div class="wallet-list" style="max-height: 120px; overflow-y: auto; width: 100%;">
                        ${walletOptions}
                    </div>
                    <div style="padding: 4px 10px; border-top: 1px solid rgba(69,139,189,.3); margin-top: 2px;">
                ` : `
                    <div style="padding: 8px 12px;">
                `}
                    <div class="create-wallet-container">
                        <button type="button" class="traditional-provider" onclick="toggleCreateWalletDropdown(${walletIndex});" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.08); color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; font-size: 13px;">
                            <div class="traditional-provider-icon" style="background: #5a7cff; width: 20px; height: 20px; font-size: 9px; flex-shrink: 0;">CI</div>
                            <span class="traditional-provider-name" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">Create or Import Wallet</span>
                        </button>
                        <div class="create-wallet-dropdown" id="createWalletDropdown${walletIndex}">
                            <div class="traditional-provider-form" style="padding: 8px 12px;">
                                <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                                    <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Wallet Name:</label>
                                    <input type="text" id="createWalletName${walletIndex}" placeholder="Enter wallet name" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                                </div>
                                <div class="form-row" style="display: flex; flex-direction: column; align-items: stretch; margin-bottom: 8px; gap: 6px;">
                                    <label style="font-size: 10px; color: #cfe4f7; font-weight: 600;">Private Key (optional):</label>
                                    <textarea id="createWalletPrivateKey${walletIndex}" placeholder="Leave blank to generate a new key" style="font-size: 10px; padding: 6px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7; min-height: 60px; resize: vertical;"></textarea>
                                    <span style="font-size: 9px; color: rgba(207,228,247,0.7);">Paste a Base64 private key to import an existing wallet.</span>
                                </div>
                                <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                                    <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Password:</label>
                                    <input type="password" id="createWalletPassword${walletIndex}" placeholder="Min 8 characters" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                                </div>
                                <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                                    <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Confirm:</label>
                                    <input type="password" id="createWalletConfirmPassword${walletIndex}" placeholder="Confirm password" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                                </div>
                                <div class="form-actions" style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px;">
                                    <button type="button" onclick="closeCreateWalletDropdown(${walletIndex});" style="font-size: 10px; padding: 4px 8px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: transparent; color: #cfe4f7; cursor: pointer;">Cancel</button>
                                    <button type="button" onclick="handleCreateWalletFromDropdown(${walletIndex})" class="create-btn" style="font-size: 10px; padding: 4px 8px; border: none; border-radius: 4px; background: #5a7cff; color: white; cursor: pointer; font-weight: 600;">Continue</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            dropdown.classList.add('visible');
        }

        function showCreateWalletForm(dropdown, walletIndex) {
            if (!dropdown) {
                console.error('No dropdown element provided to showCreateWalletForm');
                return;
            }

            // Clear dropdown completely first and force a reflow
            dropdown.innerHTML = '';
            dropdown.className = 'traditional-dropdown visible';

            // Force DOM reflow before setting new content
            dropdown.offsetHeight;

            dropdown.innerHTML = `
                <div class="traditional-provider-form" id="createWalletForm" style="padding: 8px 12px; max-height: none;">
                    <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                        <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Wallet Name:</label>
                        <input type="text" id="createWalletName" placeholder="Enter wallet name" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                    </div>
                    <div class="form-row" style="display: flex; flex-direction: column; align-items: stretch; margin-bottom: 8px; gap: 6px;">
                        <label style="font-size: 10px; color: #cfe4f7; font-weight: 600;">Private Key (optional):</label>
                        <textarea id="createWalletPrivateKey" placeholder="Leave blank to generate a new key" style="font-size: 10px; padding: 6px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7; min-height: 60px; resize: vertical;"></textarea>
                        <span style="font-size: 9px; color: rgba(207,228,247,0.7);">Paste a Base64 private key to import an existing wallet.</span>
                    </div>
                    <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                        <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Password:</label>
                        <input type="password" id="createWalletPassword" placeholder="Min 8 characters" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                    </div>
                    <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                        <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Confirm:</label>
                        <input type="password" id="createWalletConfirmPassword" placeholder="Confirm password" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                    </div>
                    <div class="form-actions" style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px;">
                        <button type="button" onclick="showExistingWallets(this.closest('.traditional-dropdown'), getStoredWallets(), ${walletIndex});" style="font-size: 10px; padding: 4px 8px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: transparent; color: #cfe4f7; cursor: pointer;">Back</button>
                        <button type="button" onclick="handleCreateWalletForm(${walletIndex})" class="create-btn" style="font-size: 10px; padding: 4px 8px; border: none; border-radius: 4px; background: #5a7cff; color: white; cursor: pointer; font-weight: 600;">Continue</button>
                    </div>
                </div>
            `;

        }

        function closeAllTraditionalDropdowns() {
            document.querySelectorAll('.traditional-dropdown').forEach(d => d.classList.remove('visible'));
            document.querySelectorAll('.create-wallet-dropdown').forEach(d => d.classList.remove('visible'));
        }

        function toggleCreateWalletDropdown(walletIndex) {
            const dropdown = document.getElementById('createWalletDropdown' + walletIndex);
            if (!dropdown) return;

            // Close other create wallet dropdowns
            document.querySelectorAll('.create-wallet-dropdown').forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });

            // Toggle current dropdown
            dropdown.classList.toggle('visible');

            // If opening, focus the first input
            if (dropdown.classList.contains('visible')) {
                setTimeout(() => {
                    const nameInput = document.getElementById('createWalletName' + walletIndex);
                    if (nameInput) nameInput.focus();
                }, 100);
            }

            // Close dropdown when clicking outside
            const closeHandler = (e) => {
                if (!dropdown.contains(e.target) && !e.target.closest('.create-wallet-container')) {
                    dropdown.classList.remove('visible');
                    document.removeEventListener('click', closeHandler);
                }
            };

            if (dropdown.classList.contains('visible')) {
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            }
        }

        function closeCreateWalletDropdown(walletIndex) {
            const dropdown = document.getElementById('createWalletDropdown' + walletIndex);
            if (dropdown) {
                dropdown.classList.remove('visible');
            }
        }

        async function handleCreateWalletFromDropdown(walletIndex) {
            const nameInput = document.getElementById('createWalletName' + walletIndex);
            const privateKeyInput = document.getElementById('createWalletPrivateKey' + walletIndex);
            const passwordInput = document.getElementById('createWalletPassword' + walletIndex);
            const confirmInput = document.getElementById('createWalletConfirmPassword' + walletIndex);

            if (!nameInput || !passwordInput || !confirmInput) {
                alert('Form inputs not found');
                return;
            }

            try {
                await createOrImportWallet({
                    name: nameInput.value,
                    rawPrivateKey: privateKeyInput ? privateKeyInput.value : '',
                    password: passwordInput.value,
                    confirmPassword: confirmInput.value
                });

                closeCreateWalletDropdown(walletIndex);
                closeWalletModal();
            } catch (error) {
                logOutput('Error creating or importing wallet: ' + error.message, true);
                alert('Error creating or importing wallet: ' + error.message);
            }
        }

        async function unlockSpecificWallet(walletName) {
            try {
                const storedWallets = getStoredWallets();
                const wallet = storedWallets.find(w => w.name === walletName);
                if (!wallet) {
                    alert('Wallet not found');
                    return;
                }

                const password = prompt(`Enter password for "${walletName}":`);
                if (!password) {
                    logOutput('Wallet unlock cancelled');
                    return;
                }

                // Decrypt private key
                const privateKey = await decryptPrivateKey(wallet.encryptedPrivateKey, password);

                // Recreate keypair
                const { Ed25519Keypair } = window.SuiSDK.Sui;
                const keypair = Ed25519Keypair.fromSecretKey(privateKey);

                // Set as current wallet
                currentWallet = { address: wallet.address, keypair, type: 'traditional', name: wallet.name };
                showCurrentWalletAddress(wallet.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);

                logOutput(`Wallet "${wallet.name}" unlocked successfully!`);
                logOutput(`Address: ${wallet.address}`);
                await getWalletBalance();

                // Close the wallet modal
                closeWalletModal();
            } catch (error) {
                logOutput('Error unlocking wallet: ' + error.message, true);
                alert('Error unlocking wallet: ' + error.message);
            }
        }

        window.toggleZkLoginProviders = toggleZkLoginProviders;
        window.connectZkLoginProvider = connectZkLoginProvider;

        window.toggleTraditionalWalletOptions = toggleTraditionalWalletOptions;
        window.closeAllTraditionalDropdowns = closeAllTraditionalDropdowns;
        window.handleCreateWalletForm = handleCreateWalletForm;
        window.showTraditionalWalletOptions = showTraditionalWalletOptions;
        window.showExistingWallets = showExistingWallets;
        window.showCreateWalletForm = showCreateWalletForm;
        window.unlockSpecificWallet = unlockSpecificWallet;
        window.deleteWalletAndRefresh = deleteWalletAndRefresh;
        window.toggleCreateWalletDropdown = toggleCreateWalletDropdown;
        window.closeCreateWalletDropdown = closeCreateWalletDropdown;
        window.handleCreateWalletFromDropdown = handleCreateWalletFromDropdown;

        window.connectWalletByIndex = async function(i) {
            try {
                const entry = (window.availableSuiWallets && window.availableSuiWallets.length) ? window.availableSuiWallets[i] : null;
                if (!entry) throw new Error('Invalid wallet index');
                closeWalletModal();
                if (entry.type === 'standard' && entry.wallet) {
                    await connectToWallet(entry.wallet);
                } else if (entry.type === 'windowSui') {
                    await connectViaWindowSui();
                } else if (entry.type === 'phantomSui') {
                    await connectViaPhantomSui();
                } else if (entry.type === 'custom') {
                    if (entry.action === 'zkLogin') {
                        // zkLogin now uses provider selection dropdown instead of direct connection
                        throw new Error('zkLogin should use provider selection - this path should not be reached');
                    } else if (entry.action === 'passkey') {
                        await handlePasskeyStub();
                    } else if (entry.action === 'traditionalWallet') {
                        // Traditional wallet uses dropdown, no action needed here
                        throw new Error('Traditional wallet should use dropdown - this path should not be reached');
                    } else {
                        throw new Error('Unsupported custom wallet entry');
                    }
                } else {
                    throw new Error('Unsupported wallet entry');
                }
            } catch (e) {
                logOutput('Wallet selection error: ' + e.message, true);
            }
        };

        async function handlePasskeyStub() {
            logOutput('🧪 Passkey flow coming soon. This option will use Mysten passkey helpers in the inline Sui SDK.');
        }

        // Network sync utilities
        function getWalletNetwork(wallet) {
            if (!wallet || !wallet.chains) return null;

            // Debug: Show what chains the wallet supports
            logOutput(`🔍 Wallet chains: ${JSON.stringify(wallet.chains)}`);

            // Check for Sui networks - prioritize TESTNET first since user expects testnet
            const suiNetworks = ['sui:testnet', 'sui:mainnet', 'sui:devnet'];
            for (const network of suiNetworks) {
                if (wallet.chains.includes(network)) {
                    logOutput(`🎯 Detected network: ${network} (prioritizing testnet)`);
                    return network.replace('sui:', '');
                }
            }

            // Fallback: check for generic 'sui' chain
            if (wallet.chains.includes('sui')) {
                logOutput(`⚠️ Generic 'sui' chain detected, assuming testnet`);
                return 'testnet'; // Assume testnet if generic sui chain
            }

            logOutput(`❌ No Sui network detected in wallet chains`);
            return null;
        }

        function checkWalletNetworkMismatch(wallet) {
            const walletNetwork = getWalletNetwork(wallet);
            if (!walletNetwork) {
                logOutput(`⚠️ Could not detect wallet network from chains: ${JSON.stringify(wallet.chains)}`);
                return false;
            }

            if (walletNetwork !== currentNetwork) {
                logOutput(`⚠️ Network mismatch detected!`);
                logOutput(`💡 App is on ${currentNetwork}, but wallet ${wallet.name || 'Unknown'} supports ${walletNetwork}`);
                logOutput(`📝 You can manually change networks using the dropdown above if needed`);
                return true; // There's a mismatch
            } else {
                logOutput(`✅ Networks match: Both app and wallet on ${walletNetwork}`);
                return false; // No mismatch
            }
        }

        async function connectToWallet(wallet) {
            try {
                logOutput(`Connecting to ${wallet.name || 'wallet'}...`);
                
                let connectFeature = null;
                let accountsFeature = null;
                
                // Find the correct connection feature
                if (wallet.features) {
                    // Priority order for connection features
                    if (wallet.features['standard:connect']) {
                        connectFeature = wallet.features['standard:connect'];
                        accountsFeature = wallet.features['standard:connect'];
                    } else if (wallet.features['sui:connect']) {
                        connectFeature = wallet.features['sui:connect'];
                        accountsFeature = wallet.features['sui:connect'];
                    } else if (wallet.features['sui:signAndExecuteTransaction']) {
                        // Some wallets only have signing features, try to get accounts directly
                        accountsFeature = wallet.features['sui:signAndExecuteTransaction'];
                    }
                }
                
                // Try to connect if we have a connect feature
                if (connectFeature && typeof connectFeature.connect === 'function') {
                    try { await connectFeature.disconnect?.(); } catch (_) {}
                    await connectFeature.connect({ silent: false });
                }
                
                // Try to get accounts
                let accounts = [];
                if (accountsFeature) {
                    if (typeof accountsFeature.getAccounts === 'function') {
                        accounts = await accountsFeature.getAccounts();
                    } else if (accountsFeature.accounts) {
                        accounts = accountsFeature.accounts;
                    }
                }
                
                // Fallback: try direct wallet properties
                if (!accounts || accounts.length === 0) {
                    if (wallet.accounts) {
                        accounts = wallet.accounts;
                    }
                }
                
                if (accounts && accounts.length > 0) {
                    const account = accounts[0];

                    // Check for network mismatch (no auto-switching)
                    const hasMismatch = checkWalletNetworkMismatch(wallet);

                    currentWallet = {
                        address: account.address,
                        type: 'wallet_standard',
                        wallet: wallet
                    };
                    connectedWalletStandard = wallet;
                    attachWalletEvents(wallet);

                    showCurrentWalletAddress(account.address);
                    document.getElementById('walletInfo').style.display = 'block';
                    updateWalletConnectionControls(true);
                    document.getElementById('walletType').textContent = `${wallet.name || 'Wallet Standard'}${hasMismatch ? ' (network mismatch!)' : ''}`;

                    logOutput(`Connected to ${wallet.name || 'wallet'}!`);
                    logOutput(`Address: ${account.address}`);
                    await getWalletBalance();

                    // Automatically find wallets after successful connection
                    try {
                        await findMyWallets();
                    } catch (e) {
                        // Non-fatal error, just log it
                    }
                } else {
                    throw new Error('No accounts found in wallet');
                }
            } catch (error) {
                throw new Error(`Failed to connect to wallet: ${error.message}`);
            }
        }


        async function connectViaWindowSui() {
            if (!window.sui) throw new Error('window.sui not detected');
            try {
                const hasConnectFeature = window.sui.features && window.sui.features['standard:connect'];
                const hasLegacyConnect = typeof window.sui.connect === 'function';
                if (hasConnectFeature) {
                    try { await window.sui.features['standard:connect'].disconnect?.(); } catch (_) {}
                    await window.sui.features['standard:connect'].connect({ silent: false });
                } else if (hasLegacyConnect) {
                    await window.sui.connect();
                } else if (window.sui.requestPermissions) {
                    await window.sui.requestPermissions();
                }
                let accounts = [];
                if (window.sui.accounts) accounts = window.sui.accounts;
                else if (window.sui.getAccounts) accounts = await window.sui.getAccounts();
                else if (window.sui.features && window.sui.features['standard:connect'] && window.sui.features['standard:connect'].accounts) {
                    accounts = window.sui.features['standard:connect'].accounts;
                }
                if (!accounts || !accounts.length) throw new Error('No accounts found in window.sui');
                const account = accounts[0];

                // Check for network mismatch (no auto-switching)
                const hasMismatch = checkWalletNetworkMismatch(window.sui);

                currentWallet = { address: account.address, type: 'wallet_standard', wallet: window.sui };
                connectedWalletStandard = window.sui;
                showCurrentWalletAddress(account.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `Sui Wallet (window.sui)${hasMismatch ? ' (network mismatch!)' : ''}`;
                logOutput('✅ Connected via window.sui');
                await getWalletBalance();

                // Automatically find wallets after successful connection
                try {
                    await findMyWallets();
                } catch (e) {
                    // Non-fatal error, just log it
                }
            } catch (e) {
                throw new Error('window.sui connection failed: ' + e.message);
            }
        }

        async function connectViaPhantomSui() {
            if (!(window.phantom && window.phantom.sui)) throw new Error('Phantom Sui provider not detected');
            const phantomSui = window.phantom.sui;
            try {
                logOutput('Attempting to connect to Phantom Sui...');
                
                // For Phantom, we need to request connection first
                let connectResult;
                if (typeof phantomSui.connect === 'function') {
                    try { await phantomSui.disconnect?.(); } catch (_) {}
                    connectResult = await phantomSui.connect();
                    logOutput('Phantom connect() called successfully');
                } else {
                    logOutput('No connect() method found, trying direct account access');
                }
                
                // Try multiple ways to get accounts from Phantom Sui
                let accounts = [];
                
                // Method 1: Check connect result
                if (connectResult && connectResult.accounts) {
                    accounts = connectResult.accounts;
                    logOutput('Got accounts from connect result');
                }
                // Method 2: Check accounts property
                else if (phantomSui.accounts && phantomSui.accounts.length) {
                    accounts = phantomSui.accounts;
                    logOutput('Got accounts from phantomSui.accounts');
                }
                // Method 3: Try getAccounts method
                else if (typeof phantomSui.getAccounts === 'function') {
                    accounts = await phantomSui.getAccounts();
                    logOutput('Got accounts from getAccounts()');
                }
                // Method 4: Check for publicKey (legacy)
                else if (phantomSui.publicKey) {
                    if (typeof phantomSui.publicKey.toSuiAddress === 'function') {
                        accounts = [{ address: phantomSui.publicKey.toSuiAddress() }];
                        logOutput('Got address from publicKey.toSuiAddress()');
                    } else if (typeof phantomSui.publicKey.toBase58 === 'function') {
                        accounts = [{ address: phantomSui.publicKey.toBase58() }];
                        logOutput('Got address from publicKey.toBase58()');
                    }
                }
                
                logOutput(`Phantom Sui returned ${accounts ? accounts.length : 0} accounts`);
                
                if (!accounts || !accounts.length) {
                    throw new Error('No accounts returned by Phantom Sui. Please ensure Phantom is unlocked and has a Sui account configured.');
                }
                
                const account = accounts[0];
                logOutput(`Using account: ${account.address}`);

                // Check for network mismatch (no auto-switching)
                const hasMismatch = checkWalletNetworkMismatch(phantomSui);
                
                currentWallet = { address: account.address, type: 'wallet_standard', wallet: phantomSui };
                connectedWalletStandard = phantomSui;
                
                showCurrentWalletAddress(account.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `Phantom (Sui)${hasMismatch ? ' (network mismatch!)' : ''}`;
                
                logOutput('✅ Connected via Phantom (Sui)');
                logOutput(`Address: ${account.address}`);
                await getWalletBalance();

                // Automatically find wallets after successful connection
                try {
                    await findMyWallets();
                } catch (e) {
                    // Non-fatal error, just log it
                }

            } catch (e) {
                logOutput(`Phantom Sui connection error: ${e.message}`, true);
                throw new Error('Phantom Sui connection failed: ' + e.message);
            }
        }

        async function disconnectWallet() {
            try {
                if (connectedWalletStandard && connectedWalletStandard.features) {
                    if (
                        connectedWalletStandard.features['standard:connect'] &&
                        typeof connectedWalletStandard.features['standard:connect'].disconnect === 'function'
                    ) {
                        await connectedWalletStandard.features['standard:connect'].disconnect();
                    } else if (
                        connectedWalletStandard.features['sui:connect'] &&
                        typeof connectedWalletStandard.features['sui:connect'].disconnect === 'function'
                    ) {
                        await connectedWalletStandard.features['sui:connect'].disconnect();
                    } else if (typeof connectedWalletStandard.disconnect === 'function') {
                        await connectedWalletStandard.disconnect();
                    }
                }
                
                currentWallet = null;
                connectedWalletStandard = null;

                // Clear zkLogin session storage
                try {
                    sessionStorage.removeItem('galactic:zkLogin');
                } catch (_) {}
                
                document.getElementById('walletInfo').style.display = 'none';
                updateWalletConnectionControls(false);
                showCurrentWalletAddress('', { skipReverse: true });
                document.getElementById('currentBalance').textContent = 'Loading...';

                logOutput('Wallet disconnected.');
            } catch (error) {
                logOutput('Error disconnecting wallet: ' + error.message, true);
            }
        }

        function attachWalletEvents(wallet) {
            try {
                if (wallet && wallet.features && wallet.features['standard:events'] && typeof wallet.features['standard:events'].on === 'function') {
                    wallet.features['standard:events'].on('change', async (e) => {
                        try {
                            if (e && e.accounts && e.accounts.length) {
                                const account = e.accounts[0];
                                currentWallet = { address: account.address, type: 'wallet_standard', wallet };
                                connectedWalletStandard = wallet;
                                showCurrentWalletAddress(account.address);
                                document.getElementById('walletInfo').style.display = 'block';
                                updateWalletConnectionControls(true);
                                await getWalletBalance();
                                logOutput(`Active account changed to: ${account.address}`);
                            }
                        } catch (err) {
                            logOutput('Error handling account change: ' + err.message, true);
                        }
                    });
                }
            } catch (_) {}
        }

        // Helper function to sign and execute transactions using proper Wallet Standard
        async function signAndExecuteTransaction(tx) {
            if (!currentWallet) {
                throw new Error('No wallet connected');
            }

            if (currentWallet.type === 'wallet_standard') {
                const wallet = connectedWalletStandard;
                
                // Build transaction data for wallet standard
                const transactionData = {
                    transaction: tx,
                    account: { address: currentWallet.address },
                    chain: `sui:${currentNetwork}`,
                    // Ask wallets to return rich response so we can read created object IDs
                    options: { showEffects: true, showObjectChanges: true }
                };
                
                // Try current Wallet Standard methods (preferred)
                if (wallet.features && wallet.features['sui:signAndExecuteTransaction']) {
                    logOutput('Using sui:signAndExecuteTransaction feature...');
                    return await wallet.features['sui:signAndExecuteTransaction'].signAndExecuteTransaction(transactionData);
                }
                
                // Try legacy methods (for backward compatibility)
                if (wallet.features && wallet.features['sui:signAndExecuteTransactionBlock']) {
                    logOutput('Using sui:signAndExecuteTransactionBlock feature...');
                    return await wallet.features['sui:signAndExecuteTransactionBlock'].signAndExecuteTransactionBlock({
                        transactionBlock: tx,
                        account: { address: currentWallet.address },
                        chain: `sui:${currentNetwork}`,
                        options: { showEffects: true, showObjectChanges: true }
                    });
                }
                
                // Try direct method access
                if (typeof wallet.signAndExecuteTransactionBlock === 'function') {
                    logOutput('Using direct signAndExecuteTransactionBlock method...');
                    return await wallet.signAndExecuteTransactionBlock({
                        transactionBlock: tx,
                        account: { address: currentWallet.address },
                        chain: `sui:${currentNetwork}`,
                        options: { showEffects: true, showObjectChanges: true }
                    });
                }
                
                if (typeof wallet.signAndExecuteTransaction === 'function') {
                    logOutput('Using direct signAndExecuteTransaction method...');
                    return await wallet.signAndExecuteTransaction(transactionData);
                }
                
                throw new Error('Wallet does not support transaction signing. Please ensure your wallet supports the Sui Wallet Standard.');
                
            } else if (currentWallet.type === 'zkLogin') {
                const zk = currentWallet.zkLogin || {};
                if (!zk.signatureInputs) {
                    throw new Error('zkLogin proving service not ready. Reconnect after configuring the prover URL.');
                }
                if (!zk.ephemeralKeypair) {
                    throw new Error('zkLogin session missing ephemeral keypair. Please reconnect via zkLogin before signing.');
                }

                const { Transaction } = window.SuiSDK.Sui;
                if (!(tx instanceof Transaction)) {
                    throw new Error('Unsupported transaction object for zkLogin signing.');
                }

                tx.setSenderIfNotSet(currentWallet.address);
                const txBytes = await tx.build({ client: suiClient });

                const { signature } = await zk.ephemeralKeypair.signTransaction(txBytes);
                const signatureBytes = window.SuiSDK.BCS.fromBase64(signature);
                if (!signatureBytes || signatureBytes.length < 65) {
                    throw new Error('Invalid zkLogin user signature produced.');
                }
                const rawUserSignature = signatureBytes.slice(1, 65);

                const maxEpochValue = zk.maxEpoch || pendingZkLoginContext?.maxEpoch;
                if (!maxEpochValue) {
                    throw new Error('Missing maxEpoch for zkLogin signature. Reconnect to refresh the session.');
                }
                let maxEpochBigInt;
                try {
                    maxEpochBigInt = BigInt(maxEpochValue);
                } catch (_) {
                    throw new Error('Invalid maxEpoch value returned by zkLogin proving service.');
                }

                const zkSignature = window.SuiSDK.ZkLogin.getZkLoginSignature({
                    inputs: zk.signatureInputs,
                    maxEpoch: maxEpochBigInt,
                    userSignature: rawUserSignature
                });

                logOutput('🔐 Signing transaction with zkLogin...');
                const result = await suiClient.executeTransactionBlock({
                    transactionBlock: txBytes,
                    signature: [zkSignature],
                    options: { showEffects: true, showObjectChanges: true }
                });
                logOutput('✅ zkLogin transaction executed successfully');
                return result;

            } else {
                // Use traditional keypair signing for non-wallet-standard connections
                return await suiClient.signAndExecuteTransaction({
                    signer: currentWallet.keypair,
                    transaction: tx
                });
            }
        }

        function clearOutput() {
            document.getElementById('output').textContent = '';
        }

        // View-only connection function that accepts Sui addresses or SuiNS names
        async function connectViewOnly(target) {
            try {
                const { address, source, name } = await resolveViewOnlyTarget(target);

                currentWallet = {
                    address,
                    type: 'view_only',
                    wallet: null
                };
                connectedWalletStandard = null;

                showCurrentWalletAddress(address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = source === 'suins' ? 'View Only (SuiNS)' : 'View Only (Address)';

                if (source === 'suins' && name) {
                    logOutput(`SuiNS ${name} resolved to: ${address}`);
                } else {
                    logOutput(`Viewing address: ${address}`);
                }
                logOutput('Note: This is view-only. You cannot sign transactions without a proper wallet connection.');

                try {
                    const inputEl = document.getElementById('viewOnlyTarget');
                    if (inputEl) inputEl.value = ''; // clear after successful connect
                } catch (_) {}

                await getWalletBalance();
            } catch (error) {
                logOutput('View-only connection error: ' + error.message, true);
            }
        }

        window.getWalletBalance = getWalletBalance;
        window.getStoredWallets = getStoredWallets;
        window.clearOutput = clearOutput;
        window.connectWalletStandard = connectWalletStandard;
        window.disconnectWallet = disconnectWallet;
        window.connectViewOnly = connectViewOnly;
        window.clearZkLoginSession = function() {
            try {
                sessionStorage.removeItem('galactic:zkLogin');
                logOutput('zkLogin session storage cleared');
            } catch (e) {
                logOutput('Failed to clear zkLogin session: ' + e.message, true);
            }
        };


        // App initialization
        function initializeApp() {
            updateWalletConnectionControls(false);

            // Show all sections immediately (except operations which stays collapsed)
            const allSections = document.querySelectorAll('.section');
            const operationsSection = document.getElementById('smartWalletOperations');
            allSections.forEach(section => {
                if (operationsSection && section === operationsSection) {
                    return;
                }
                section.style.display = 'block';
                section.classList.add('visible');
            });

            try {
                const overlay = document.getElementById('walletModal');
                if (overlay) {
                    overlay.addEventListener('click', function(ev){ if (ev.target === overlay) closeWalletModal(); });
                }
                const closeButton = document.getElementById('walletModalClose');
                if (closeButton) {
                    closeButton.addEventListener('click', () => closeWalletModal());
                }
                document.addEventListener('keydown', function(ev){
                    if (ev.key === 'Escape') {
                        closeWalletModal();
                        closeAllTraditionalDropdowns();
                    }
                });

                // Close dropdowns when clicking outside
                document.addEventListener('click', function(ev) {
                    if (!ev.target.closest('.traditional-providers') && !ev.target.closest('.zklogin-providers')) {
                        closeAllTraditionalDropdowns();
                    }
                });
            } catch (e) {}

            scheduleBootstrapWork();
        }

        // Global variables for zkLogin state
        let currentJWT = null;
        let currentSub = null;
        let currentNonce = null;
        let ephemeralKeypair = null;

        // Google OAuth configuration
        // Use the same client ID as ZKLOGIN_CONFIG for consistency
        const GOOGLE_CLIENT_ID = ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID;

        // Initialize Google OAuth when page loads
        window.addEventListener('load', function() {
            if (typeof google !== 'undefined') {
                initializeGoogleAuth();
            } else {
                // Wait for Google script to load
                const checkGoogle = setInterval(() => {
                    if (typeof google !== 'undefined') {
                        clearInterval(checkGoogle);
                        initializeGoogleAuth();
                    }
                }, 100);
            }
        });

        function initializeGoogleAuth() {
            try {
                google.accounts.id.initialize({
                    client_id: GOOGLE_CLIENT_ID,
                    callback: handleGoogleSignIn,
                    auto_select: false,
                    cancel_on_tap_outside: true
                });

                // Render manual sign-in button immediately
                renderManualSignInButton();
            } catch (error) {
                console.error('Failed to initialize Google Auth:', error);
            }
        }

        function renderManualSignInButton() {
            const buttonContainer = document.getElementById('manual-signin-button');
            if (buttonContainer && typeof google !== 'undefined' && google.accounts) {
                google.accounts.id.renderButton(
                    buttonContainer,
                    {
                        theme: 'outline',
                        size: 'large',
                        width: 300
                    }
                );
            }
        }

        function handleGoogleSignIn(response) {
            try {
                console.log('Google sign-in response received:', response);
                currentJWT = response.credential;

                // Decode JWT to get claims
                const payload = parseJWT(currentJWT);
                currentSub = payload.sub;

                console.log('JWT received, sub:', currentSub);

                // Generate ephemeral key data for zkLogin
                generateEphemeralKeyData();

                // Update UI (with safety checks)
                const googleSignInResult = document.getElementById('googleSignInResult');
                const googleAuthText = document.getElementById('googleAuthText');
                const jwtDisplay = document.getElementById('jwtDisplay');
                const jwtContent = document.getElementById('jwtContent');
                const zkLoginBtn = document.getElementById('zkLoginBtn');

                if (googleSignInResult) {
                    googleSignInResult.style.display = 'block';
                }
                if (googleAuthText) {
                    googleAuthText.textContent = `✅ Signed in as ${payload.email || payload.sub}`;
                }
                if (jwtDisplay) {
                    jwtDisplay.style.display = 'block';
                }
                if (jwtContent) {
                    jwtContent.textContent = JSON.stringify(payload, null, 2);
                }

                // Enable zkLogin proof generation
                if (zkLoginBtn) {
                    zkLoginBtn.disabled = false;
                    zkLoginBtn.style.background = 'linear-gradient(145deg,#458BBD,#5A9BD4)';
                    zkLoginBtn.style.cursor = 'pointer';
                    zkLoginBtn.innerHTML = '🔐 Generate zkLogin Proof';
                }

                logOutput(`✅ Google authentication successful! Sub: ${currentSub}`);

            } catch (error) {
                console.error('Error handling Google sign-in:', error);
                logOutput(`❌ Google authentication failed: ${error.message}`, true);
            }
        }

        function parseJWT(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (error) {
                throw new Error('Failed to parse JWT: ' + error.message);
            }
        }

        // Make handleGoogleSignIn globally accessible
        window.handleGoogleSignIn = handleGoogleSignIn;

        // Generate ephemeral keypair and nonce when user signs in
        async function generateEphemeralKeyData() {
            try {
                // Ensure transaction tier is loaded for keypair generation
                await ensureSDKTier('transaction', 'keypair generation');

                // Generate ephemeral keypair for this session (for demo purposes)
                if (window.SuiSDK?.Sui?.Ed25519Keypair) {
                    ephemeralKeypair = window.SuiSDK.Sui.Ed25519Keypair.generate();
                }

                // Generate cryptographically secure nonce
                const randomness = window.SuiSDK.ZkLogin.generateRandomness();
                const maxEpoch = BigInt(10); // Set max epoch for the proof
                currentNonce = window.SuiSDK.ZkLogin.generateNonce(ephemeralKeypair?.getPublicKey(), maxEpoch, randomness);

                console.log('Generated nonce:', currentNonce);
                console.log('Ephemeral keypair generated');
            } catch (error) {
                console.error('Failed to generate ephemeral key data:', error);
            }
        }

        // Security initialization
        function initializeSecurity() {
            try {
                // Generate and set CSRF token if security utilities are available
                if (typeof window.setCSRFToken === 'function') {
                    const csrfToken = window.setCSRFToken();
                    console.log('CSRF protection initialized');
                } else {
                    console.warn('CSRF protection not available - ensure zklogin-helpers are loaded');
                }
            } catch (error) {
                console.error('Security initialization failed:', error);
            }
        }

        // Combined initialization
        async function initializeWallet() {
            initializeSecurity();
            await initializeApp();
        }

        // Initialize when ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeWallet);
        } else {
            initializeWallet();
        }
    </script>
</head>
<body>
    <!-- Main content (show immediately) -->
    <div class="container main-content loaded" id="main-content">
        <h1><span class="sw-icon" aria-hidden="true"></span> Galactic</h1>
        <p style="text-align: center; color: #c3d5e8; font-size: 16px; margin-top: -10px; margin-bottom: 30px;">
            Galactic Wallet Interface
        </p>
        

        <div class="section">
            <div class="wallet-connection-header">
                <h3>Wallet Connection</h3>
                <button id="walletHeaderAction" class="primary-btn connect-wallet-inline">Connect</button>
            </div>

            <details id="walletConnectionControls" class="section-toggle">
                <summary>
                    <span>Wallet Connection Controls</span>
                    <span id="walletConnectionStatus" class="summary-status">Not connected</span>
                </summary>
                <div style="padding: 5px;">

                    
                    <!-- View-Only Connection -->
                    <details style="margin-top: 15px; border: 1px solid rgba(139,69,189,.3); border-radius: 8px; padding: 10px;">
                        <summary style="cursor: pointer; font-weight: 500; color: #c3d5e8; font-size: 12px;">👁️ View-Only Connection</summary>
                        <div style="margin-top: 10px;">
                            <p style="font-size: 11px; color: #a0b3c5; margin: 0 0 8px 0;">Enter a Sui address (0x...) or SuiNS name (example.sui) to view balances without signing.</p>
                            <input type="text" id="viewOnlyTarget" placeholder="0x... or name.sui" style="width: 70%; font-size: 12px;">
                            <button onclick="connectViewOnly(document.getElementById('viewOnlyTarget').value)" style="font-size: 12px; padding: 5px 10px;">Connect View-Only</button>
                        </div>
                    </details>
                </div>
            </details>

            <div id="walletInfo" class="wallet-info" style="display: none;">
                <h4 class="wallet-heading">Connected Wallet
                    <span id="walletSuinsName" class="wallet-suins" style="display:none;">
                        <span id="walletSuinsValue" class="address-value"></span>
                        <button type="button" class="copy-btn" data-copy-target="walletSuinsValue" data-copy-allow-any="true" aria-label="Copy SuiNS name" title="Copy SuiNS name">Copy</button>
                    </span>
                </h4>
                <p><strong>Type:</strong> <span id="walletType">Unknown</span></p>
                <p class="address-row"><strong>Address:</strong>
                    <span id="currentAddress" class="address-value"></span>
                    <button type="button" class="copy-btn" data-copy-target="currentAddress" aria-label="Copy address" title="Copy address">Copy</button>
                </p>
                <p class="balance-row"><strong>Balance:</strong>
                    <span id="currentBalance" class="balance-value">Loading...</span>
                    <button type="button" class="balance-refresh" onclick="getWalletBalance()" aria-label="Refresh balance">Refresh</button>
                </p>
                <button onclick="disconnectWallet()" style="background: #dc3545;">Disconnect</button>
            </div>
        </div>

        <div class="section">
            <h3>Console Output</h3>
            <button onclick="clearOutput()">Clear Output</button>
            <div id="output">Galactic Wallet Interface Ready

</div>
        </div>
    </div>
    <!-- Wallet Selection Modal -->
    <div id="walletModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="walletModalTitle">
      <div class="modal" role="document">
        <div class="modal-header">
          <h4 id="walletModalTitle" class="modal-title">Select a Sui Wallet</h4>
          <button id="walletModalClose" class="modal-close" aria-label="Close">✕</button>
        </div>
        <div id="walletModalBody" class="modal-body">
          <div id="walletModalList"></div>
        </div>
      </div>
    </div>
    
</body>
</html>
