<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Wallet</title>

    <!-- Critical inline CSS for initial paint -->
    <style>
        :root {
            color-scheme: dark;
        }
        body {
            margin: 0;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0f;
            color: #e0e0ff;
            display: flex;
            flex-direction: column;
        }
        .wallet-connection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }
        #walletHeaderSpinnerWrapper {
            display: none;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #cfe4f7;
        }
        #walletHeaderSpinner {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: #ffffff;
            animation: wallet-header-spin 1s linear infinite;
        }
        @keyframes wallet-header-spin {
            to { transform: rotate(360deg); }
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
    </style>

    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' blob: https://accounts.google.com https://www.gstatic.com https://*.gstatic.com https://apis.google.com; script-src-elem 'self' 'unsafe-inline' 'unsafe-eval' blob: https://accounts.google.com https://www.gstatic.com https://*.gstatic.com https://apis.google.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; connect-src 'self' https: wss: https://accounts.google.com https://www.googleapis.com https://www.gstatic.com; worker-src 'self' blob:; child-src 'self' blob:; frame-src 'self' https://accounts.google.com; object-src 'none'; base-uri 'self'; form-action 'self';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">

    <!-- Dev favicon: served from assets; injector may override in prod -->
    <link rel="icon" type="image/png" href="/assets/favicon-128.png" onerror="this.onerror=null; this.href='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzQ1OEJCRCIvPgo8dGV4dCB4PSI1MCUiIHk9IjUwJSIgZmlsbD0iI0ZGRkZGRiIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIGZvbnQtd2VpZ2h0PSI2MDAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJjZW50cmFsIj5XPC90ZXh0Pgo8L3N2Zz4='">

    <!-- Google OAuth -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>

    <script>
        // Optimized favicon loading - defer until critical content loads
        window.addEventListener('load',function(){
            const link=document.querySelector('link[rel="icon"]');
            if(link&&link.href){
                const styleEl=document.createElement('style');
                styleEl.id='sw-favicon-var';
                styleEl.textContent=`:root{--sw-favicon-url:url("${link.href}")}`;
                (document.body||document.head).appendChild(styleEl);
            }
        });
        if ('serviceWorker' in navigator) {
            const isLocalhost = ['localhost', '127.0.0.1', '::1'].includes(window.location.hostname);
            if (window.location.protocol === 'https:' || isLocalhost) {
                navigator.serviceWorker.register('/sw.js').catch(error => {
                    console.warn('Service worker registration failed:', error);
                });
            }
        }
    </script>

    <!-- zk-Login dependencies -->
    <script>
        // zkLogin circuit runtime will be loaded via zklogin-helpers bundle
        // Static WASM assets should be available at /zklogin.wasm, /zklogin.zkey, /verification_key.json
    </script>
    <!-- Critical CSS for immediate rendering -->
    <style>
        html {
            height: 100%;
            overflow-y: auto;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a2332 0%, #2a3d52 100%);
            color: #f4f1ef;
            min-height: 100vh;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .container {
            background: linear-gradient(145deg, #1e3a52 0%, #2d4a66 100%);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            border: 1px solid rgba(69, 139, 189, 0.3);
        }
        h1 {
            color: #f4f1ef;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* Main content shows immediately */
        .main-content.loaded {
            opacity: 1;
        }

        /* Sections fade in smoothly */
        .section {
            margin:20px 0;padding:20px;border:1px solid rgba(69,139,189,.4);border-radius:10px;background:linear-gradient(145deg,rgba(30,58,82,.6),rgba(45,74,102,.6));backdrop-filter:blur(10px);display:none;opacity:0;transition:opacity .5s ease-in;
        }
        .section.visible {
            opacity: 1;
        }
        
        /* Critical elements - optimized */
        body,.container,h1{visibility:visible!important}
        .section h3{margin-top:0;color:#c3d5e8;text-shadow:0 1px 2px rgba(0,0,0,.3)}
        :root{--sw-favicon-url:initial;--sw-modal-surface:linear-gradient(145deg,#1e3a52 0%,#2d4a66 100%)}
        .sw-icon{display:inline-block;width:1em;height:1em;background-image:var(--sw-favicon-url);background-size:contain;background-repeat:no-repeat;vertical-align:-.15em}
        button{background:linear-gradient(145deg,#458BBD,#5A9BD4);color:#f4f1ef;border:none;padding:10px 20px;border-radius:8px;cursor:pointer;margin:5px;font-size:14px;transition:all .3s ease;box-shadow:0 3px 8px rgba(0,0,0,.3);border:1px solid rgba(90,155,212,.3)}
        button:hover{background:linear-gradient(145deg,#5A9BD4,#6BB6FF);transform:translateY(-1px);box-shadow:0 6px 12px rgba(0,0,0,.4)}
        button:disabled{background:rgba(69,139,189,.4);cursor:not-allowed;transform:none;color:rgba(244,241,239,.5)}
        .primary-btn{border-radius:12px;padding:15px 25px;font-size:16px;font-weight:600;box-shadow:0 6px 15px rgba(0,0,0,.25);border:1px solid rgba(69,139,189,.5);cursor:pointer;transition:all .3s ease;background:linear-gradient(145deg,#2d4a66,#458BBD)}
        .primary-btn:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,.35);background:linear-gradient(145deg,#458BBD,#5A9BD4)}
        input[type="text"],input[type="number"],input[type="password"],textarea{padding:12px;border:1px solid rgba(69,139,189,.4);border-radius:8px;margin:5px;background:rgba(30,58,82,.3);color:#f4f1ef;backdrop-filter:blur(5px);font-size:14px}
        .copy-btn{margin:0 0 0 8px;padding:6px 10px;font-size:12px;line-height:1;border-radius:6px;background:rgba(69,139,189,.6);border:1px solid rgba(69,139,189,.5);box-shadow:none}
        .copy-btn:hover{background:rgba(90,155,212,.85)}
        .copy-btn:disabled{opacity:.6;cursor:not-allowed}
        .copy-btn[data-copied="true"]{background:#2e7d32;border-color:#2e7d32;color:#fff}
        .address-row,.address-display{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
        .address-value{font-family:'Courier New',monospace;font-size:13px;word-break:break-all}
        .wallet-heading{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:10px}
        .wallet-suins{display:inline-flex;align-items:center;gap:6px;padding:2px 6px;border-radius:6px;background:rgba(69,139,189,.2);font-size:12px;color:#aedaef}
        input[type="text"]:focus,input[type="number"]:focus,input[type="password"]:focus,textarea:focus{outline:none;border-color:#5A9BD4;box-shadow:0 0 10px rgba(90,155,212,.3)}
        input::placeholder,textarea::placeholder{color:rgba(244,241,239,.6)}
        #output{background:#2c3e50;color:#ecf0f1;padding:15px;border-radius:5px;font-family:'Courier New',monospace;font-size:12px;max-height:300px;overflow-y:auto;white-space:pre-wrap;margin-top:20px}
        .wallet-connection-header{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:12px;margin-bottom:12px}
        .wallet-connection-header h3{margin:0}
        .connect-wallet-inline{padding:8px 16px;font-size:14px;background:linear-gradient(145deg,#4CAF50,#45a049);box-shadow:0 4px 12px rgba(0,0,0,.25);}
        .connect-wallet-inline:hover{background:linear-gradient(145deg,#45a049,#3f8f44)}
        .view-only-toggle{width:36px;height:36px;padding:0;display:inline-flex;align-items:center;justify-content:center;background:linear-gradient(145deg,#F7D36B,#E3A619);color:#1f1f1f;border:none;border-radius:12px;cursor:pointer;box-shadow:0 4px 12px rgba(179,126,24,.32);font-size:18px;line-height:1;transition:transform .15s ease,box-shadow .15s ease,filter .15s ease;}
        .view-only-toggle:hover{background:linear-gradient(145deg,#EFC149,#D99812);transform:translateY(-1px);box-shadow:0 6px 16px rgba(179,126,24,.38);}
        .view-only-toggle:active{transform:translateY(0);box-shadow:0 2px 6px rgba(179,126,24,.28);filter:brightness(.96);}
        .view-only-toggle:focus-visible{outline:2px solid rgba(255,255,255,.8);outline-offset:2px;}
        .connect-wallet-inline.disconnect{background:#dc3545;box-shadow:0 4px 12px rgba(0,0,0,.25);border:1px solid rgba(220,53,69,.6);}
        .connect-wallet-inline.disconnect:hover{background:#c82333}
        .balance-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
        .view-only-input-error{border:1px solid #dc3545 !important; box-shadow:0 0 0 2px rgba(220,53,69,.35) !important;}
        .balance-value{font-family:'Courier New',monospace;}
        .balance-refresh{margin:0;padding:6px 10px;font-size:12px;line-height:1;border-radius:6px;background:rgba(69,139,189,.6);border:1px solid rgba(69,139,189,.5);color:#f4f1ef;cursor:pointer;transition:background .2s ease;box-shadow:none}
        .balance-refresh:hover{background:rgba(90,155,212,.85)}
        @media (max-width:600px){.wallet-connection-header{flex-direction:column;align-items:stretch}.wallet-connection-header h3{text-align:left}.connect-wallet-inline{width:100%}}
        .wallet-info{background:linear-gradient(145deg,#1f3b2f,#254836);border-left:4px solid #27ae60;padding:12px;margin:12px 0;border-radius:10px;color:#e6f2e6}
        .wallet-info strong{color:#f4fff4}
        .error{background:#fdf2f2;border-left:4px solid #e74c3c;padding:10px;margin:10px 0;color:#c0392b}
        .success{background:#d4edda;border-left:4px solid #28a745;padding:10px;margin:10px 0;color:#155724}
        
        .address-display {
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,.3);
            padding: 8px;
            border-radius: 5px;
            word-break: break-all;
            font-size: 12px;
        }
        .form-group {
            margin: 15px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #c3d5e8;
            font-weight: 500;
        }
        .form-group input, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        /* Modal styles */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; align-items: center; justify-content: center; z-index: 1000; }
        .modal-overlay.visible { display: flex; }
        .modal { width: min(600px, 92vw); max-height: 80vh; display: flex; flex-direction: column; overflow: hidden; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 1px solid rgba(69,139,189,.4); background: var(--sw-modal-surface); }
        .modal-header { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; border-bottom: 1px solid rgba(69,139,189,.3); }
        .modal-title { margin: 0; font-size: 16px; color: #cfe4f7; font-weight: 600; }
        .modal-close { background: transparent; border: none; color: #cfe4f7; font-size: 18px; cursor: pointer; padding: 6px 8px; }
        .modal-body { flex: 1; min-height: 0; padding: 12px 16px 20px; overflow-y: auto; overflow-x: visible; background: linear-gradient(155deg, rgba(30,58,82,.95) 0%, rgba(41,70,96,.98) 100%); }
        .wallet-card { display: flex; align-items: center; justify-content: space-between; gap: 12px; border: 1px solid rgba(69,139,189,.3); border-radius: 8px; padding: 12px; background: rgba(69,139,189,.08); margin: 10px 0; width: 100%; cursor: pointer; text-align: left; color: inherit; font: inherit; transition: border-color .2s ease, background .2s ease, transform .1s ease; position: relative; }
        .wallet-card::after { content: 'â†’'; font-size: 16px; color: #8fb9df; margin-left: auto; display: inline-flex; align-items: center; }
        .wallet-card:hover { border-color: rgba(90,155,212,.6); background: rgba(69,139,189,.15); transform: translateY(-1px); }
        .wallet-card:focus-visible { outline: 2px solid rgba(90,155,212,.8); outline-offset: 2px; }
        .wallet-card-icon-wrap { width: 48px; height: 48px; border-radius: 12px; overflow: hidden; flex-shrink: 0; display: flex; align-items: center; justify-content: center; background: rgba(69,139,189,.12); border: 1px solid rgba(69,139,189,.2); }
        .wallet-card-icon { width: 100%; height: 100%; object-fit: cover; display: block; }
        .wallet-card-icon.passkey-icon { width: 80%; height: 80%; object-fit: contain; }
        .wallet-card-content { flex: 1; min-width: 0; }
        .wallet-card-name { font-weight: 600; color: #cfe4f7; }

        /* zkLogin provider selection styles */
        .zklogin-providers { position: relative; display: inline-block; width: 100%; }
        .zklogin-providers .wallet-card { margin: 0; }
        .zklogin-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: var(--sw-modal-surface); border: 1px solid rgba(69,139,189,.4); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1001; display: none; margin-top: 4px; }
        .zklogin-dropdown.visible { display: block; }
        .zklogin-provider { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border: none; background: transparent; color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; transition: background .2s ease; }
        .zklogin-provider:hover { background: rgba(69,139,189,.15); }
        .zklogin-provider:first-child { border-radius: 8px 8px 0 0; }
        .zklogin-provider:last-child { border-radius: 0 0 8px 8px; }
        .zklogin-provider:only-child { border-radius: 8px; }

        /* Traditional wallet dropdown styles */
        .traditional-providers { position: relative; display: block; width: 100%; }
        .traditional-providers .wallet-card { margin: 0; }
        .traditional-dropdown { position: relative; background: var(--sw-modal-surface); border: 1px solid rgba(69,139,189,.4); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1; display: none; margin-top: 8px; max-width: 100%; overflow: hidden; }
        .traditional-dropdown.visible { display: block; }
        .traditional-provider { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border: none; background: transparent; color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; transition: background .2s ease; }
        .traditional-provider:hover { background: rgba(69,139,189,.15); }
        .traditional-provider:first-child { border-radius: 8px 8px 0 0; }
        .traditional-provider:last-child { border-radius: 0 0 8px 8px; }
        .traditional-provider:only-child { border-radius: 8px; }
        .traditional-provider-icon { width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 10px; }

        /* Traditional wallet form styles */
        .form-row input:focus { outline: none; border-color: rgba(90,155,212,.6); }
        .form-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
        .form-actions button { padding: 6px 12px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: transparent; color: #cfe4f7; cursor: pointer; font-size: 11px; }
        .form-actions .create-btn { background: #ff6b35; border-color: #ff6b35; color: white; font-weight: 600; }

        /* Create wallet dropdown styles */
        .create-wallet-container { position: relative; display: inline-block; width: 100%; }
        .create-wallet-dropdown { position: relative; background: var(--sw-modal-surface); border: 1px solid rgba(69,139,189,.4); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1; display: none; margin-top: 8px; max-height: none; overflow: visible; }
        .create-wallet-dropdown.visible { display: block; }
        .create-wallet-dropdown .traditional-provider-form { min-height: 210px; }

        /* Wallet item styles */
        .wallet-item:hover { background: rgba(69,139,189,.15); }
        .wallet-delete-btn { opacity: 0.7; transition: all 0.2s ease; }
        .wallet-delete-btn:hover { opacity: 1; color: #ff6666; transform: scale(1.1); }
        .wallet-list { max-height: 100px; overflow-y: auto; overflow-x: hidden; width: 100%; }
        .wallet-list::-webkit-scrollbar { width: 4px; }
        .wallet-list::-webkit-scrollbar-track { background: rgba(69,139,189,.1); }
        .wallet-list::-webkit-scrollbar-thumb { background: rgba(69,139,189,.3); border-radius: 2px; }
        .zklogin-provider-icon { width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        .zklogin-provider-icon svg { width: 100%; height: 100%; }
        .zklogin-provider-name { font-weight: 500; }
    </style>
    
    <!-- BUNDLE_PLACEHOLDER -->
    <script>
        // Shell dev bootstrap: ensure global and try to load IIFE bundle when developing.
        window.process={env:{NODE_ENV:'development'}};window.global=window.globalThis||window;
        (function ensureDevSdk(){
            if (window.SuiSDK) return; // Already injected (e.g., in production build)
            try {
                const preloadId='sw-shell-preload';
                if(!document.head.querySelector(`link[data-id="${preloadId}"]`)){
                    const preload=document.createElement('link');
                    preload.rel='preload';
                    preload.as='script';
                    preload.href='/dist/sui-sdk-shell.iife.js';
                    preload.crossOrigin='anonymous';
                    preload.dataset.id=preloadId;
                    document.head.appendChild(preload);
                }

                const s=document.createElement('script');
                s.src='/dist/sui-sdk-shell.iife.js';
                s.async=false;
                s.onload=function(){console.log('Dev SDK bundle loaded');};
                s.onerror=function(){console.warn('Dev SDK bundle not found. Run "npm run build" or serve dist/.');};
                document.head.appendChild(s);
            } catch(e){console.warn('Failed to attach dev SDK loader:', e);}
        })();

        let zkLoginHelpersPromise=null;
        window.__SMARTWALLET_ZKLOGIN_BASE64=window.__SMARTWALLET_ZKLOGIN_BASE64||'';

        function decodeZkLoginBase64(value){
            if(!value) return '';
            const globalRef=typeof globalThis!=='undefined'?globalThis:window;
            if(typeof globalRef.atob==='function'){
                return globalRef.atob(value);
            }
            if(globalRef.Buffer&&typeof globalRef.Buffer.from==='function'){
                return globalRef.Buffer.from(value,'base64').toString('utf8');
            }
            throw new Error('Base64 decoder unavailable');
        }

        function evaluateZkLoginSource(source){
            const execute=new Function(source);
            execute();
        }

        window.loadZkLoginHelpers=function(){
            if(window.WitnessCalculatorBuilder){
                return Promise.resolve();
            }
            if(zkLoginHelpersPromise){
                return zkLoginHelpersPromise;
            }
            zkLoginHelpersPromise=new Promise((resolve,reject)=>{
                const inlineBundle=window.__SMARTWALLET_ZKLOGIN_BASE64;
                if(inlineBundle){
                    try{
                        evaluateZkLoginSource(decodeZkLoginBase64(inlineBundle));
                        if(window.WitnessCalculatorBuilder){
                            try {
                                window.ZkLoginHelpers?.preloadZkLoginAssets?.();
                            } catch (helperError) {
                                console.warn('zkLogin asset prefetch failed (inline bundle):', helperError);
                            }
                            resolve();
                            return;
                        }
                        console.warn('zkLogin helpers inline bundle executed but WitnessCalculatorBuilder missing; falling back to network fetch.');
                    }catch(error){
                        console.warn('Inline zkLogin helper load failed, falling back to network bundle.', error);
                    }
                }

                const script=document.createElement('script');
                script.src='/dist/zklogin-helpers.iife.js';
                script.async=true;
                script.onload=function(){
                    if(window.WitnessCalculatorBuilder){
                        try {
                            window.ZkLoginHelpers?.preloadZkLoginAssets?.();
                        } catch (helperError) {
                            console.warn('zkLogin asset prefetch failed (script bundle):', helperError);
                        }
                        resolve();
                    }else{
                        reject(new Error('zkLogin helpers script executed but WitnessCalculatorBuilder is unavailable'));
                    }
                };
                script.onerror=function(){
                    reject(new Error('Failed to load zkLogin helper bundle'));
                };
                document.head.appendChild(script);
            }).catch(error=>{
                zkLoginHelpersPromise=null;
                throw error;
            });

            return zkLoginHelpersPromise;
        };

        const scheduleZkLoginWarmup=(function(){
            let warmupQueued=false;
            return function(){
                if(warmupQueued){
                    return;
                }
                warmupQueued=true;
                const idleScheduler=window.requestIdleCallback||function(cb){return setTimeout(cb,1500);};
                idleScheduler(async function(){
                    try {
                        if (!window.SuiSDK?.loadTransaction || !window.SuiSDK?.loadAdvanced) {
                            warmupQueued=false;
                            setTimeout(scheduleZkLoginWarmup, 1000);
                            return;
                        }
                        await window.SuiSDK.loadTransaction();
                        if (!window.SuiSDK?.Sui?.Ed25519Keypair || typeof window.SuiSDK.Sui.Ed25519Keypair.generate !== 'function') {
                            warmupQueued=false;
                            setTimeout(scheduleZkLoginWarmup, 1000);
                            return;
                        }
                        await window.SuiSDK.loadAdvanced();
                        await window.loadZkLoginHelpers?.();
                    } catch (warmupError) {
                        console.debug('zkLogin warmup skipped:', warmupError?.message || warmupError);
                        warmupQueued=false;
                    }
                });
            };
        })();

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                scheduleZkLoginWarmup();
            }
        }, { once: true });
        window.addEventListener('focus', scheduleZkLoginWarmup, { once: true });
    </script>
    
    <script type="module">

        import { argon2id } from '@noble/hashes/argon2';

        const ARGON2_MEMORY_KIB = 64 * 1024; // 64 MiB
        const ARGON2_TIME_COST = 3;
        const ARGON2_PARALLELISM = 1;
        const ARGON2_OUTPUT_LENGTH = 32;

        const HEX_ADDRESS_RE = /^0x[0-9a-fA-F]{2,}$/;
        const HEX_STRING_RE = /^(0x)?[0-9a-fA-F]{2,}$/;
        const SUINS_NAME_RE = /^[a-z0-9]+(?:[-.][a-z0-9]+)*\.sui$/i;
        const IMAGE_PLACEHOLDER = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
        const GOOGLE_JWKS_URL = 'https://www.googleapis.com/oauth2/v3/certs';
        const JWKS_CACHE_TTL_MS = 60 * 60 * 1000;
        const CLOCK_SKEW_MS = 5 * 60 * 1000;
        const ALLOWED_GOOGLE_ISSUERS = new Set(['https://accounts.google.com', 'accounts.google.com']);
        const GOOGLE_JWK_CACHE = new Map();
        let cachedGoogleJwks = { keys: null, fetchedAt: 0 };

       function base64UrlToUint8Array(segment){
           if(typeof segment!=='string' || !segment.length){
               return new Uint8Array();
           }
           const paddedLength = segment.length % 4;
           const padding = paddedLength ? '='.repeat(4 - paddedLength) : '';
           const base64 = (segment + padding).replace(/-/g, '+').replace(/_/g, '/');
           const binary = atob(base64);
           const bytes = new Uint8Array(binary.length);
           for(let i = 0; i < binary.length; i++){
               bytes[i] = binary.charCodeAt(i);
           }
           return bytes;
       }

       function decodeBase64UrlJson(segment){
           try {
                if (typeof segment !== 'string' || !segment.length) {
                    throw new Error('Invalid segment');
                }
                const paddedLength = segment.length % 4;
                const padding = paddedLength ? '='.repeat(4 - paddedLength) : '';
                const base64 = (segment + padding).replace(/-/g, '+').replace(/_/g, '/');
                const json = atob(base64);
                return JSON.parse(json);
            } catch (error) {
                throw new Error('Invalid JWT segment');
            }
        }

        async function fetchGoogleJwks(){
            const now = Date.now();
            if (cachedGoogleJwks.keys && now - cachedGoogleJwks.fetchedAt < JWKS_CACHE_TTL_MS) {
                return cachedGoogleJwks.keys;
            }
            const response = await fetch(GOOGLE_JWKS_URL, { cache: 'no-store' }).catch(() => null);
            if (!response || !response.ok) {
                throw new Error('Unable to fetch Google signing keys');
            }
            const data = await response.json();
            if (!data || !Array.isArray(data.keys)) {
                throw new Error('Google JWKS response malformed');
            }
            cachedGoogleJwks = { keys: data.keys, fetchedAt: now };
            return data.keys;
        }

        async function getGoogleSigningKey(kid){
            if (GOOGLE_JWK_CACHE.has(kid)) {
                return GOOGLE_JWK_CACHE.get(kid);
            }

            let keys = await fetchGoogleJwks();
            let jwk = keys.find(key => key.kid === kid);

            if (!jwk) {
                cachedGoogleJwks = { keys: null, fetchedAt: 0 };
                keys = await fetchGoogleJwks();
                jwk = keys.find(key => key.kid === kid);
            }

            if (!jwk) {
                throw new Error('Unable to locate Google signing key');
            }

            const keyData = {
                ...jwk,
                alg: 'RS256',
                use: 'sig',
                ext: true,
                key_ops: ['verify']
            };

            const cryptoKey = await crypto.subtle.importKey(
                'jwk',
                keyData,
                { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },
                false,
                ['verify']
            );

            GOOGLE_JWK_CACHE.set(kid, cryptoKey);
            return cryptoKey;
        }

        let currentWallet = null;
        let currentNetwork = 'testnet';
        let suiClient = null;
        let connectedWalletStandard = null; // Will store connected wallet standard wallet
        const suinsResolutionCache = new Map();
        const suinsReverseCache = new Map();
        let currentReverseLookupToken = 0;
        let sdkReadyPromise = null;
        let bootstrapPromise = null;


        const ZKLOGIN_CONFIG = {
            GOOGLE_CLIENT_ID: '373405271144-kevesn5h18jt8grqh5cel7jcsu9si73t.apps.googleusercontent.com',
            REDIRECT_PATH: '/auth/callback.html',
            EPOCH_BUFFER: 5,
            KEY_CLAIM_NAME: 'sub',
            PROVER_URL: (typeof window !== 'undefined' && window.ZKLOGIN_PROVER_URL) ? String(window.ZKLOGIN_PROVER_URL) : ''
        };

        let pendingZkLoginContext = null;


        function escapeHtml(value) {
            return String(value ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function makeWalletIcon(label, bg, fg = '#ffffff') {
            const text = (label || 'W').toString().trim().slice(0, 2).toUpperCase() || 'W';
            const fontSize = text.length > 1 ? 18 : 22;
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48"><rect width="48" height="48" rx="12" fill="${bg}"/><text x="50%" y="50%" fill="${fg}" font-family="'Segoe UI', 'Inter', sans-serif" font-size="${fontSize}" font-weight="600" text-anchor="middle" dominant-baseline="central">${text}</text></svg>`;
            return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
        }

        // Wallet encryption/decryption utilities
        async function encryptPrivateKey(privateKey, password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(privateKey);
            const passwordBytes = encoder.encode(password);

            const salt = crypto.getRandomValues(new Uint8Array(16));
            const derivedKey = argon2id(passwordBytes, salt, {
                m: ARGON2_MEMORY_KIB,
                t: ARGON2_TIME_COST,
                p: ARGON2_PARALLELISM,
                dkLen: ARGON2_OUTPUT_LENGTH,
            });

            const key = await crypto.subtle.importKey(
                'raw',
                derivedKey,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );

            // Encrypt the private key
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt(
                {
                    name: 'AES-GCM',
                    iv: iv
                },
                key,
                data
            );

            // Combine salt + iv + encrypted data
            const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
            result.set(salt, 0);
            result.set(iv, salt.length);
            result.set(new Uint8Array(encrypted), salt.length + iv.length);

            return btoa(String.fromCharCode.apply(null, result));
        }

        async function decryptPrivateKey(encryptedData, password) {
            try {
                const decoder = new TextDecoder();
                const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));

                const salt = data.slice(0, 16);
                const iv = data.slice(16, 28);
                const encrypted = data.slice(28);

                const passwordBytes = new TextEncoder().encode(password);

                const derivedKey = argon2id(passwordBytes, salt, {
                    m: ARGON2_MEMORY_KIB,
                    t: ARGON2_TIME_COST,
                    p: ARGON2_PARALLELISM,
                    dkLen: ARGON2_OUTPUT_LENGTH,
                });

                const key = await crypto.subtle.importKey(
                    'raw',
                    derivedKey,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );

                const decrypted = await crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    key,
                    encrypted
                );

                return decoder.decode(decrypted);
            } catch (error) {
                throw new Error('Invalid password or corrupted data');
            }
        }

        // Wallet storage management
        function getStoredWallets() {
            const wallets = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('galactic:wallet:')) {
                    try {
                        const walletData = JSON.parse(localStorage.getItem(key));
                        wallets.push(walletData);
                    } catch (e) {
                        // Skip corrupted entries
                    }
                }
            }
            return wallets.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        }

        function saveWallet(name, encryptedPrivateKey, address) {
            const walletData = {
                name,
                encryptedPrivateKey,
                address,
                createdAt: new Date().toISOString()
            };
            localStorage.setItem(`galactic:wallet:${name}`, JSON.stringify(walletData));
        }

        function deleteWallet(name) {
            if (confirm(`Are you sure you want to delete the wallet "${name}"? This action cannot be undone.`)) {
                localStorage.removeItem(`galactic:wallet:${name}`);
                logOutput(`Wallet "${name}" deleted successfully`);
                return true;
            }
            return false;
        }

        async function deleteWalletAndRefresh(walletName, walletIndex) {
            const success = deleteWallet(walletName);
            if (success) {
                // Check if any wallets remain
                const remainingWallets = getStoredWallets();

                if (remainingWallets.length === 0) {
                    // No wallets left, show create form
                    const dropdown = document.getElementById('traditionalDropdown' + walletIndex);
                    if (dropdown && dropdown.classList.contains('visible')) {
                        showCreateWalletForm(dropdown, walletIndex);
                    }
                } else {
                    // Refresh the dropdown to show updated wallet list
                    const dropdown = document.getElementById('traditionalDropdown' + walletIndex);
                    if (dropdown && dropdown.classList.contains('visible')) {
                        showTraditionalWalletOptions(dropdown, walletIndex);
                    }
                }
            }
        }



        function getZkLoginRedirectUri() {
            try {
                if (!window.location || !window.location.origin) {
                    return ZKLOGIN_CONFIG.REDIRECT_PATH || '/auth/callback.html';
                }
                const url = new URL(ZKLOGIN_CONFIG.REDIRECT_PATH || '/auth/callback.html', window.location.origin);
                return url.toString();
            } catch (_) {
                return `${window.location.origin || ''}/auth/callback.html`;
            }
        }

        function mapIssuerToProvider(iss) {
            if (!iss) return 'Unknown Provider';
            const normalized = iss.replace(/^https?:\/\//, '');
            if (normalized.startsWith('accounts.google.com')) return 'Google';
            if (normalized.includes('apple')) return 'Apple';
            if (normalized.includes('facebook')) return 'Facebook';
            try {
                const url = new URL(iss);
                return url.hostname;
            } catch (_) {
                return normalized;
            }
        }

        function buildZkLoginAuthUrl(nonce, provider = 'google') {
            const clientId = getClientIdForProvider(provider);
            const authUrl = getAuthUrlForProvider(provider);
            const params = new URLSearchParams({
                client_id: clientId,
                redirect_uri: getZkLoginRedirectUri(),
                response_type: 'id_token',
                scope: 'openid email profile',
                nonce: nonce,
                prompt: 'select_account',
                state: 'zklogin_galactic'
            });
            return `${authUrl}?${params.toString()}`;
        }

        async function prepareZkLoginContext() {
            // Ensure all required SDK tiers are loaded
            await ensureSDKTier('transaction', 'keypair generation');
            await ensureSDKTier('advanced', 'zkLogin support');

            if (!window.SuiSDK || !window.SuiSDK.ZkLogin || !window.SuiSDK.Sui) {
                throw new Error('Sui SDK not loaded');
            }
            if (!suiClient) {
                await initializeSuiClient();
            }
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            const { getExtendedEphemeralPublicKey, generateRandomness, generateNonce } = window.SuiSDK.ZkLogin;

            // Validate keypair generation capability
            if (!Ed25519Keypair || typeof Ed25519Keypair.generate !== 'function') {
                throw new Error('Ed25519Keypair.generate is not available - transaction tier may not be loaded');
            }

            const ephemeralKeyPair = Ed25519Keypair.generate();
            if (!ephemeralKeyPair) {
                throw new Error('Failed to generate ephemeral keypair');
            }
            const extendedPublicKey = getExtendedEphemeralPublicKey(ephemeralKeyPair.getPublicKey());

            // Generate local randomness and nonce
            const randomness = generateRandomness();
            const additionalEpochs = Number(ZKLOGIN_CONFIG.EPOCH_BUFFER ?? 5);

            // Fetch current epoch from Sui network
            const currentEpochInfo = await suiClient.getLatestSuiSystemState();
            const currentEpoch = Number(currentEpochInfo.epoch);
            // Set maxEpoch to currentEpoch + 1 for future-proofing as per zklogin2-instructions
            const maxEpoch = BigInt(currentEpoch + 1);
            const nonce = generateNonce(ephemeralKeyPair.getPublicKey(), maxEpoch, randomness);

            return {
                ephemeralKeyPair,
                randomness,
                nonce,
                maxEpoch: String(maxEpoch),
                currentEpoch: String(currentEpoch), // Store currentEpoch for consistent use during proof generation
                extendedPublicKey,
                provider: 'local',
                expiresAt: null // Local generation doesn't have predefined expiration
            };
        }

        function openOAuthPopup(authUrl) {
            return new Promise((resolve, reject) => {
                const popup = window.open(
                    authUrl,
                    'zklogin_oauth',
                    'width=500,height=600,scrollbars=yes,resizable=yes'
                );

                if (!popup) {
                    reject(new Error('Failed to open popup - please allow popups'));
                    return;
                }

                let checkClosed = null;

                const cleanup = () => {
                    window.removeEventListener('message', messageHandler);
                    if (checkClosed) {
                        clearInterval(checkClosed);
                        checkClosed = null;
                    }
                };

                const messageHandler = (event) => {
                    if (event.origin !== window.location.origin) {
                        return;
                    }
                    if (event.data?.type === 'zklogin_oauth_success') {
                        cleanup();
                        resolve(event.data.idToken);
                    } else if (event.data?.type === 'zklogin_oauth_error') {
                        cleanup();
                        reject(new Error('OAuth error: ' + event.data.error));
                    }
                };

                window.addEventListener('message', messageHandler);

                checkClosed = setInterval(() => {
                    try {
                        if (popup.closed) {
                            cleanup();
                            reject(new Error('OAuth popup was closed by user'));
                        }
                    } catch (error) {
                        // Cross-origin policy blocks popup.closed access - ignore silently
                        // The popup will still work via the message handler
                    }
                }, 800);
            });
        }

        async function validateZkLoginJwt(idToken, expectedNonce, expectedAud) {
            const encoder = new TextEncoder();

            if (typeof idToken !== 'string' || !idToken.includes('.')) {
                throw new Error('Invalid JWT format');
            }

            const segments = idToken.split('.');
            if (segments.length !== 3) {
                throw new Error('Invalid JWT format');
            }

            const [headerSegment, payloadSegment, signatureSegment] = segments;
            const header = decodeBase64UrlJson(headerSegment);

            if (header.alg !== 'RS256') {
                throw new Error('Unsupported JWT algorithm');
            }
            if (!header.kid) {
                throw new Error('JWT missing key identifier');
            }

            const signingKey = await getGoogleSigningKey(header.kid);
            const signatureBytes = base64UrlToUint8Array(signatureSegment);
            const signedContent = encoder.encode(`${headerSegment}.${payloadSegment}`);
            const signatureValid = await crypto.subtle.verify('RSASSA-PKCS1-v1_5', signingKey, signatureBytes, signedContent);

            if (!signatureValid) {
                throw new Error('JWT signature verification failed');
            }

            const payload = decodeBase64UrlJson(payloadSegment);

            if (!payload || typeof payload !== 'object') {
                throw new Error('JWT payload missing');
            }
            if (!payload.sub) {
                throw new Error('JWT missing subject (sub)');
            }
            if (!payload.iss || !ALLOWED_GOOGLE_ISSUERS.has(payload.iss)) {
                throw new Error('JWT issuer is not allowed');
            }
            if (!payload.nonce || payload.nonce !== expectedNonce) {
                throw new Error('Nonce mismatch between request and JWT');
            }

            const now = Date.now();

            if (typeof payload.exp === 'number') {
                const expiry = payload.exp * 1000;
                if (!Number.isFinite(expiry) || expiry < now - CLOCK_SKEW_MS) {
                    throw new Error('JWT has expired');
                }
            } else {
                throw new Error('JWT missing expiration (exp) claim');
            }

            if (typeof payload.iat === 'number') {
                const issuedAt = payload.iat * 1000;
                if (!Number.isFinite(issuedAt) || issuedAt > now + CLOCK_SKEW_MS) {
                    throw new Error('JWT issued-at time is invalid');
                }
            }

            if (typeof payload.nbf === 'number') {
                const notBefore = payload.nbf * 1000;
                if (notBefore > now + CLOCK_SKEW_MS) {
                    throw new Error('JWT not yet valid (nbf)');
                }
            }

            const audClaim = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
            if (!audClaim.includes(expectedAud)) {
                throw new Error('Unexpected JWT audience');
            }
            payload.aud = expectedAud;

            if (payload.email && payload.email_verified === false) {
                throw new Error('Email address has not been verified by Google');
            }

            return payload;
        }

        // zkLogin provider configuration
        const ZKLOGIN_PROVIDERS = {
            google: {
                name: 'Google',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18A10.85 10.85 0 001 12c0 1.61.39 3.14 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC04"/><path d="M12 4.75c1.61 0 3.06.55 4.22 1.64l3.15-3.15C17.45 1.09 14.97 0 12 0 7.7 0 3.99 2.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>',
                clientId: 'GOOGLE_CLIENT_ID'
            },
            facebook: {
                name: 'Meta',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.927v-8.437H7.078v-3.49h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.49h-2.796v8.437C19.612 23.027 24 18.062 24 12.073z" fill="#1877F2"/></svg>',
                clientId: 'FACEBOOK_CLIENT_ID'
            },
            apple: {
                name: 'Apple',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.71 19.5c-.83 1.24-1.71 2.45-3.05 2.47-1.34.03-1.77-.79-3.29-.79-1.53 0-2 .77-3.27.82-1.31.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.39c.87-1.52 2.43-2.48 4.12-2.51 1.28-.02 2.5.87 3.29.87.78 0 2.26-1.07 3.81-.91.65.03 2.47.26 3.64 1.98-.09.06-2.17 1.28-2.15 3.81.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.19-.69.85-1.83 1.51-2.95 1.42-.15-1.15.41-2.35 1.05-3.11z" fill="#ffffff"/></svg>',
                clientId: 'APPLE_CLIENT_ID'
            }
        };

        const ZKLOGIN_STORAGE_PREFIX = 'galactic:zklogin';

        function issuerToProviderSlug(iss) {
            switch (iss) {
                case 'https://accounts.google.com':
                    return 'google';
                case 'https://login.microsoftonline.com':
                    return 'microsoft';
                default:
                    return null;
            }
        }

        function hasStoredZkLogin(providerSlug) {
            if (!providerSlug) {
                return false;
            }

            const slugLower = providerSlug.toLowerCase();
            const zkPrefixLower = ZKLOGIN_STORAGE_PREFIX.toLowerCase();

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (!key) continue;

                const lowerKey = key.toLowerCase();
                if (!lowerKey.startsWith(zkPrefixLower)) {
                    continue;
                }

                if (lowerKey.includes(slugLower)) {
                    return true;
                }
            }

            return false;
        }

        function createZkLoginProviderIcon(provider) {
            return ZKLOGIN_PROVIDERS[provider]?.icon || makeWalletIcon('ZK', '#6c4bcc');
        }

        async function ensureZkLoginHelpers() {
            if (window.WitnessCalculatorBuilder) {
                return;
            }
            if (typeof window.loadZkLoginHelpers !== 'function') {
                throw new Error('zkLogin helper loader is not available');
            }
            await window.loadZkLoginHelpers();
            if (!window.WitnessCalculatorBuilder) {
                throw new Error('zkLogin helpers failed to load correctly - WitnessCalculatorBuilder missing');
            }
        }

        // Password prompt modal function
        function showPasswordPrompt(options = {}) {
            const {
                providerLabel = 'zkLogin',
                hasCache = false,
                initialError = '',
                validator,
                title,
                description,
                submitLabel = 'Continue',
                cancelLabel = 'Cancel',
                minLength = 8
            } = options;

            const effectiveTitle = title || `${providerLabel} Password`;
            const effectiveDescription = description || (
                hasCache
                    ? `Enter the password previously set to unlock this ${providerLabel} zkLogin identity.`
                    : `Create a password to protect these ${providerLabel} zkLogin credentials.`
            );

            return new Promise((resolve, reject) => {
                let isProcessing = false;

                const modal = document.createElement('div');
                modal.className = 'password-modal-overlay';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: linear-gradient(145deg, #1e3a52 0%, #2d4a66 100%);
                    border-radius: 15px;
                    padding: 30px;
                    box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
                    border: 1px solid rgba(69, 139, 189, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;

                content.innerHTML = `
                    <h3 style="color: #f4f1ef; margin-top: 0; text-align: center;">${effectiveTitle}</h3>
                    <p style="color: #cfe4f7; margin-bottom: 20px;">${effectiveDescription}</p>
                    <p id="passwordErrorMessage" style="color: #ff8888; margin-bottom: 12px; text-align: center; ${initialError ? '' : 'display:none;'}">${initialError}</p>
                    <input type="password" id="zkLoginPasswordInput" placeholder="Password (${minLength}+ characters)"
                        style="width: 100%; padding: 12px; background: rgba(30,58,82,.3); border: 1px solid rgba(69,139,189,.4);
                        border-radius: 8px; color: #f4f1ef; font-size: 14px; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: flex-end; align-items: center;">
                        <button id="passwordCancel" style="background: rgba(69,139,189,.4); color: #f4f1ef; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px;">${cancelLabel}</button>
                        <button id="passwordSubmit" style="background: linear-gradient(145deg,#458BBD,#5A9BD4); color: #f4f1ef; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">${submitLabel}</button>
                    </div>
                `;

                modal.appendChild(content);
                document.body.appendChild(modal);

                const passwordInput = content.querySelector('#zkLoginPasswordInput');
                const submitBtn = content.querySelector('#passwordSubmit');
                const cancelBtn = content.querySelector('#passwordCancel');
                const errorMessageEl = content.querySelector('#passwordErrorMessage');

                const defaultBorder = '1px solid rgba(69,139,189,.4)';
                const errorBorder = '1px solid #ff4444';

                const setProcessing = (processing) => {
                    isProcessing = processing;
                    submitBtn.disabled = processing;
                    cancelBtn.disabled = processing;
                    if (processing && validator) {
                        submitBtn.textContent = 'Validatingâ€¦';
                    } else {
                        submitBtn.textContent = submitLabel;
                    }
                };

                const showError = (message) => {
                    if (!errorMessageEl) return;
                    errorMessageEl.textContent = message;
                    errorMessageEl.style.display = message ? 'block' : 'none';
                    if (message) {
                        passwordInput.style.border = errorBorder;
                    }
                };

                const clearError = () => {
                    if (!errorMessageEl) return;
                    errorMessageEl.textContent = '';
                    errorMessageEl.style.display = 'none';
                    passwordInput.style.border = defaultBorder;
                };

                if (initialError) {
                    passwordInput.style.border = errorBorder;
                } else {
                    passwordInput.style.border = defaultBorder;
                }

                passwordInput.focus();

                const cleanup = () => {
                    submitBtn.removeEventListener('click', handleSubmit);
                    cancelBtn.removeEventListener('click', handleCancel);
                    passwordInput.removeEventListener('keydown', handleKeydown);
                    passwordInput.removeEventListener('input', handleInput);
                    if (modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                };

                const handleInput = () => {
                    passwordInput.style.border = defaultBorder;
                };

                const handleCancel = () => {
                    cleanup();
                    reject(new Error('Password prompt cancelled'));
                };

                const handleKeydown = (e) => {
                    if (e.key === 'Enter') {
                        handleSubmit();
                    } else if (e.key === 'Escape') {
                        handleCancel();
                    }
                };

                const handleSubmit = async () => {
                    if (isProcessing) return;
                    const password = passwordInput.value.trim();
                    clearError();

                    if (password.length < minLength) {
                        showError(`Password must be at least ${minLength} characters`);
                        passwordInput.focus();
                        return;
                    }

                    if (!validator) {
                        cleanup();
                        resolve(password);
                        return;
                    }

                    try {
                        setProcessing(true);
                        await validator(password);
                        cleanup();
                        resolve(password);
                    } catch (error) {
                        if (error?.message === 'Invalid password') {
                            showError('Invalid password. Please try again.');
                            passwordInput.focus();
                            passwordInput.select();
                        } else if (error?.message === 'NO_CACHED_JWT') {
                            cleanup();
                            reject(error);
                            return;
                        } else {
                            const message = error?.message || 'Unexpected error. Please try again.';
                            showError(message);
                            passwordInput.focus();
                        }
                    } finally {
                        if (modal.parentNode) {
                            setProcessing(false);
                        }
                    }
                };

                submitBtn.addEventListener('click', handleSubmit);
                cancelBtn.addEventListener('click', handleCancel);
                passwordInput.addEventListener('keydown', handleKeydown);
                passwordInput.addEventListener('input', handleInput);
            });
        }

        function formatAddressShort(address) {
            if (!address || address.length <= 12) return address || '';
            return `${address.slice(0, 8)}â€¦${address.slice(-4)}`;
        }

        async function handleZkLoginConnect(provider = 'google') {
            try {
                const providerName = ZKLOGIN_PROVIDERS[provider]?.name || provider;
                logOutput(`Starting ${providerName} zkLoginâ€¦`);
                await ensureSdkReady();
                if (!suiClient) {
                    await initializeSuiClient();
                }

                await ensureZkLoginHelpers();

                // zkLogin helpers are already injected globally

                // Set up custom password prompt with unified validation
                setPasswordPromptFunction(async (iss) => {
                    const providerSlug = issuerToProviderSlug(iss);
                    const providerLabel = providerSlug
                        ? (ZKLOGIN_PROVIDERS[providerSlug]?.name || mapIssuerToProvider(iss))
                        : mapIssuerToProvider(iss);
                    const hasCache = providerSlug ? hasStoredZkLogin(providerSlug) : false;

                    const validator = providerSlug
                        ? async (password) => {
                            await validatePasswordForProvider(providerSlug, password, { requireExistingEntry: hasCache });
                        }
                        : undefined;

                    return await showPasswordPrompt({
                        providerLabel,
                        hasCache,
                        validator
                    });
                });

                // Check cache-first approach using localStorage
                const iss = getIssuerFromProvider(provider);
                let jwt = null;
                let decodedJwt = null;
                let salt = null;
                let fromCache = false;

                try {
                    // CACHE PATH: First check if we have cached claims for this provider
                    logOutput(`ðŸ” Checking for cached ${providerName} identity...`);
                    const initStatus = await initiateSmartZkLogin(provider);

                    if (!initStatus || initStatus.needsOAuth) {
                        const reason = initStatus?.reason || 'Cached credentials unavailable';
                        logOutput(`â„¹ï¸ ${providerName} cache unavailable (${reason}).`);
                        throw new Error(`OAUTH_REQUIRED:${reason}`);
                    }

                    // If we get here, cache exists and password was provided
                    logOutput(`âœ… Using cached ${providerName} identity`);
                    fromCache = true;

                    // For cached flows we still need a fresh zkLogin context to generate proofs
                    pendingZkLoginContext = await prepareZkLoginContext();

                    // Set active provider for cached path
                    setActiveProvider(provider);

                    // Get salt from cached claims (uses cached password key, no double prompt)
                    salt = await getSaltForClaims();

                    // CACHE PATH: Load JWT using cached password key
                    jwt = await loadJwt(provider);
                    decodedJwt = window.SuiSDK.ZkLogin.decodeJwt(jwt); // Use official Sui SDK function

                } catch (error) {
                    if (error.message.includes('OAUTH_REQUIRED')) {
                        // Fall back to OAuth flow
                        logOutput('ðŸŒ No cached identity found, proceeding with OAuth...');

                        pendingZkLoginContext = await prepareZkLoginContext();
                        const authUrl = buildZkLoginAuthUrl(pendingZkLoginContext.nonce, provider);
                        jwt = await openOAuthPopup(authUrl);

                        const { ZkLogin } = window.SuiSDK;
                        if (!ZkLogin) {
                            throw new Error('ZkLogin utilities unavailable in SDK bundle');
                        }

                        const clientId = getClientIdForProvider(provider);
                        decodedJwt = await validateZkLoginJwt(jwt, pendingZkLoginContext.nonce, clientId);
                        logOutput(`${providerName} identity token verified.`);

                        // Get password for storing new claims
                        logOutput('ðŸ”‘ OAuth completed. Please set a password to secure your identity.');
                        const password = await showPasswordPrompt({
                            providerLabel: ZKLOGIN_PROVIDERS[provider]?.name || 'zkLogin',
                            hasCache: false,
                            validator: async (value) => {
                                await validatePasswordForProvider(provider, value, { requireExistingEntry: false });
                            }
                        });

                        // OAUTH PATH: Store verified JWT in localStorage
                        await storeVerifiedJwt(password, jwt);

                        // Derive salt directly from password + claims (no additional prompting)
                        salt = await deriveSaltFromClaims(password, decodedJwt);
                        logOutput(`âœ… ${providerName} identity stored for future use`);
                    } else if (error.message === 'Invalid password') {
                        logOutput('âŒ Invalid password. Please try again.');
                        throw error;
                    } else {
                        logOutput('âŒ Smart zkLogin failed: ' + error.message, true);
                        throw error;
                    }
                }

                // Convert salt to BigInt for SDK compatibility
                const BN254_FIELD_MODULUS = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617');
                const saltHex = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 62);
                const saltBigInt = BigInt('0x' + saltHex) % BN254_FIELD_MODULUS;

                const suiAddress = window.SuiSDK.ZkLogin.jwtToAddress(jwt, saltBigInt, false);
                let addressSeed = window.SuiSDK.ZkLogin.genAddressSeed(saltBigInt, 'sub', decodedJwt.sub, decodedJwt.aud);
                let publicIdentifier = window.SuiSDK.ZkLogin.toZkLoginPublicIdentifier(addressSeed, decodedJwt.iss, { legacyAddress: false });

                // Prepare epoch and randomness values
                const signatureMaxEpoch = pendingZkLoginContext?.maxEpoch ?? null;
                let randomnessValue = '';
                if (pendingZkLoginContext && pendingZkLoginContext.randomness !== undefined && pendingZkLoginContext.randomness !== null) {
                    randomnessValue = typeof pendingZkLoginContext.randomness === 'bigint'
                        ? pendingZkLoginContext.randomness.toString()
                        : String(pendingZkLoginContext.randomness);
                }

                // Establish wallet connection
                const ephemeralKeyPair = pendingZkLoginContext?.ephemeralKeyPair || null;
                const publicKeyBase64 = ephemeralKeyPair?.getPublicKey?.()?.toBase64?.() || null;

                currentWallet = {
                    address: suiAddress,
                    type: 'zkLogin',
                    provider: mapIssuerToProvider(decodedJwt.iss),
                    zkLogin: {
                        jwt,
                        payload: decodedJwt,
                        salt: saltBigInt.toString(),
                        addressSeed: addressSeed.toString(),
                        publicIdentifier: publicIdentifier.toBase64(),
                        publicKey: publicKeyBase64,
                        nonce: pendingZkLoginContext?.nonce ?? null,
                        randomness: randomnessValue,
                        maxEpoch: signatureMaxEpoch,
                        ephemeralPublicKey: pendingZkLoginContext?.extendedPublicKey ?? null,
                        connectedAt: Date.now(),
                        expiresAt: pendingZkLoginContext?.expiresAt || null,
                        signatureInputs: null, // Will be set after proof generation
                        prover: null, // Will be set after proof generation
                        ephemeralKeyPair: ephemeralKeyPair,
                        identityHash: null,
                        hasEncryptedProof: false,
                        canSign: false, // Will be set to true after successful proof generation
                        addressSeed: null,
                        intentHash: null,
                        addressCommitment: null,
                        zkProof: null,
                        fromCache
                    }
                };

                connectedWalletStandard = null;
                showCurrentWalletAddress(suiAddress);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `zkLogin (${currentWallet.provider})`;
                logOutput(`zkLogin wallet connected (${formatAddressShort(suiAddress)}).`);
                await getWalletBalance();

                const proofStart = typeof performance !== 'undefined' ? performance.now() : Date.now();
                try {
                    logOutput('âš™ï¸ Generating zkLogin signature...');
                    const helperSource = window.ZkLoginHelpers || {};
                    const generateZkLoginSignature = helperSource.generateZkLoginSignature || window.generateZkLoginSignature;

                    if (typeof generateZkLoginSignature !== 'function') {
                        throw new Error('generateZkLoginSignature helper is unavailable');
                    }

                    // Create test intent for proof generation
                    const testIntent = {
                        type: 'personal_message',
                        data: 'zkLogin proof generation test'
                    };

                    const signatureResult = await generateZkLoginSignature(provider, testIntent, currentWallet.zkLogin.ephemeralKeyPair);
                    const proofEnd = typeof performance !== 'undefined' ? performance.now() : Date.now();
                    const proofMs = Math.max(1, Math.round(proofEnd - proofStart));

                    currentWallet.zkLogin.zkLoginSignature = signatureResult.zkLoginSignature;
                    currentWallet.zkLogin.address = signatureResult.address;
                    currentWallet.zkLogin.maxEpoch = signatureResult.maxEpoch;
                    currentWallet.zkLogin.addressSeed = signatureResult.addressSeed;
                    currentWallet.zkLogin.intentHash = signatureResult.intentHash;
                    currentWallet.zkLogin.addressCommitment = signatureResult.addressCommitment;
                    currentWallet.zkLogin.zkProof = signatureResult.zkProof;
                    currentWallet.zkLogin.canSign = true;
                    logOutput(`âœ… zkLogin signature generated (${proofMs}ms).`);

                    if (signatureResult.zkProof) {
                        try {
                            const proofOutput = JSON.stringify(signatureResult.zkProof, null, 2);
                            logOutput(`ðŸ“„ zkProof:\n${proofOutput}`);
                        } catch (proofFormatError) {
                            console.warn('Failed to stringify zkProof for log output', proofFormatError, signatureResult.zkProof);
                            logOutput('ðŸ“„ zkProof generated (unable to serialize for display).');
                        }
                    }
                } catch (proofError) {
                    const proofEnd = typeof performance !== 'undefined' ? performance.now() : Date.now();
                    const proofMs = Math.max(1, Math.round(proofEnd - proofStart));
                    logOutput(`âŒ Failed to generate zkLogin proof after ${proofMs}ms: ${proofError?.message || proofError}`, true);
                    console.warn('zkLogin proof generation failed:', proofError);
                }

                try {
                    await findMyWallets();
                } catch (e) {
                    // Ignore errors in findMyWallets
                }

            } catch (error) {
                logOutput('zkLogin connection failed: ' + error.message, true);
                throw error;
            } finally {
                pendingZkLoginContext = null;
            }
        }

        async function restoreZkLoginFromSession(provider = 'google') {
            try {
                const providerName = ZKLOGIN_PROVIDERS[provider]?.name || provider;
                logOutput(`ðŸ” Checking for cached zkLogin identity...`);

                // Use the same smart zkLogin flow for restoration
                await ensureZkLoginHelpers();

                // zkLogin helpers are already injected globally

                setPasswordPromptFunction(async (iss) => {
                    const providerSlug = issuerToProviderSlug(iss);
                    const providerLabel = providerSlug
                        ? (ZKLOGIN_PROVIDERS[providerSlug]?.name || mapIssuerToProvider(iss))
                        : mapIssuerToProvider(iss);
                    const hasCache = providerSlug ? hasStoredZkLogin(providerSlug) : false;

                    const validator = providerSlug
                        ? async (password) => {
                            await validatePasswordForProvider(providerSlug, password, { requireExistingEntry: hasCache });
                        }
                        : undefined;

                    return await showPasswordPrompt({
                        providerLabel,
                        hasCache,
                        validator
                    });
                });

                try {

                    // Try to restore using cached claims (this will prompt for password once)
                    await initiateSmartZkLogin(provider);
                    logOutput(`âœ… Restored from cached ${providerName} identity`);

                    // CACHE PATH: Get salt and JWT from cached data (uses cached password key)
                    const salt = await getSaltForClaims();
                    const jwt = await loadJwt(provider); // Load actual JWT
                    const cachedClaims = window.SuiSDK.ZkLogin.decodeJwt(jwt); // Use official Sui SDK function

                    // Convert salt to BigInt for SDK compatibility
                    const BN254_FIELD_MODULUS = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617');
                    const saltHex = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 62);
                    const saltBigInt = BigInt('0x' + saltHex) % BN254_FIELD_MODULUS;

                    const suiAddress = window.SuiSDK.ZkLogin.jwtToAddress(jwt, saltBigInt, false);
                    let addressSeed = window.SuiSDK.ZkLogin.genAddressSeed(saltBigInt, 'sub', cachedClaims.sub, cachedClaims.aud);
                    let publicIdentifier = window.SuiSDK.ZkLogin.toZkLoginPublicIdentifier(addressSeed, cachedClaims.iss, { legacyAddress: false });

                    // Set up wallet state
                    currentWallet = {
                        address: suiAddress,
                        type: 'zkLogin',
                        provider: mapIssuerToProvider(cachedClaims.iss),
                        zkLogin: {
                            jwt,
                            payload: cachedClaims,
                            salt: saltBigInt.toString(),
                            addressSeed: addressSeed.toString(),
                            publicIdentifier: publicIdentifier.toBase64(),
                            publicKey: null,
                            nonce: null,
                            randomness: '',
                            maxEpoch: null,
                            ephemeralPublicKey: null,
                            connectedAt: Date.now(),
                            expiresAt: null,
                            signatureInputs: null,
                            prover: null,
                            ephemeralKeyPair: null,
                            identityHash: null,
                            canSign: true, // Enable signing since we have valid cached claims
                            hasEncryptedProof: false,
                            intentHash: null,
                            addressCommitment: null,
                            zkProof: null,
                            fromCache: true
                        }
                    };

                    connectedWalletStandard = null;
                    showCurrentWalletAddress(suiAddress);
                    document.getElementById('walletInfo').style.display = 'block';
                    updateWalletConnectionControls(true);
                    document.getElementById('walletType').textContent = `zkLogin (${currentWallet.provider} - restored)`;

                    logOutput('ðŸ” zkLogin identity restored from cache');
                    logOutput(`ðŸŽ‰ Reconnected as ${formatAddressShort(suiAddress)}`);

                    await getWalletBalance();
                    try {
                        await findMyWallets();
                    } catch (e) {
                        // Ignore errors in findMyWallets
                    }

                    return true;

                } catch (error) {
                    if (error.message.includes('OAUTH_REQUIRED')) {
                        // No cached claims available
                        logOutput('No cached zkLogin identity found');
                        return false;
                    } else if (error.message === 'Invalid password') {
                        // User cancelled password prompt or entered wrong password
                        logOutput('Password required for cached identity');
                        return false;
                    } else {
                        logOutput('âš ï¸ Error restoring cached identity: ' + error.message, false);
                        return false;
                    }
                }

            } catch (error) {
                logOutput('Failed to restore zkLogin: ' + error.message, true);
                return false;
            }
        }

        function toggleZkLoginProviders(event, walletIndex) {
            event.stopPropagation();
            const dropdown = document.getElementById('zkloginDropdown' + walletIndex);
            if (!dropdown) return;

            // Close any other open dropdowns
            const allDropdowns = document.querySelectorAll('.zklogin-dropdown');
            allDropdowns.forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });

            // Toggle current dropdown
            dropdown.classList.toggle('visible');

            // Close dropdown when clicking outside
            const closeHandler = (e) => {
                if (!dropdown.contains(e.target) && !e.target.closest('.wallet-card')) {
                    dropdown.classList.remove('visible');
                    document.removeEventListener('click', closeHandler);
                }
            };

            if (dropdown.classList.contains('visible')) {
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            }
        }

        // Helper function to ensure SDK tier is loaded
        async function ensureSDKTier(tier, description) {
            if (!window.SuiSDK) {
                throw new Error('SuiSDK not available');
            }

            if (window.SuiSDK._loading && window.SuiSDK._loading[tier]) {
                logOutput(`â³ Waiting for ${description} to finish loading...`);
            }

            const startTime = Date.now();
            let loaded = false;

            if (tier === 'core' && !window.SuiSDK.Sui.SuiClient) {
                await window.SuiSDK.loadCore();
                loaded = true;
            } else if (tier === 'transaction' && (
                !window.SuiSDK.Sui.Ed25519Keypair ||
                typeof window.SuiSDK.Sui.Ed25519Keypair.generate !== 'function'
            )) {
                await window.SuiSDK.loadTransaction();
                loaded = true;
            } else if (tier === 'advanced' && (
                typeof window.SuiSDK.ZkLogin?.generateNonce !== 'function' ||
                typeof window.SuiSDK.ZkLogin?.getExtendedEphemeralPublicKey !== 'function'
            )) {
                await window.SuiSDK.loadAdvanced();
                loaded = true;
            }

            if (loaded) {
                const duration = Date.now() - startTime;
                logOutput(`âœ… ${description} loaded in ${duration}ms`);
            }
        }

        async function connectZkLoginProvider(provider) {
            try {
                // Ensure advanced SDK tier is loaded for zkLogin
                await ensureSDKTier('advanced', 'zkLogin support');

                // Ensure zkLogin helpers are loaded (should already be loaded in background)
                if (!window.__zkLoginHelpersLoaded__) {
                    const startTime = Date.now();
                    try {
                        await window.loadZkLoginHelpers();
                        const duration = Date.now() - startTime;
                        logOutput(`âœ… zkLogin helpers loaded in ${duration}ms`);
                    } catch (error) {
                        logOutput('âŒ Failed to load zkLogin helpers: ' + error.message);
                        return;
                    }
                }

                // Close all dropdowns
                document.querySelectorAll('.zklogin-dropdown').forEach(d => d.classList.remove('visible'));

                // Close wallet modal
                closeWalletModal();

                // All providers use the same zkLogin flow
                await handleZkLoginConnect(provider);
            } catch (error) {
                logOutput('zkLogin provider connection failed: ' + error.message, true);
            }
        }

        function buildPrimaryWalletEntries() {
            const entries = [
                {
                    type: 'custom',
                    action: 'zkLogin',
                    name: 'zkLogin',
                    icon: makeWalletIcon('ZK', '#6c4bcc')
                },
                {
                    type: 'custom',
                    action: 'passkey',
                    name: 'Passkey (Preview)',
                    icon: window.__SMARTWALLET_PASSKEY_ICON__ || makeWalletIcon('PK', '#1c858f')
                },
                {
                    type: 'custom',
                    action: 'browserWallet',
                    name: 'Browser Wallet',
                    icon: makeWalletIcon('BW', '#5a7cff')
                }
            ];

            return entries;
        }

        function getWalletIconForEntry(entry) {
            try {
                if (entry && typeof entry.icon === 'string') {
                    return entry.icon;
                }

                const wallet = entry && entry.wallet ? entry.wallet : null;
                const iconCandidates = [];
                if (wallet) {
                    if (typeof wallet.icon === 'string') iconCandidates.push(wallet.icon);
                    if (Array.isArray(wallet.icons)) {
                        for (const icon of wallet.icons) {
                            if (!icon) continue;
                            if (typeof icon === 'string') {
                                iconCandidates.push(icon);
                            } else if (typeof icon.url === 'string') {
                                iconCandidates.push(icon.url);
                            } else if (typeof icon.src === 'string') {
                                iconCandidates.push(icon.src);
                            } else if (typeof icon.data === 'string') {
                                iconCandidates.push(icon.data);
                            }
                        }
                    }
                }
                const dataIcon = iconCandidates.find(src => typeof src === 'string' && src.startsWith('data:image'));
                if (dataIcon) return dataIcon;
                const urlIcon = iconCandidates.find(src => typeof src === 'string');
                if (urlIcon) return urlIcon;

                return null;
            } catch (_) {
                return null;
            }
        }


        function updateWalletConnectionControls(isConnected) {
            try {
                const controls = document.getElementById('walletConnectionControls');
                const statusEl = document.getElementById('walletConnectionStatus');
                const infoPanel = document.getElementById('walletInfo');
                const actionBtn = document.getElementById('walletHeaderAction');
                const viewToggleBtn = document.getElementById('viewOnlyToggleButton');
                const viewOnlyForm = document.getElementById('viewOnlyForm');
                const isWalletConnectionActive = isConnected && currentWallet?.type !== 'view_only';

                if (statusEl) {
                    let statusText = isConnected ? 'Connected' : 'Not connected';
                    if (isConnected && currentWallet?.type === 'view_only') {
                        statusText = 'Viewing address';
                    } else if (!isConnected) {
                        statusText = 'Not viewing';
                    }
                    statusEl.textContent = statusText;
                }

                if (actionBtn) {
                    if (isWalletConnectionActive) {
                        actionBtn.textContent = 'Disconnect';
                        actionBtn.classList.add('disconnect');
                        actionBtn.onclick = () => disconnectWallet();
                    } else {
                        actionBtn.textContent = 'Connect';
                        actionBtn.classList.remove('disconnect');
                        actionBtn.onclick = () => connectWalletStandard();
                    }
                }

                if (viewToggleBtn) {
                    const isOpen = controls && controls.dataset.open === 'true';
                    viewToggleBtn.style.display = isWalletConnectionActive ? 'none' : '';
                    viewToggleBtn.setAttribute('aria-expanded', !isWalletConnectionActive && isOpen ? 'true' : 'false');
                }

                if (!controls) {
                    return;
                }

                let connectionState = 'false';
                if (isConnected) {
                    connectionState = currentWallet?.type === 'view_only' ? 'view' : 'true';
                }
                controls.dataset.connected = connectionState;

                const isWalletConnection = connectionState === 'true';
                const isOpen = controls.dataset.open === 'true';

                if (isWalletConnection) {
                    controls.style.display = 'none';
                    controls.dataset.open = 'false';
                    if (viewOnlyForm) {
                        viewOnlyForm.style.display = 'none';
                    }
                    if (viewToggleBtn) {
                        viewToggleBtn.setAttribute('aria-expanded', 'false');
                    }
                } else {
                    controls.style.display = isOpen ? '' : 'none';
                    if (viewOnlyForm) {
                        viewOnlyForm.style.display = isOpen ? 'block' : 'none';
                    }
                }

                if (infoPanel) {
                    if (isConnected) {
                        infoPanel.style.display = 'block';
                    } else {
                        infoPanel.style.display = 'none';
                    }
                }
            } catch (_) {}
        }

        async function resolveViewOnlyTarget(value) {
            const raw = (value || '').trim();
            if (!raw) {
                throw new Error('Enter a Sui address (0x...) or SuiNS name (example.sui).');
            }

            const { normalized } = normalizeAddressForDisplay(raw);
            if (normalized && HEX_ADDRESS_RE.test(normalized)) {
                return { address: normalized, source: 'address' };
            }

            const lower = raw.toLowerCase();
            const utils = window.SuiSDK?.Utils || {};
            const normalizeSuinsTarget = typeof utils.normalizeSuinsTarget === 'function' ? utils.normalizeSuinsTarget : null;
            const validateSuinsName = typeof utils.isValidSuinsName === 'function' ? utils.isValidSuinsName : null;

            let suinsTarget = normalizeSuinsTarget ? normalizeSuinsTarget(lower) : lower;

            if (!validateSuinsName?.(suinsTarget) && !SUINS_NAME_RE.test(suinsTarget || '')) {
                throw new Error('Invalid input. Provide a valid Sui address (0x...) or a SuiNS name ending in .sui');
            }

            if (!suiClient) {
                await initializeSuiClient();
            }

            if (!suiClient || typeof suiClient.resolveNameServiceAddress !== 'function') {
                throw new Error('SuiNS resolution is not available in this SDK build.');
            }

            try {
                const targetToResolve = suinsTarget || lower;
                const result = await suiClient.resolveNameServiceAddress({ name: targetToResolve });
                let resolved = '';
                if (typeof result === 'string') {
                    resolved = result;
                } else if (result && typeof result === 'object') {
                    if (typeof result.address === 'string') resolved = result.address;
                    else if (typeof result.Address === 'string') resolved = result.Address;
                    else if (typeof result.value === 'string') resolved = result.value;
                    else if (result.data) {
                        if (typeof result.data === 'string') {
                            resolved = result.data;
                        } else if (typeof result.data === 'object' && typeof result.data.address === 'string') {
                            resolved = result.data.address;
                        }
                    }
                }

                const { normalized: resolvedAddress } = normalizeAddressForDisplay(resolved);
                if (!resolvedAddress || !HEX_ADDRESS_RE.test(resolvedAddress)) {
                    throw new Error(`No Sui address found for ${targetToResolve}`);
                }

                return { address: resolvedAddress, source: 'suins', name: targetToResolve };
            } catch (error) {
                const targetToResolve = suinsTarget || lower;
                throw new Error(`Failed to resolve ${targetToResolve}: ${error.message}`);
            }
        }

        async function copyText(value) {
            if (!value) return;
            if (navigator.clipboard?.writeText) {
                return navigator.clipboard.writeText(value);
            }
            const textarea = document.createElement('textarea');
            textarea.value = value;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try {
                document.execCommand('copy');
            } finally {
                document.body.removeChild(textarea);
            }
        }

        function setupCopyButtons() {
            const buttons = document.querySelectorAll('.copy-btn');
            buttons.forEach(button => {
                if (button.dataset.copySetup === 'done') return;
                button.dataset.copySetup = 'done';
                if (!button.dataset.copyLabel) {
                    button.dataset.copyLabel = button.textContent.trim() || 'Copy';
                }
                const targetId = button.dataset.copyTarget;
                const targetEl = targetId ? document.getElementById(targetId) : null;
                const allowAny = button.dataset.copyAllowAny === 'true';
                const getValue = () => {
                    if (button.dataset.copyValue !== undefined) {
                        return (button.dataset.copyValue || '').trim();
                    }
                    return targetEl ? targetEl.textContent.trim() : '';
                };
                if (!targetEl && button.dataset.copyValue === undefined) {
                    button.disabled = true;
                    return;
                }
                const updateState = () => {
                    const value = getValue();
                    button.disabled = allowAny ? !value : !HEX_ADDRESS_RE.test(value);
                };
                button.addEventListener('click', async () => {
                    const value = getValue();
                    if (!value) return;
                    if (!allowAny && !HEX_ADDRESS_RE.test(value)) return;
                    try {
                        await copyText(value);
                        button.dataset.copied = 'true';
                        button.textContent = 'Copied âœ“';
                        setTimeout(() => {
                            button.textContent = button.dataset.copyLabel || 'Copy';
                            delete button.dataset.copied;
                        }, 1200);
                    } catch (error) {
                        console.warn('Copy failed', error);
                    }
                });
                if (targetEl) {
                    const observer = new MutationObserver(updateState);
                    observer.observe(targetEl, { subtree: true, childList: true, characterData: true });
                }
                updateState();
            });
        }

        if (typeof window !== 'undefined') {
            if (typeof window.requestIdleCallback === 'function') {
                window.requestIdleCallback(() => setupCopyButtons(), { timeout: 500 });
            } else {
                window.addEventListener('DOMContentLoaded', () => setTimeout(setupCopyButtons, 0));
            }
        }

        // Optimized SDK loading - check synchronously first, then wait only if needed
        // PERFORMANCE: This prevents blocking the UI thread during SDK initialization
        // - Fast path: Immediate return if SDK already loaded (production builds)
        // - Timeout: Prevents infinite waiting if SDK fails to load
        // - Caching: Reuses existing promise if already waiting
        function waitForSDKs() {
            // Fast path: SDK already available (production build)
            if (window.SuiSDK) {
                return Promise.resolve();
            }

            // Check if we're already waiting
            if (sdkReadyPromise) {
                return sdkReadyPromise;
            }

            // Create promise with timeout to avoid infinite waiting
            sdkReadyPromise = new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50; // Max 4 seconds (50 * 80ms)

                const poll = () => {
                    attempts++;

                    if (window.SuiSDK) {
                        resolve();
                        return;
                    }

                    if (attempts >= maxAttempts) {
                        reject(new Error('SDK failed to load within timeout'));
                        return;
                    }

                    setTimeout(poll, 80);
                };

                // Start polling
                poll();
            });

            return sdkReadyPromise;
        }

        function logOutput(message, isError = false) {
            const output = document.getElementById('output');
            const prefix = isError ? '[ERROR]' : '[INFO]';
            const line = isError ? `\n${prefix} ${message}` : `${prefix} ${message}`;
            output.textContent += `${line}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function normalizeAddressForDisplay(value) {
            if (!value && value !== 0) {
                return { normalized: '', display: '' };
            }
            const str = String(value).trim();
            if (!str) {
                return { normalized: '', display: '' };
            }
            if (HEX_STRING_RE.test(str)) {
                try {
                    const normalizer = window.SuiSDK?.Sui?.normalizeSuiAddress;
                    if (typeof normalizer === 'function') {
                        const normalized = normalizer(str.startsWith('0x') ? str : `0x${str}`);
                        return { normalized, display: normalized };
                    }
                } catch (_) {}
                const lower = str.startsWith('0x') ? str.toLowerCase() : `0x${str.toLowerCase()}`;
                return { normalized: lower, display: lower };
            }
            return { normalized: '', display: str };
        }

        function setCurrentWalletNameDisplay(name) {
            try {
                const container = document.getElementById('walletSuinsName');
                const valueEl = document.getElementById('walletSuinsValue');
                if (!container || !valueEl) return;
                if (name) {
                    valueEl.textContent = name;
                    container.style.display = 'inline-flex';
                } else {
                    valueEl.textContent = '';
                    container.style.display = 'none';
                }
            } catch (_) {}
        }

        async function resolveSuinsReverse(address, { silent = true } = {}) {
            const { normalized } = normalizeAddressForDisplay(address);
            if (!normalized) return null;
            const cacheKey = `${currentNetwork}:${normalized}`;
            if (suinsReverseCache.has(cacheKey)) {
                return suinsReverseCache.get(cacheKey);
            }

            try {
                if (!suiClient) {
                    await initializeSuiClient();
                }
                if (!suiClient?.resolveNameServiceNames) {
                    suinsReverseCache.set(cacheKey, null);
                    return null;
                }
                const response = await suiClient.resolveNameServiceNames({ address: normalized, limit: 5 });
                const names = Array.isArray(response?.data) ? response.data : [];
                const name = names.length ? names[0] : null;
                suinsReverseCache.set(cacheKey, name);
                return name;
            } catch (error) {
                suinsReverseCache.set(cacheKey, null);
                if (!silent) logOutput('Reverse SuiNS lookup failed: ' + error.message, true);
                return null;
            }
        }

        function showCurrentWalletAddress(address, { skipReverse = false } = {}) {
            const { normalized, display } = normalizeAddressForDisplay(address);
            const text = normalized || display;
            try {
                const addressEl = document.getElementById('currentAddress');
                if (addressEl) {
                    addressEl.textContent = text || '';
                }
                const copyBtn = document.querySelector('.copy-btn[data-copy-target="currentAddress"]');
                if (copyBtn) {
                    if (normalized) {
                        copyBtn.dataset.copyValue = normalized;
                        copyBtn.dataset.copyAllowAny = 'false';
                    } else {
                        copyBtn.dataset.copyValue = text || '';
                        copyBtn.dataset.copyAllowAny = 'true';
                    }
                    const value = copyBtn.dataset.copyValue || '';
                    const allowAny = copyBtn.dataset.copyAllowAny === 'true';
                    copyBtn.disabled = allowAny ? !value : !HEX_ADDRESS_RE.test(value);
                }
            } catch (_) {}

            if (!normalized) {
                currentReverseLookupToken += 1;
                setCurrentWalletNameDisplay(null);
                return;
            }

            if (skipReverse) return;

            const lookupToken = ++currentReverseLookupToken;
            setCurrentWalletNameDisplay(null);
            resolveSuinsReverse(normalized, { silent: true }).then(name => {
                if (lookupToken !== currentReverseLookupToken) return;
                setCurrentWalletNameDisplay(name);
            }).catch(() => {
                if (lookupToken !== currentReverseLookupToken) return;
                setCurrentWalletNameDisplay(null);
            });
        }

        // Initialize Sui client - optimized for performance
        async function initializeSuiClient() {
            if (suiClient) return suiClient;

            // Ensure core SDK tier is loaded for network connection
            await ensureSDKTier('core', 'network connection');

            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl } = window.SuiSDK.Sui;
            suiClient = new SuiClient({ url: getFullnodeUrl(currentNetwork) });
            try {
                window.SuiSDK.client = suiClient;
            } catch (_) {}
            logOutput(`Connected to Sui ${currentNetwork} network`);
            return suiClient;
        }

        async function ensureSdkReady() {
            await waitForSDKs();
            return initializeSuiClient();
        }

        function scheduleBootstrapWork() {
            if (bootstrapPromise) {
                return bootstrapPromise;
            }

            const runBootstrap = async () => {
                try {
                    await ensureSdkReady();
                    // Preload advanced tier for zkLogin after basic connection is ready
                    ensureSDKTier('advanced', 'zkLogin support').catch(err =>
                        console.warn('Advanced tier preload failed:', err.message)
                    );
                } catch (error) {
                    logOutput('Failed to initialize SDK: ' + error.message, true);
                    return;
                }


                // zkLogin restoration is now on-demand when user selects provider
                // No automatic restoration on page load
            };

            if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {
                bootstrapPromise = new Promise((resolve) => {
                    window.requestIdleCallback(() => {
                        runBootstrap().finally(resolve);
                    }, { timeout: 1200 });
                });
            } else {
                bootstrapPromise = new Promise((resolve) => {
                    setTimeout(() => {
                        runBootstrap().finally(resolve);
                    }, 120);
                });
            }

            return bootstrapPromise;
        }


        async function createOrImportWallet({ name, rawPrivateKey, password, confirmPassword }) {
            const trimmedName = (name || '').trim();
            if (!trimmedName) {
                throw new Error('Please enter a wallet name');
            }

            if (!password || password.length < 8) {
                throw new Error('Password must be at least 8 characters long');
            }

            if (password !== confirmPassword) {
                throw new Error('Passwords do not match');
            }

            const existingWallets = getStoredWallets();
            if (existingWallets.some(w => w.name === trimmedName)) {
                throw new Error('A wallet with this name already exists');
            }

            await ensureSdkReady();

            const normalizedPrivateKey = (rawPrivateKey || '').trim().replace(/\s+/g, '');
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            let keypair;
            let secretForStorage;
            let actionLabel;

            if (normalizedPrivateKey) {
                logOutput('Importing wallet...');
                try {
                    keypair = Ed25519Keypair.fromSecretKey(normalizedPrivateKey);
                } catch (error) {
                    throw new Error('Invalid private key format. Please verify and try again.');
                }
                secretForStorage = normalizedPrivateKey;
                actionLabel = 'imported';
            } else {
                logOutput('Creating new wallet...');
                keypair = Ed25519Keypair.generate();
                secretForStorage = keypair.getSecretKey();
                actionLabel = 'created';
            }

            const address = keypair.toSuiAddress();
            const encryptedPrivateKey = await encryptPrivateKey(secretForStorage, password);

            saveWallet(trimmedName, encryptedPrivateKey, address);

            currentWallet = { address, keypair, type: 'traditional', name: trimmedName };
            showCurrentWalletAddress(address);
            document.getElementById('walletInfo').style.display = 'block';
            updateWalletConnectionControls(true);

            logOutput(`Wallet "${trimmedName}" ${actionLabel} successfully!`);
            logOutput(`Address: ${address}`);
            await getWalletBalance();

            return { actionLabel, address };
        }

        async function handleCreateWalletForm(walletIndex) {
            const nameInput = document.getElementById('createWalletName');
            const privateKeyInput = document.getElementById('createWalletPrivateKey');
            const passwordInput = document.getElementById('createWalletPassword');
            const confirmInput = document.getElementById('createWalletConfirmPassword');

            if (!nameInput || !passwordInput || !confirmInput) {
                alert('Form inputs not found');
                return;
            }

            try {
                await createOrImportWallet({
                    name: nameInput.value,
                    rawPrivateKey: privateKeyInput ? privateKeyInput.value : '',
                    password: passwordInput.value,
                    confirmPassword: confirmInput.value
                });

                // Close the dropdown
                const dropdown = document.getElementById('traditionalDropdown' + walletIndex);
                if (dropdown) {
                    dropdown.classList.remove('visible');
                }

                // Close the wallet modal
                closeWalletModal();
            } catch (error) {
                logOutput('Error creating or importing wallet: ' + error.message, true);
                alert('Error creating or importing wallet: ' + error.message);
            }
        }

        async function getWalletBalance() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            try {
                if (!suiClient) {
                    await initializeSuiClient();
                }
                const balance = await suiClient.getBalance({ owner: currentWallet.address });
                const suiBalance = Number(balance.totalBalance) / 1_000_000_000;
                document.getElementById('currentBalance').textContent = `${suiBalance} SUI`;
            } catch (error) {
                logOutput('Error getting balance: ' + error.message, true);
            }
        }

        // Wait for wallet extensions to load
        function waitForWalletExtensions(timeout = 3000) {
            return new Promise((resolve) => {
                const startTime = Date.now();
                const checkWallets = () => {
                    const walletFound = window.sui || window.suiWallet || window.ethos || window.slush || 
                                      (window.suiWallet && window.suiWallet.getWallets) ||
                                      Object.keys(window).some(key => key.toLowerCase().includes('sui'));
                    
                    if (walletFound || Date.now() - startTime > timeout) {
                        resolve(walletFound);
                    } else {
                        setTimeout(checkWallets, 100);
                    }
                };
                checkWallets();
            });
        }

        // Proper Sui Wallet Standard Connection using @mysten/wallet-standard
        async function connectWalletStandard() {
            try {
                await ensureSdkReady();
                
                // Wait for extensions to load
                await waitForWalletExtensions();
                
                // Method 1: Use @mysten/wallet-standard from SuiSDK bundle
                if (typeof window !== 'undefined' && window.SuiSDK) {
                    // Check for @mysten/wallet-standard in the SuiSDK bundle
                    if (window.SuiSDK.WalletStandard) {
                        try {
                            // Use proper Mysten wallet standard
                            const { getWallets } = window.SuiSDK.WalletStandard;
                            const walletsApi = getWallets();
                            const allWallets = walletsApi.get();
                            
                            // Filter for Sui-compatible wallets only
                            const suiWallets = allWallets.filter(wallet => {
                                // Check for Sui chains first (most reliable)
                                const supportsSui = wallet.chains && wallet.chains.some(chain =>
                                    chain.includes('sui:') || chain === 'sui'
                                );

                                // Check for Sui-specific features
                                const hasSuiConnect = wallet.features && (
                                    wallet.features['sui:connect'] ||
                                    wallet.features['sui:signAndExecuteTransaction']
                                );

                                // Only include if it explicitly supports Sui chains OR has Sui-specific features
                                // Exclude wallets that only have generic 'standard:connect' without Sui chain support
                                return supportsSui || hasSuiConnect;
                            });
                            
                                        openWalletModal(suiWallets);
                            return; // Stop here; user will choose a wallet
                        } catch (sdkError) {
                            logOutput('Mysten Wallet Standard detection failed: ' + sdkError.message, true);
                        }
                    }
                    
                    // Method 2: Direct window.sui detection (proper approach)
                    if (window.sui) {
                        logOutput('Found window.sui, attempting proper connection...');
                        try {
                            // Use the standard connection flow
                        const connectFeature = window.sui.features && window.sui.features['standard:connect'];
                        if (!connectFeature || typeof connectFeature.connect !== 'function') {
                            throw new Error('window.sui does not expose standard:connect. Please update the wallet.');
                        }

                        logOutput('Using standard:connect feature...');
                        await connectFeature.connect();

                        const accounts = connectFeature.accounts || (typeof connectFeature.getAccounts === 'function'
                            ? await connectFeature.getAccounts()
                            : []);

                        if (!accounts || !accounts.length) {
                            throw new Error('No accounts returned via standard:connect.');
                        }

                        const account = accounts[0];
                        currentWallet = {
                            address: account.address,
                            type: 'wallet_standard',
                            wallet: window.sui
                        };
                        connectedWalletStandard = window.sui;

                        showCurrentWalletAddress(account.address);
                        document.getElementById('walletInfo').style.display = 'block';
                        updateWalletConnectionControls(true);
                        document.getElementById('walletType').textContent = 'Sui Wallet Standard';

                        logOutput('âœ… Successfully connected via window.sui!');
                        logOutput(`Address: ${account.address}`);
                        await getWalletBalance();
                        return;
                    } catch (suiError) {
                        logOutput('window.sui connection failed: ' + suiError.message, true);
                    }
                    }
                    
                    // Method 3: Check for wallet-specific globals
                    const knownWallets = ['suiWallet', 'ethos', 'slush', 'martian'];
                    for (const walletName of knownWallets) {
                        if (window[walletName]) {
                            logOutput(`Found ${walletName}, attempting connection...`);
                            try {
                                const wallet = window[walletName];
                                
                                // Try standard connect
                                if (wallet.features && wallet.features['standard:connect']) {
                                    await wallet.features['standard:connect'].connect();
                                    const accounts = wallet.features['standard:connect'].accounts;
                                    if (accounts && accounts.length > 0) {
                                        await handleSuccessfulConnection(accounts[0], wallet, walletName);
                                        return;
                                    }
                                } else {
                                    logOutput(`${walletName} does not expose wallet-standard connect features; skipping.`);
                                }
                            } catch (walletError) {
                                logOutput(`${walletName} connection failed: ${walletError.message}`, true);
                            }
                        }
                    }
                }
                
                logOutput('âŒ No compatible Sui wallets found', true);
                logOutput('Please ensure you have a Sui wallet extension installed (Slush, Sui Wallet, Ethos, etc.)', true);
                logOutput('After installing, please refresh the page and try again.', true);

            } catch (error) {
                logOutput('Wallet connection error: ' + error.message, true);
            }
        }
        
        // Helper function for successful wallet connection
        async function handleSuccessfulConnection(account, wallet, walletName) {
            currentWallet = {
                address: account.address,
                type: 'wallet_standard',
                wallet: wallet
            };
            connectedWalletStandard = wallet;

            showCurrentWalletAddress(account.address);
            document.getElementById('walletInfo').style.display = 'block';
            updateWalletConnectionControls(true);
            document.getElementById('walletType').textContent = walletName + ' Wallet';

            logOutput(`âœ… Connected to ${walletName}!`);
            logOutput(`Address: ${account.address}`);
            await getWalletBalance();

        }

        // Open modal with wallet selection (suiWallets are already filtered for Sui compatibility)
        function openWalletModal(suiWallets) {
            const overlay = document.getElementById('walletModal');
            const list = document.getElementById('walletModalList');
            if (!overlay || !list) return;
            
            // Start with the pre-filtered Sui wallets from @mysten/wallet-standard
            var entries = buildPrimaryWalletEntries();
            
            // Add wallet standard entries (already filtered for Sui compatibility)
            for (var i = 0; i < (suiWallets || []).length; i++) {
                var wallet = suiWallets[i];
                entries.push({ 
                    type: 'standard', 
                    wallet: wallet,
                    name: wallet.name || `${wallet.id || 'Wallet'} ${i + 1}`
                });
            }
            
            // Add fallback entries for directly injected providers (if not already in standard list)
            var fallbacks = [];
            if (window.sui) {
                // Check if this isn't already in the standard list
                var alreadyHasSui = entries.some(e => e.name && e.name.toLowerCase().includes('sui'));
                if (!alreadyHasSui) {
                    fallbacks.push({ 
                        type: 'windowSui', 
                        name: 'Sui Wallet (window.sui)'
                    });
                }
            }
            if (window.phantom && window.phantom.sui) {
                var alreadyHasPhantom = entries.some(e => e.name && e.name.toLowerCase().includes('phantom'));
                if (!alreadyHasPhantom) {
                    fallbacks.push({ 
                        type: 'phantomSui', 
                        name: 'Phantom (Sui)'
                    });
                }
            }
            
            // Add fallbacks to entries
            for (var fi = 0; fi < fallbacks.length; fi++) {
                entries.push(fallbacks[fi]);
            }

            window.availableSuiWallets = entries;

            var html = '';
            if (!entries.length) {
                html = '<p style="font-size: 13px; color: #a0b3c5;">No Sui wallets detected. Please install Slush, Sui Wallet, Ethos, or Phantom, then refresh this page.</p>';
            } else {
                for (var i = 0; i < entries.length; i++) {
                    var e = entries[i];
                    var name = e.name || (e.wallet && (e.wallet.name || e.wallet.id)) || `Wallet ${i + 1}`;
                    var iconSrc = getWalletIconForEntry(e);

                    var safeName = escapeHtml(name);
                    var safeIcon = escapeHtml(iconSrc);


                    // Special handling for zkLogin to show provider selection
                    if (e.type === 'custom' && e.action === 'zkLogin') {
                                html += '\n<div class="zklogin-providers">\n' +
                                '  <button type="button" class="wallet-card" onclick="toggleZkLoginProviders(event, ' + i + ')">\n' +
                                '    <div class="wallet-card-icon-wrap"><img src="' + IMAGE_PLACEHOLDER + '" data-src="' + safeIcon + '" alt="' + safeName + ' icon" class="wallet-card-icon" loading="lazy"></div>\n' +
                                '    <div class="wallet-card-content">\n' +
                                '      <div class="wallet-card-name">' + safeName + '</div>\n' +
                                '    </div>\n' +
                                '  </button>\n' +
                                '  <div class="zklogin-dropdown" id="zkloginDropdown' + i + '">\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'google\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.google.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Google</span>\n' +
                                '    </button>\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'facebook\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.facebook.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Meta</span>\n' +
                                '    </button>\n' +
                                '    <button type="button" class="zklogin-provider" onclick="connectZkLoginProvider(\'apple\')">\n' +
                                '      <div class="zklogin-provider-icon">' + ZKLOGIN_PROVIDERS.apple.icon + '</div>\n' +
                                '      <span class="zklogin-provider-name">Apple</span>\n' +
                                '    </button>\n' +
                                '  </div>\n' +
                                '</div>';
                    } else if (e.type === 'custom' && e.action === 'browserWallet') {
                        // Special handling for browser wallet to show create/unlock options
                        html += '\n<div class="traditional-providers">\n' +
                                '  <button type="button" class="wallet-card" onclick="toggleTraditionalWalletOptions(event, ' + i + ')">\n' +
                                '    <div class="wallet-card-icon-wrap"><img src="' + IMAGE_PLACEHOLDER + '" data-src="' + safeIcon + '" alt="' + safeName + ' icon" class="wallet-card-icon" loading="lazy"></div>\n' +
                                '    <div class="wallet-card-content">\n' +
                                '      <div class="wallet-card-name">' + safeName + '</div>\n' +
                                '    </div>\n' +
                                '  </button>\n' +
                                '  <div class="traditional-dropdown" id="traditionalDropdown' + i + '"></div>\n' +
                                '</div>';
                    } else {
                        // Add passkey-icon class for passkey entries to handle scaling
                        var iconClass = (e.type === 'custom' && e.action === 'passkey') ? 'wallet-card-icon passkey-icon' : 'wallet-card-icon';
                        html += '\n<button type="button" class="wallet-card" onclick="connectWalletByIndex(' + i + ')">\n' +
                                '  <div class="wallet-card-icon-wrap"><img src="' + IMAGE_PLACEHOLDER + '" data-src="' + safeIcon + '" alt="' + safeName + ' icon" class="' + iconClass + '" loading="lazy"></div>\n' +
                                '  <div class="wallet-card-content">\n' +
                                '    <div class="wallet-card-name">' + safeName + '</div>\n' +
                                '  </div>\n' +
                                '</button>';
                    }
                }
            }
            list.innerHTML = html;
            if (window.SuiSDK?.Utils?.lazyLoadImages) {
                try {
                    window.SuiSDK.Utils.lazyLoadImages();
                } catch (lazyError) {
                    console.warn('Lazy image loader failed:', lazyError);
                }
            }
            overlay.classList.add('visible');
            document.body.style.overflow = 'hidden';
            var closeBtn = document.getElementById('walletModalClose');
            if (closeBtn) try { closeBtn.focus(); } catch(e) {}
        }

        function closeWalletModal() {
            var overlay = document.getElementById('walletModal');
            if (!overlay) return;
            overlay.classList.remove('visible');
            document.body.style.overflow = '';
        }

        function toggleTraditionalWalletOptions(event, walletIndex) {
            event.stopPropagation();

            const dropdown = document.getElementById('traditionalDropdown' + walletIndex);

            if (!dropdown) {
                console.error('Dropdown element not found for walletIndex:', walletIndex);
                return;
            }

            // Close any other open dropdowns
            const allDropdowns = document.querySelectorAll('.traditional-dropdown');

            allDropdowns.forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });

            // Show the dropdown content based on whether wallets exist
            showTraditionalWalletOptions(dropdown, walletIndex);
        }

        function showTraditionalWalletOptions(dropdown, walletIndex) {
            // Always get fresh wallet list when showing options
            const storedWallets = getStoredWallets();

            // Always show the same dropdown structure
            showExistingWallets(dropdown, storedWallets, walletIndex);

            // Make sure the dropdown is visible
            dropdown.classList.add('visible');
        }

        function showExistingWallets(dropdown, storedWallets, walletIndex) {
            // Generate wallet list (empty if no wallets)
            const walletOptions = storedWallets.map(wallet => `
                <div class="wallet-item" style="display: flex; align-items: center; gap: 8px; padding: 2px 12px; margin: 0; border: none; background: transparent; color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; transition: background .2s ease;">
                    <button type="button" class="wallet-unlock-btn" onclick="unlockSpecificWallet('${wallet.name}'); closeAllTraditionalDropdowns();" style="display: flex; align-items: center; gap: 8px; border: none; background: transparent; color: #cfe4f7; cursor: pointer; flex: 1; text-align: left; max-width: calc(100%);">
                        <div class="traditional-provider-icon" style="background: #2e7d32; width: 20px; height: 20px; font-size: 9px; flex-shrink: 0;">UW</div>
                        <span class="traditional-provider-name" style="font-size: 18px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${wallet.name}</span>
                    </button>
                    <button type="button" class="wallet-delete-btn" onclick="deleteWalletAndRefresh('${wallet.name}', ${walletIndex})" style="border: none; background: transparent; color: #ff4444; cursor: pointer; padding: 4px; flex-shrink: 0; margin-left: 8px; margin-right: 24px;">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                        </svg>
                    </button>
                </div>
            `).join('');

            dropdown.innerHTML = `
                ${storedWallets.length > 0 ? `
                    <div class="existing-wallets-header" style="padding: 4px 12px; font-size: 16px; color: #cfe4f7; font-weight: 600; border-bottom: 1px solid rgba(69,139,189,.3); margin-bottom: 2px;">
                        Select wallet to unlock:
                    </div>
                    <div class="wallet-list" style="max-height: 120px; overflow-y: auto; width: 100%;">
                        ${walletOptions}
                    </div>
                    <div style="padding: 4px 10px; border-top: 1px solid rgba(69,139,189,.3); margin-top: 2px;">
                ` : `
                    <div style="padding: 8px 12px;">
                `}
                    <div class="create-wallet-container">
                        <button type="button" class="traditional-provider" onclick="toggleCreateWalletDropdown(${walletIndex});" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.08); color: #cfe4f7; cursor: pointer; width: 100%; text-align: left; font-size: 13px;">
                            <div class="traditional-provider-icon" style="background: #5a7cff; width: 20px; height: 20px; font-size: 9px; flex-shrink: 0;">CI</div>
                            <span class="traditional-provider-name" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">Create or Import Wallet</span>
                        </button>
                        <div class="create-wallet-dropdown" id="createWalletDropdown${walletIndex}">
                            <div class="traditional-provider-form" style="padding: 8px 12px;">
                                <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                                    <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Wallet Name:</label>
                                    <input type="text" id="createWalletName${walletIndex}" placeholder="Enter wallet name" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                                </div>
                                <div class="form-row" style="display: flex; flex-direction: column; align-items: stretch; margin-bottom: 8px; gap: 6px;">
                                    <label style="font-size: 10px; color: #cfe4f7; font-weight: 600;">Private Key (optional):</label>
                                    <textarea id="createWalletPrivateKey${walletIndex}" placeholder="Leave blank to generate a new key" style="font-size: 10px; padding: 6px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7; min-height: 60px; resize: vertical;"></textarea>
                                    <span style="font-size: 9px; color: rgba(207,228,247,0.7);">Paste a Base64 private key to import an existing wallet.</span>
                                </div>
                                <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                                    <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Password:</label>
                                    <input type="password" id="createWalletPassword${walletIndex}" placeholder="Min 8 characters" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                                </div>
                                <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                                    <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Confirm:</label>
                                    <input type="password" id="createWalletConfirmPassword${walletIndex}" placeholder="Confirm password" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                                </div>
                                <div class="form-actions" style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px;">
                                    <button type="button" onclick="closeCreateWalletDropdown(${walletIndex});" style="font-size: 10px; padding: 4px 8px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: transparent; color: #cfe4f7; cursor: pointer;">Cancel</button>
                                    <button type="button" onclick="handleCreateWalletFromDropdown(${walletIndex})" class="create-btn" style="font-size: 10px; padding: 4px 8px; border: none; border-radius: 4px; background: #5a7cff; color: white; cursor: pointer; font-weight: 600;">Continue</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            dropdown.classList.add('visible');
        }

        function showCreateWalletForm(dropdown, walletIndex) {
            if (!dropdown) {
                console.error('No dropdown element provided to showCreateWalletForm');
                return;
            }

            // Clear dropdown completely first and force a reflow
            dropdown.innerHTML = '';
            dropdown.className = 'traditional-dropdown visible';

            // Force DOM reflow before setting new content
            dropdown.offsetHeight;

            dropdown.innerHTML = `
                <div class="traditional-provider-form" id="createWalletForm" style="padding: 8px 12px; max-height: none;">
                    <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                        <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Wallet Name:</label>
                        <input type="text" id="createWalletName" placeholder="Enter wallet name" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                    </div>
                    <div class="form-row" style="display: flex; flex-direction: column; align-items: stretch; margin-bottom: 8px; gap: 6px;">
                        <label style="font-size: 10px; color: #cfe4f7; font-weight: 600;">Private Key (optional):</label>
                        <textarea id="createWalletPrivateKey" placeholder="Leave blank to generate a new key" style="font-size: 10px; padding: 6px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7; min-height: 60px; resize: vertical;"></textarea>
                        <span style="font-size: 9px; color: rgba(207,228,247,0.7);">Paste a Base64 private key to import an existing wallet.</span>
                    </div>
                    <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                        <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Password:</label>
                        <input type="password" id="createWalletPassword" placeholder="Min 8 characters" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                    </div>
                    <div class="form-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                        <label style="font-size: 10px; color: #cfe4f7; font-weight: 600; min-width: 80px;">Confirm:</label>
                        <input type="password" id="createWalletConfirmPassword" placeholder="Confirm password" style="flex: 1; font-size: 10px; padding: 4px 6px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: rgba(69,139,189,.1); color: #cfe4f7;" />
                    </div>
                    <div class="form-actions" style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px;">
                        <button type="button" onclick="showExistingWallets(this.closest('.traditional-dropdown'), getStoredWallets(), ${walletIndex});" style="font-size: 10px; padding: 4px 8px; border: 1px solid rgba(69,139,189,.3); border-radius: 4px; background: transparent; color: #cfe4f7; cursor: pointer;">Back</button>
                        <button type="button" onclick="handleCreateWalletForm(${walletIndex})" class="create-btn" style="font-size: 10px; padding: 4px 8px; border: none; border-radius: 4px; background: #5a7cff; color: white; cursor: pointer; font-weight: 600;">Continue</button>
                    </div>
                </div>
            `;

        }

        function closeAllTraditionalDropdowns() {
            document.querySelectorAll('.traditional-dropdown').forEach(d => d.classList.remove('visible'));
            document.querySelectorAll('.create-wallet-dropdown').forEach(d => d.classList.remove('visible'));
        }

        function toggleCreateWalletDropdown(walletIndex) {
            const dropdown = document.getElementById('createWalletDropdown' + walletIndex);
            if (!dropdown) return;

            // Close other create wallet dropdowns
            document.querySelectorAll('.create-wallet-dropdown').forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });

            // Toggle current dropdown
            dropdown.classList.toggle('visible');

            // If opening, focus the first input
            if (dropdown.classList.contains('visible')) {
                setTimeout(() => {
                    const nameInput = document.getElementById('createWalletName' + walletIndex);
                    if (nameInput) nameInput.focus();
                }, 100);
            }

            // Close dropdown when clicking outside
            const closeHandler = (e) => {
                if (!dropdown.contains(e.target) && !e.target.closest('.create-wallet-container')) {
                    dropdown.classList.remove('visible');
                    document.removeEventListener('click', closeHandler);
                }
            };

            if (dropdown.classList.contains('visible')) {
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            }
        }

        function closeCreateWalletDropdown(walletIndex) {
            const dropdown = document.getElementById('createWalletDropdown' + walletIndex);
            if (dropdown) {
                dropdown.classList.remove('visible');
            }
        }

        async function handleCreateWalletFromDropdown(walletIndex) {
            const nameInput = document.getElementById('createWalletName' + walletIndex);
            const privateKeyInput = document.getElementById('createWalletPrivateKey' + walletIndex);
            const passwordInput = document.getElementById('createWalletPassword' + walletIndex);
            const confirmInput = document.getElementById('createWalletConfirmPassword' + walletIndex);

            if (!nameInput || !passwordInput || !confirmInput) {
                alert('Form inputs not found');
                return;
            }

            try {
                await createOrImportWallet({
                    name: nameInput.value,
                    rawPrivateKey: privateKeyInput ? privateKeyInput.value : '',
                    password: passwordInput.value,
                    confirmPassword: confirmInput.value
                });

                closeCreateWalletDropdown(walletIndex);
                closeWalletModal();
            } catch (error) {
                logOutput('Error creating or importing wallet: ' + error.message, true);
                alert('Error creating or importing wallet: ' + error.message);
            }
        }

        async function unlockSpecificWallet(walletName) {
            try {
                const storedWallets = getStoredWallets();
                const wallet = storedWallets.find(w => w.name === walletName);
                if (!wallet) {
                    alert('Wallet not found');
                    return;
                }

                const password = prompt(`Enter password for "${walletName}":`);
                if (!password) {
                    logOutput('Wallet unlock cancelled');
                    return;
                }

                // Decrypt private key
                const privateKey = await decryptPrivateKey(wallet.encryptedPrivateKey, password);

                // Recreate keypair
                const { Ed25519Keypair } = window.SuiSDK.Sui;
                const keypair = Ed25519Keypair.fromSecretKey(privateKey);

                // Set as current wallet
                currentWallet = { address: wallet.address, keypair, type: 'traditional', name: wallet.name };
                showCurrentWalletAddress(wallet.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);

                logOutput(`Wallet "${wallet.name}" unlocked successfully!`);
                logOutput(`Address: ${wallet.address}`);
                await getWalletBalance();

                // Close the wallet modal
                closeWalletModal();
            } catch (error) {
                logOutput('Error unlocking wallet: ' + error.message, true);
                alert('Error unlocking wallet: ' + error.message);
            }
        }

        window.toggleZkLoginProviders = toggleZkLoginProviders;
        window.connectZkLoginProvider = connectZkLoginProvider;

        window.toggleTraditionalWalletOptions = toggleTraditionalWalletOptions;
        window.closeAllTraditionalDropdowns = closeAllTraditionalDropdowns;
        window.handleCreateWalletForm = handleCreateWalletForm;
        window.showTraditionalWalletOptions = showTraditionalWalletOptions;
        window.showExistingWallets = showExistingWallets;
        window.showCreateWalletForm = showCreateWalletForm;
        window.unlockSpecificWallet = unlockSpecificWallet;
        window.deleteWalletAndRefresh = deleteWalletAndRefresh;
        window.toggleCreateWalletDropdown = toggleCreateWalletDropdown;
        window.closeCreateWalletDropdown = closeCreateWalletDropdown;
        window.handleCreateWalletFromDropdown = handleCreateWalletFromDropdown;

        window.connectWalletByIndex = async function(i) {
            try {
                const entry = (window.availableSuiWallets && window.availableSuiWallets.length) ? window.availableSuiWallets[i] : null;
                if (!entry) throw new Error('Invalid wallet index');
                closeWalletModal();
                if (entry.type === 'standard' && entry.wallet) {
                    await connectToWallet(entry.wallet);
                } else if (entry.type === 'windowSui') {
                    await connectViaWindowSui();
                } else if (entry.type === 'phantomSui') {
                    await connectViaPhantomSui();
                } else if (entry.type === 'custom') {
                    if (entry.action === 'zkLogin') {
                        // zkLogin now uses provider selection dropdown instead of direct connection
                        throw new Error('zkLogin should use provider selection - this path should not be reached');
                    } else if (entry.action === 'passkey') {
                        await handlePasskeyStub();
                    } else if (entry.action === 'traditionalWallet') {
                        // Traditional wallet uses dropdown, no action needed here
                        throw new Error('Traditional wallet should use dropdown - this path should not be reached');
                    } else {
                        throw new Error('Unsupported custom wallet entry');
                    }
                } else {
                    throw new Error('Unsupported wallet entry');
                }
            } catch (e) {
                logOutput('Wallet selection error: ' + e.message, true);
            }
        };

        async function handlePasskeyStub() {
            logOutput('ðŸ§ª Passkey flow coming soon. This option will use Mysten passkey helpers in the inline Sui SDK.');
        }

        // Network sync utilities
        function getWalletNetwork(wallet) {
            if (!wallet || !wallet.chains) return null;

            // Debug: Show what chains the wallet supports
            logOutput(`ðŸ” Wallet chains: ${JSON.stringify(wallet.chains)}`);

            // Check for Sui networks - prioritize TESTNET first since user expects testnet
            const suiNetworks = ['sui:testnet', 'sui:mainnet', 'sui:devnet'];
            for (const network of suiNetworks) {
                if (wallet.chains.includes(network)) {
                    logOutput(`ðŸŽ¯ Detected network: ${network} (prioritizing testnet)`);
                    return network.replace('sui:', '');
                }
            }

            // Fallback: check for generic 'sui' chain
            if (wallet.chains.includes('sui')) {
                logOutput(`âš ï¸ Generic 'sui' chain detected, assuming testnet`);
                return 'testnet'; // Assume testnet if generic sui chain
            }

            logOutput(`âŒ No Sui network detected in wallet chains`);
            return null;
        }

        function checkWalletNetworkMismatch(wallet) {
            const walletNetwork = getWalletNetwork(wallet);
            if (!walletNetwork) {
                logOutput(`âš ï¸ Could not detect wallet network from chains: ${JSON.stringify(wallet.chains)}`);
                return false;
            }

            if (walletNetwork !== currentNetwork) {
                logOutput(`âš ï¸ Network mismatch detected!`);
                logOutput(`ðŸ’¡ App is on ${currentNetwork}, but wallet ${wallet.name || 'Unknown'} supports ${walletNetwork}`);
                logOutput(`ðŸ“ You can manually change networks using the dropdown above if needed`);
                return true; // There's a mismatch
            } else {
                logOutput(`âœ… Networks match: Both app and wallet on ${walletNetwork}`);
                return false; // No mismatch
            }
        }

        async function connectToWallet(wallet) {
            try {
                logOutput(`Connecting to ${wallet.name || 'wallet'}...`);
                
                let connectFeature = null;
                let accountsFeature = null;
                
                // Find the correct connection feature
                if (wallet.features) {
                    // Priority order for connection features
                    if (wallet.features['standard:connect']) {
                        connectFeature = wallet.features['standard:connect'];
                        accountsFeature = wallet.features['standard:connect'];
                    } else if (wallet.features['sui:connect']) {
                        connectFeature = wallet.features['sui:connect'];
                        accountsFeature = wallet.features['sui:connect'];
                    } else if (wallet.features['sui:signAndExecuteTransaction']) {
                        // Some wallets only have signing features, try to get accounts directly
                        accountsFeature = wallet.features['sui:signAndExecuteTransaction'];
                    }
                }
                
                // Try to connect if we have a connect feature
                if (connectFeature && typeof connectFeature.connect === 'function') {
                    try { await connectFeature.disconnect?.(); } catch (_) {}
                    await connectFeature.connect({ silent: false });
                }
                
                // Try to get accounts
                let accounts = [];
                if (accountsFeature) {
                    if (typeof accountsFeature.getAccounts === 'function') {
                        accounts = await accountsFeature.getAccounts();
                    } else if (accountsFeature.accounts) {
                        accounts = accountsFeature.accounts;
                    }
                }
                
                // Fallback: try direct wallet properties
                if (!accounts || accounts.length === 0) {
                    if (wallet.accounts) {
                        accounts = wallet.accounts;
                    }
                }
                
                if (accounts && accounts.length > 0) {
                    const account = accounts[0];

                    // Check for network mismatch (no auto-switching)
                    const hasMismatch = checkWalletNetworkMismatch(wallet);

                    currentWallet = {
                        address: account.address,
                        type: 'wallet_standard',
                        wallet: wallet
                    };
                    connectedWalletStandard = wallet;
                    attachWalletEvents(wallet);

                    showCurrentWalletAddress(account.address);
                    document.getElementById('walletInfo').style.display = 'block';
                    updateWalletConnectionControls(true);
                    document.getElementById('walletType').textContent = `${wallet.name || 'Wallet Standard'}${hasMismatch ? ' (network mismatch!)' : ''}`;

                    logOutput(`Connected to ${wallet.name || 'wallet'}!`);
                    logOutput(`Address: ${account.address}`);
                    await getWalletBalance();

                    // Automatically find wallets after successful connection
                    try {
                        await findMyWallets();
                    } catch (e) {
                        // Non-fatal error, just log it
                    }
                } else {
                    throw new Error('No accounts found in wallet');
                }
            } catch (error) {
                throw new Error(`Failed to connect to wallet: ${error.message}`);
            }
        }


        async function connectViaWindowSui() {
            if (!window.sui) throw new Error('window.sui not detected');
            try {
                const connectFeature = window.sui.features && window.sui.features['standard:connect'];
                if (!connectFeature || typeof connectFeature.connect !== 'function') {
                    throw new Error('window.sui does not expose standard:connect');
                }

                try { await connectFeature.disconnect?.(); } catch (_) {}
                await connectFeature.connect({ silent: false });

                const accounts = connectFeature.accounts || (typeof connectFeature.getAccounts === 'function'
                    ? await connectFeature.getAccounts()
                    : []);

                if (!accounts || !accounts.length) {
                    throw new Error('No accounts returned via standard:connect');
                }

                const account = accounts[0];
                const hasMismatch = checkWalletNetworkMismatch(window.sui);

                currentWallet = { address: account.address, type: 'wallet_standard', wallet: window.sui };
                connectedWalletStandard = window.sui;
                showCurrentWalletAddress(account.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `Sui Wallet (window.sui)${hasMismatch ? ' (network mismatch!)' : ''}`;
                logOutput('âœ… Connected via window.sui');
                await getWalletBalance();

                try {
                    await findMyWallets();
                } catch (e) {
                    // Non-fatal error, just log it
                }
            } catch (e) {
                throw new Error('window.sui connection failed: ' + e.message);
            }
        }

        async function connectViaPhantomSui() {
            if (!(window.phantom && window.phantom.sui)) throw new Error('Phantom Sui provider not detected');
            const phantomSui = window.phantom.sui;
            try {
                logOutput('Attempting to connect to Phantom Sui...');
                
                // For Phantom, we need to request connection first
                let connectResult;
                if (typeof phantomSui.connect === 'function') {
                    try { await phantomSui.disconnect?.(); } catch (_) {}
                    connectResult = await phantomSui.connect();
                    logOutput('Phantom connect() called successfully');
                } else {
                    logOutput('No connect() method found, trying direct account access');
                }
                
                // Try multiple ways to get accounts from Phantom Sui
                let accounts = [];
                
                // Method 1: Check connect result
                if (connectResult && connectResult.accounts) {
                    accounts = connectResult.accounts;
                    logOutput('Got accounts from connect result');
                }
                // Method 2: Check accounts property
                else if (phantomSui.accounts && phantomSui.accounts.length) {
                    accounts = phantomSui.accounts;
                    logOutput('Got accounts from phantomSui.accounts');
                }
                // Method 3: Try getAccounts method
                else if (typeof phantomSui.getAccounts === 'function') {
                    accounts = await phantomSui.getAccounts();
                    logOutput('Got accounts from getAccounts()');
                }
                
                logOutput(`Phantom Sui returned ${accounts ? accounts.length : 0} accounts`);
                
                if (!accounts || !accounts.length) {
                    throw new Error('No accounts returned by Phantom Sui. Please ensure Phantom is unlocked and has a Sui account configured.');
                }
                
                const account = accounts[0];
                logOutput(`Using account: ${account.address}`);

                // Check for network mismatch (no auto-switching)
                const hasMismatch = checkWalletNetworkMismatch(phantomSui);
                
                currentWallet = { address: account.address, type: 'wallet_standard', wallet: phantomSui };
                connectedWalletStandard = phantomSui;
                
                showCurrentWalletAddress(account.address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = `Phantom (Sui)${hasMismatch ? ' (network mismatch!)' : ''}`;
                
                logOutput('âœ… Connected via Phantom (Sui)');
                logOutput(`Address: ${account.address}`);
                await getWalletBalance();

                // Automatically find wallets after successful connection
                try {
                    await findMyWallets();
                } catch (e) {
                    // Non-fatal error, just log it
                }

            } catch (e) {
                logOutput(`Phantom Sui connection error: ${e.message}`, true);
                throw new Error('Phantom Sui connection failed: ' + e.message);
            }
        }

        async function disconnectWallet() {
            try {
                // Clear zkLogin session data first
                try {
                    clearSensitiveSessionData();
                    logOutput('ðŸ”‘ zkLogin session data cleared');
                } catch (error) {
                    console.warn('Failed to clear zkLogin session data:', error);
                }

                if (connectedWalletStandard && connectedWalletStandard.features) {
                    if (
                        connectedWalletStandard.features['standard:connect'] &&
                        typeof connectedWalletStandard.features['standard:connect'].disconnect === 'function'
                    ) {
                        await connectedWalletStandard.features['standard:connect'].disconnect();
                    } else if (
                        connectedWalletStandard.features['sui:connect'] &&
                        typeof connectedWalletStandard.features['sui:connect'].disconnect === 'function'
                    ) {
                        await connectedWalletStandard.features['sui:connect'].disconnect();
                    } else if (typeof connectedWalletStandard.disconnect === 'function') {
                        await connectedWalletStandard.disconnect();
                    }
                }

                currentWallet = null;
                connectedWalletStandard = null;

                // Clear zkLogin session storage
                try {
                    sessionStorage.removeItem('galactic:zkLogin');
                } catch (_) {}
                
                document.getElementById('walletInfo').style.display = 'none';
                updateWalletConnectionControls(false);
                showCurrentWalletAddress('', { skipReverse: true });
                document.getElementById('currentBalance').textContent = 'Loading...';

                logOutput('Wallet disconnected.');
            } catch (error) {
                logOutput('Error disconnecting wallet: ' + error.message, true);
            }
        }

        function attachWalletEvents(wallet) {
            try {
                if (wallet && wallet.features && wallet.features['standard:events'] && typeof wallet.features['standard:events'].on === 'function') {
                    wallet.features['standard:events'].on('change', async (e) => {
                        try {
                            if (e && e.accounts && e.accounts.length) {
                                const account = e.accounts[0];
                                currentWallet = { address: account.address, type: 'wallet_standard', wallet };
                                connectedWalletStandard = wallet;
                                showCurrentWalletAddress(account.address);
                                document.getElementById('walletInfo').style.display = 'block';
                                updateWalletConnectionControls(true);
                                await getWalletBalance();
                                logOutput(`Active account changed to: ${account.address}`);
                            }
                        } catch (err) {
                            logOutput('Error handling account change: ' + err.message, true);
                        }
                    });
                }
            } catch (_) {}
        }

        // Helper function to sign and execute transactions using proper Wallet Standard
        async function signAndExecuteTransaction(tx) {
            if (!currentWallet) {
                throw new Error('No wallet connected');
            }

            if (currentWallet.type === 'wallet_standard') {
                const wallet = connectedWalletStandard;
                
                // Build transaction data for wallet standard
                const transactionData = {
                    transaction: tx,
                    account: { address: currentWallet.address },
                    chain: `sui:${currentNetwork}`,
                    // Ask wallets to return rich response so we can read created object IDs
                    options: { showEffects: true, showObjectChanges: true }
                };
                
                // Try current Wallet Standard methods (preferred)
                if (wallet.features && wallet.features['sui:signAndExecuteTransaction']) {
                    logOutput('Using sui:signAndExecuteTransaction feature...');
                    return await wallet.features['sui:signAndExecuteTransaction'].signAndExecuteTransaction(transactionData);
                }
                
                throw new Error('Wallet does not support transaction signing. Please ensure your wallet supports the Sui Wallet Standard.');
                
            } else if (currentWallet.type === 'zkLogin') {
                const zk = currentWallet.zkLogin || {};
                if (!zk.signatureInputs) {
                    throw new Error('zkLogin proving service not ready. Reconnect after configuring the prover URL.');
                }
                if (!zk.ephemeralKeyPair) {
                    throw new Error('zkLogin session missing ephemeral keypair. Please reconnect via zkLogin before signing.');
                }

                const { Transaction } = window.SuiSDK.Sui;
                if (!(tx instanceof Transaction)) {
                    throw new Error('Unsupported transaction object for zkLogin signing.');
                }

                tx.setSenderIfNotSet(currentWallet.address);
                const txBytes = await tx.build({ client: suiClient });

                const { signature } = await zk.ephemeralKeyPair.signTransaction(txBytes);
                const signatureBytes = window.SuiSDK.BCS.fromBase64(signature);
                if (!signatureBytes || signatureBytes.length < 65) {
                    throw new Error('Invalid zkLogin user signature produced.');
                }
                const rawUserSignature = signatureBytes.slice(1, 65);

                const maxEpochValue = zk.maxEpoch || pendingZkLoginContext?.maxEpoch;
                if (!maxEpochValue) {
                    throw new Error('Missing maxEpoch for zkLogin signature. Reconnect to refresh the session.');
                }
                let maxEpochBigInt;
                try {
                    maxEpochBigInt = BigInt(maxEpochValue);
                } catch (_) {
                    throw new Error('Invalid maxEpoch value returned by zkLogin proving service.');
                }

                const zkSignature = window.SuiSDK.ZkLogin.getZkLoginSignature({
                    inputs: zk.signatureInputs,
                    maxEpoch: maxEpochBigInt,
                    userSignature: rawUserSignature
                });

                logOutput('ðŸ” Signing transaction with zkLogin...');
                const result = await suiClient.executeTransactionBlock({
                    transactionBlock: txBytes,
                    signature: [zkSignature],
                    options: { showEffects: true, showObjectChanges: true }
                });
                logOutput('âœ… zkLogin transaction executed successfully');
                return result;

            } else {
                // Use traditional keypair signing for non-wallet-standard connections
                return await suiClient.signAndExecuteTransaction({
                    signer: currentWallet.keypair,
                    transaction: tx
                });
            }
        }

        function clearOutput() {
            document.getElementById('output').textContent = '';
        }

        async function clearCache() {
            try {
                // Debug: First show all localStorage keys
                logOutput('ðŸ” Scanning localStorage for zkLogin entries...');

                const allKeys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key) {
                        allKeys.push(key);
                        logOutput(`Found key: "${key}"`);
                    }
                }

                // Count cache entries to remove
                const keysToRemove = allKeys.filter(key => key.toLowerCase().startsWith(ZKLOGIN_STORAGE_PREFIX));

                if (keysToRemove.length === 0) {
                    logOutput('No zkLogin cache entries found to clear');
                    logOutput(`Total localStorage keys: ${allKeys.length}`);
                    return;
                }

                logOutput(`Found ${keysToRemove.length} zkLogin cache entries:`);
                keysToRemove.forEach(key => logOutput(`  - ${key}`));

                // Show confirmation dialog
                const confirmed = confirm(
                    `Clear ${keysToRemove.length} cached zkLogin identity entries?\n\n` +
                    'This will remove all stored Google OAuth identities and you will need to sign in again.\n\n' +
                    'Are you sure you want to continue?'
                );

                if (!confirmed) {
                    logOutput('Cache clear cancelled by user');
                    return;
                }

                // Clear the cache
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key);
                    logOutput(`ðŸ—‘ï¸ Removed: ${key}`);
                });

                logOutput(`âœ… Cleared ${keysToRemove.length} zkLogin cache entries from localStorage`);
                logOutput('âš ï¸ You will need to sign in with Google again for zkLogin');

                try {
                    clearSensitiveSessionData();
                    logOutput('ðŸ”‘ In-memory zkLogin session data cleared');
                } catch (innerError) {
                    console.warn('Failed to clear in-memory zkLogin session data:', innerError);
                }

            } catch (error) {
                logOutput('âŒ Failed to clear cache: ' + error.message, true);
            }
        }

        function toggleViewOnlyForm(button) {
            try {
                const controls = document.getElementById('walletConnectionControls');
                const form = document.getElementById('viewOnlyForm');
                if (!controls) {
                    return;
                }

                if (controls.dataset.connected === 'true') {
                    return;
                }

                const isOpen = controls.dataset.open === 'true';
                const nextState = !isOpen;

                controls.dataset.open = nextState ? 'true' : 'false';
                controls.style.display = nextState ? '' : 'none';

                if (form) {
                    form.style.display = nextState ? 'block' : 'none';
                }

                if (button) {
                    button.setAttribute('aria-expanded', nextState ? 'true' : 'false');
                }

                if (nextState) {
                    clearViewOnlyInputError();
                    const input = document.getElementById('viewOnlyTarget');
                    if (input) {
                        input.focus();
                    }
                }
            } catch (error) {
                console.warn('Failed to toggle view-only form:', error);
            }
        }

        function markViewOnlyInputError() {
            const input = document.getElementById('viewOnlyTarget');
            const setInputError = window.SuiSDK?.Utils?.setInputError;
            if (typeof setInputError === 'function') {
                setInputError(input, true);
            } else if (input) {
                input.classList.add('view-only-input-error');
            }
        }

        function clearViewOnlyInputError() {
            const input = document.getElementById('viewOnlyTarget');
            const setInputError = window.SuiSDK?.Utils?.setInputError;
            if (typeof setInputError === 'function') {
                setInputError(input, false);
            } else if (input) {
                input.classList.remove('view-only-input-error');
            }
        }

        // View-only connection function that accepts Sui addresses or SuiNS names
        async function connectViewOnly(target) {
            try {
                clearViewOnlyInputError();
                const { address, source, name } = await resolveViewOnlyTarget(target);

                currentWallet = {
                    address,
                    type: 'view_only',
                    wallet: null
                };
                connectedWalletStandard = null;

                const viewOnlyControls = document.getElementById('walletConnectionControls');
                const viewOnlyForm = document.getElementById('viewOnlyForm');
                const viewToggleButton = document.getElementById('viewOnlyToggleButton');

                if (viewOnlyControls) {
                    viewOnlyControls.dataset.open = 'false';
                    viewOnlyControls.style.display = 'none';
                }
                if (viewOnlyForm) {
                    viewOnlyForm.style.display = 'none';
                }
                if (viewToggleButton) {
                    viewToggleButton.setAttribute('aria-expanded', 'false');
                }

                showCurrentWalletAddress(address);
                document.getElementById('walletInfo').style.display = 'block';
                updateWalletConnectionControls(true);
                document.getElementById('walletType').textContent = source === 'suins' ? 'View Only (SuiNS)' : 'View Only (Address)';

                if (source === 'suins' && name) {
                    logOutput(`SuiNS ${name} resolved to: ${address}`);
                } else {
                    logOutput(`Viewing address: ${address}`);
                }
                logOutput('Note: This is view-only. You cannot sign transactions without a proper wallet connection.');

                try {
                    const inputEl = document.getElementById('viewOnlyTarget');
                    if (inputEl) inputEl.value = '';
                } catch (_) {}

                await getWalletBalance();
            } catch (error) {
                logOutput('View-only connection error: ' + error.message, true);
                markViewOnlyInputError();
            }
        }

        window.getWalletBalance = getWalletBalance;
        window.getStoredWallets = getStoredWallets;
        window.clearOutput = clearOutput;
        window.clearCache = clearCache;
        window.connectWalletStandard = connectWalletStandard;
        window.disconnectWallet = disconnectWallet;
        window.connectViewOnly = connectViewOnly;
        window.toggleViewOnlyForm = toggleViewOnlyForm;
        window.clearZkLoginSession = function() {
            try {
                sessionStorage.removeItem('galactic:zkLogin');
                logOutput('zkLogin session storage cleared');
            } catch (e) {
                logOutput('Failed to clear zkLogin session: ' + e.message, true);
            }
        };


        // App initialization
        function initializeApp() {
            updateWalletConnectionControls(false);

            // Show all sections immediately (except operations which stays collapsed)
            const allSections = document.querySelectorAll('.section');
            const operationsSection = document.getElementById('smartWalletOperations');
            allSections.forEach(section => {
                if (operationsSection && section === operationsSection) {
                    return;
                }
                section.style.display = 'block';
                section.classList.add('visible');
            });

            try {
                const overlay = document.getElementById('walletModal');
                if (overlay) {
                    overlay.addEventListener('click', function(ev){ if (ev.target === overlay) closeWalletModal(); });
                }
                const closeButton = document.getElementById('walletModalClose');
                if (closeButton) {
                    closeButton.addEventListener('click', () => closeWalletModal());
                }
                document.addEventListener('keydown', function(ev){
                    if (ev.key === 'Escape') {
                        closeWalletModal();
                        closeAllTraditionalDropdowns();
                    }
                });

                // Close dropdowns when clicking outside
                document.addEventListener('click', function(ev) {
                    if (!ev.target.closest('.traditional-providers') && !ev.target.closest('.zklogin-providers')) {
                        closeAllTraditionalDropdowns();
                    }
                });

                const viewOnlyInput = document.getElementById('viewOnlyTarget');
                if (viewOnlyInput) {
                    viewOnlyInput.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            connectViewOnly(viewOnlyInput.value);
                        }
                    });
                    viewOnlyInput.addEventListener('input', function() {
                        clearViewOnlyInputError();
                    });
                }
            } catch (e) {}

            scheduleBootstrapWork();
        }


        // Security initialization
        function initializeSecurity() {
            try {
                // Generate and set CSRF token if security utilities are available
                if (typeof window.setCSRFToken === 'function') {
                    const csrfToken = window.setCSRFToken();
                    console.log('CSRF protection initialized');
                } else {
                    console.warn('CSRF protection not available - ensure zklogin-helpers are loaded');
                }
            } catch (error) {
                console.error('Security initialization failed:', error);
            }
        }

        // Combined initialization
        async function initializeWallet() {
            initializeSecurity();
            await initializeApp();
        }

        // Initialize when ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeWallet);
        } else {
            initializeWallet();
        }
    </script>
</head>
<body>
    <!-- Main content (show immediately) -->
    <div class="container main-content loaded" id="main-content">
        <h1><span class="sw-icon" aria-hidden="true"></span> Galactic</h1>
        <p style="text-align: center; color: #c3d5e8; font-size: 16px; margin-top: -10px; margin-bottom: 30px;">
            Galactic Wallet Interface
        </p>
        

        <div class="section">
            <div class="wallet-connection-header">
                <h3>Wallet Connection</h3>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <button id="walletHeaderAction" class="primary-btn connect-wallet-inline">Connect</button>
                    <button type="button" id="viewOnlyToggleButton" class="view-only-toggle" onclick="toggleViewOnlyForm(this)" aria-expanded="false" aria-controls="walletConnectionControls">
                        ðŸ”
                        <span class="sr-only">Toggle view-only quick connect</span>
                    </button>
                </div>
                <div id="walletHeaderSpinnerWrapper" aria-live="polite" aria-atomic="true">
                    <span id="walletHeaderSpinner" aria-hidden="true"></span>
                    <span class="sr-only" id="walletHeaderSpinnerLabel">Loading wallet SDKâ€¦</span>
                </div>
            </div>

            <div id="walletConnectionControls" class="section-toggle" data-connected="false" data-open="false" style="display: none; margin-top: 15px; border: 1px solid rgba(139,69,189,.3); border-radius: 12px; padding: 14px;">
                <div style="display: flex; align-items: center; gap: 14px; flex-wrap: wrap;">
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        <h4 style="margin: 0; font-weight: 500; color: #c3d5e8; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                            <span aria-hidden="true">ðŸ‘ï¸</span>
                            <span>View-Only Connection</span>
                        </h4>
                        <span id="walletConnectionStatus" class="summary-status" style="font-size: 11px; color: #a0b3c5;">Not viewing</span>
                    </div>
                </div>
                <div id="viewOnlyForm" style="display: none; margin-top: 12px;">
                    <p style="font-size: 11px; color: #a0b3c5; margin: 0 0 8px 0;">Enter a Sui address (0x...) or SuiNS name (example.sui) to view balances without signing.</p>
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <input type="text" id="viewOnlyTarget" placeholder="0x... or name.sui" style="flex: 1; min-width: 220px; font-size: 12px;">
                        <button onclick="connectViewOnly(document.getElementById('viewOnlyTarget').value)" style="font-size: 12px; padding: 5px 10px;">Connect View-Only</button>
                    </div>
                </div>
            </div>

            <div id="walletInfo" class="wallet-info" style="display: none;">
                <h4 class="wallet-heading">Connected Wallet
                    <span id="walletSuinsName" class="wallet-suins" style="display:none;">
                        <span id="walletSuinsValue" class="address-value"></span>
                        <button type="button" class="copy-btn" data-copy-target="walletSuinsValue" data-copy-allow-any="true" aria-label="Copy SuiNS name" title="Copy SuiNS name">Copy</button>
                    </span>
                </h4>
                <p><strong>Type:</strong> <span id="walletType">Unknown</span></p>
                <p class="address-row"><strong>Address:</strong>
                    <span id="currentAddress" class="address-value"></span>
                    <button type="button" class="copy-btn" data-copy-target="currentAddress" aria-label="Copy address" title="Copy address">Copy</button>
                </p>
                <p class="balance-row"><strong>Balance:</strong>
                    <span id="currentBalance" class="balance-value">Loading...</span>
                    <button type="button" class="balance-refresh" onclick="getWalletBalance()" aria-label="Refresh balance">Refresh</button>
                </p>
                <button onclick="disconnectWallet()" style="background: #dc3545;">Disconnect</button>
            </div>
        </div>

        <div class="section">
            <h3>Console Output</h3>
            <button onclick="clearOutput()">Clear Output</button>
            <button onclick="clearCache()" style="margin-left: 10px;">Clear Cache</button>
            <div id="output">Galactic Wallet Interface Ready

</div>
        </div>
    </div>
    <!-- Wallet Selection Modal -->
    <div id="walletModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="walletModalTitle">
      <div class="modal" role="document">
        <div class="modal-header">
          <h4 id="walletModalTitle" class="modal-title">Select a Sui Wallet</h4>
          <button id="walletModalClose" class="modal-close" aria-label="Close">âœ•</button>
        </div>
        <div id="walletModalBody" class="modal-body">
          <div id="walletModalList"></div>
        </div>
      </div>
    </div>
    
</body>
</html>
