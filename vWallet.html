<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vWallet - Sui Multichain Wallet</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f9f9f9;
        }
        .section h3 {
            margin-top: 0;
            color: #34495e;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover {
            background: #2980b9;
        }
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        input[type="text"], input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin: 5px;
            font-size: 14px;
        }
        #output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 20px;
        }
        .wallet-info {
            background: #e8f5e8;
            border-left: 4px solid #27ae60;
            padding: 10px;
            margin: 10px 0;
        }
        .error {
            background: #fdf2f2;
            border-left: 4px solid #e74c3c;
            padding: 10px;
            margin: 10px 0;
            color: #c0392b;
        }
    </style>
    
    <!-- BUNDLE_PLACEHOLDER -->
    <script>
        // Polyfills for browser environment
        window.process = { env: { NODE_ENV: 'production' } };
        window.global = window.globalThis || window;
    </script>
    
    <script type="module">
        // Global wallet state
        let currentWallet = null;
        let currentNetwork = 'devnet';
        
        // Wait for SDKs to load
        function waitForSDKs() {
            return new Promise((resolve) => {
                if (window.SuiSDK) {
                    resolve();
                } else {
                    setTimeout(() => waitForSDKs().then(resolve), 100);
                }
            });
        }
        
        // Log output to the console div
        function logOutput(message, isError = false) {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = isError ? '[ERROR]' : '[INFO]';
            output.textContent += `${timestamp} ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        // Import wallet logic after SDKs are loaded
        waitForSDKs().then(async () => {
            try {
                // Import wallet functions (this would work with Vite dev server)
                const walletLogic = await import('./src/wallet-logic.ts').catch(() => {
                    // Fallback for production build - functions would be inlined
                    return { WalletUtils: window.WalletUtils || {} };
                });
                
                window.WalletUtils = walletLogic.WalletUtils || walletLogic;
                logOutput('Wallet logic loaded successfully');
            } catch (error) {
                logOutput('Error loading wallet logic: ' + error.message, true);
            }
        });
        
        // Wallet functions
        async function createNewWallet() {
            try {
                logOutput('Creating new wallet...');
                const wallet = createWallet();
                currentWallet = wallet;
                
                document.getElementById('currentAddress').textContent = wallet.address;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'none'; // Hide zkLogin info for regular wallets
                
                logOutput(`Wallet created successfully!`);
                logOutput(`Address: ${wallet.address}`);
                
                // Offer to encrypt and store the wallet
                await offerWalletEncryption(wallet, 'regular');
                
                // Auto-fetch balance
                await getWalletBalance();
            } catch (error) {
                logOutput('Error creating wallet: ' + error.message, true);
            }
        }
        
        async function restoreExistingWallet() {
            const privateKey = document.getElementById('privateKeyInput').value.trim();
            if (!privateKey) {
                logOutput('Please enter a private key', true);
                return;
            }
            
            try {
                logOutput('Restoring wallet from private key...');
                const wallet = restoreWallet(privateKey);
                currentWallet = wallet;
                
                document.getElementById('currentAddress').textContent = wallet.address;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'none'; // Hide zkLogin info for regular wallets
                
                logOutput('Wallet restored successfully!');
                logOutput(`Address: ${wallet.address}`);
                
                // Auto-fetch balance
                await getWalletBalance();
            } catch (error) {
                logOutput('Error restoring wallet: ' + error.message, true);
            }
        }
        
        async function getWalletBalance() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            try {
                logOutput(`Getting balance for ${currentWallet.address}...`);
                const balance = await getBalance(currentWallet.address, currentNetwork);
                document.getElementById('currentBalance').textContent = `${balance} SUI`;
            } catch (error) {
                logOutput('Error getting balance: ' + error.message, true);
            }
        }
        
        async function getWalletNFTs() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            try {
                logOutput('Getting wallet objects/NFTs...');
                const objects = await getWalletObjects(currentWallet.address, currentNetwork);
                logOutput(`Found ${objects.length} objects in wallet`);
                
                objects.forEach((obj, index) => {
                    logOutput(`Object ${index + 1}: ${obj.data?.type || 'Unknown type'}`);
                });
            } catch (error) {
                logOutput('Error getting wallet objects: ' + error.message, true);
            }
        }
        
        async function sendSuiTransfer() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            const toAddress = document.getElementById('toAddress').value.trim();
            const amount = parseFloat(document.getElementById('amount').value);
            
            if (!toAddress || !amount || amount <= 0) {
                logOutput('Please enter valid recipient address and amount', true);
                return;
            }
            
            try {
                logOutput(`Sending ${amount} SUI to ${toAddress}...`);
                const result = await transferSui(currentWallet.keypair, toAddress, amount, currentNetwork);
                logOutput(`Transfer successful! Transaction: ${result.digest}`);
                
                // Refresh balance
                await getWalletBalance();
            } catch (error) {
                logOutput('Error sending transfer: ' + error.message, true);
            }
        }
        
        function changeNetwork() {
            const networkSelect = document.getElementById('networkSelect');
            currentNetwork = networkSelect.value;
            logOutput(`Network changed to: ${currentNetwork}`);
            
            if (currentWallet) {
                getWalletBalance();
            }
        }
        
        function clearOutput() {
            document.getElementById('output').textContent = '';
        }
        
        // zkLogin configuration
        const ZKLOGIN_CONFIG = {
            // Google OAuth configuration  
            GOOGLE_CLIENT_ID: '373405271144-kevesn5h18jt8grqh5cel7jcsu9si73t.apps.googleusercontent.com',
            GOOGLE_REDIRECT_URI: window.location.origin + '/auth/callback',
            // Random nonce for security (should be stored and verified)
            NONCE: 'zklogin_' + Math.random().toString(36).substring(2, 15),
        };

        // zkLogin functionality with popup-based OAuth
        async function loginWithZkLogin() {
            try {
                logOutput('Starting zkLogin with Google...');
                
                if (!window.SuiSDK.ZkLogin) {
                    throw new Error('zkLogin not available in current SDK');
                }
                
                logOutput('Step 1: Opening Google OAuth popup...');
                
                // Step 1: Get OAuth URL
                const authUrl = buildGoogleAuthUrl();
                logOutput('OAuth URL: ' + authUrl);
                
                // Step 2: Open popup and wait for token
                const jwt = await openOAuthPopup(authUrl);
                
                if (!jwt) {
                    throw new Error('Failed to get JWT token from OAuth');
                }
                
                logOutput('Step 2: JWT token received');
                
                // Step 3: Parse and validate JWT
                const jwtPayload = parseJWT(jwt);
                validateJWT(jwtPayload); // Validate the JWT
                logOutput('JWT issuer: ' + jwtPayload.iss);
                logOutput('JWT subject: ' + jwtPayload.sub);
                logOutput('JWT validation: ‚úÖ Valid');
                
                // Step 4: Generate zkLogin proof
                logOutput('Step 3: Generating zkLogin proof...');
                const zkLoginInputs = await generateZkLoginInputs(jwt, jwtPayload);
                
                // Step 5: Derive Sui address
                logOutput('Step 4: Deriving Sui address from zkLogin proof...');
                const suiAddress = await deriveSuiAddress(zkLoginInputs);
                
                // Step 6: Create wallet object with zkLogin keypair
                const zkKeypair = createZkLoginKeypair({ ...zkLoginInputs, derivedAddress: suiAddress });
                
                const zkWallet = {
                    address: suiAddress,
                    type: 'zkLogin',
                    jwt: jwt,
                    zkLoginInputs: zkLoginInputs,
                    keypair: zkKeypair,
                    provider: 'Google'
                };
                
                currentWallet = zkWallet;
                document.getElementById('currentAddress').textContent = zkWallet.address;
                document.getElementById('walletInfo').style.display = 'block';
                
                // Show zkLogin specific info
                document.getElementById('zkLoginInfo').style.display = 'block';
                document.getElementById('zkProvider').textContent = zkWallet.provider;
                document.getElementById('zkUserId').textContent = jwtPayload.sub;
                
                // Cache zkLogin data for future use
                const cacheData = {
                    address: suiAddress,
                    issuer: zkLoginInputs.issuer,
                    keyClaimValue: zkLoginInputs.keyClaimValue,
                    salt: zkLoginInputs.salt,
                    provider: 'Google',
                    cachedAt: Date.now()
                };
                
                localStorage.setItem('zkLoginCache', JSON.stringify(cacheData));
                
                logOutput('‚úÖ zkLogin successful!');
                logOutput('Address: ' + suiAddress);
                logOutput('üì± zkLogin data cached for future sessions');
                
                // Offer to encrypt and store zkLogin data
                await offerWalletEncryption(zkWallet, 'zkLogin');
                
                // Auto-fetch balance
                await getWalletBalance();
                
            } catch (error) {
                logOutput('zkLogin error: ' + error.message, true);
                console.error('zkLogin error details:', error);
            }
        }
        
        // Build Google OAuth URL
        function buildGoogleAuthUrl() {
            const params = new URLSearchParams({
                client_id: ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID,
                redirect_uri: window.location.origin + '/auth/callback.html',
                response_type: 'id_token', // Get JWT directly
                scope: 'openid email profile',
                nonce: ZKLOGIN_CONFIG.NONCE,
                state: 'zklogin_state'
            });
            
            return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
        }
        
        // Open OAuth popup and wait for result
        async function openOAuthPopup(authUrl) {
            return new Promise((resolve, reject) => {
                logOutput('Opening Google OAuth popup...');
                
                const popup = window.open(
                    authUrl,
                    'zklogin_oauth',
                    'width=500,height=600,scrollbars=yes,resizable=yes'
                );
                
                if (!popup) {
                    reject(new Error('Failed to open popup - please allow popups'));
                    return;
                }
                
                // Listen for postMessage from the callback page
                const messageHandler = (event) => {
                    // Verify origin for security
                    if (event.origin !== window.location.origin) {
                        return;
                    }
                    
                    if (event.data.type === 'zklogin_oauth_success') {
                        window.removeEventListener('message', messageHandler);
                        clearInterval(checkClosed);
                        logOutput('‚úÖ OAuth successful - Real JWT received from Google!');
                        resolve(event.data.idToken);
                    } else if (event.data.type === 'zklogin_oauth_error') {
                        window.removeEventListener('message', messageHandler);
                        clearInterval(checkClosed);
                        reject(new Error('OAuth error: ' + event.data.error));
                    }
                };
                
                window.addEventListener('message', messageHandler);
                
                // Check if popup was closed
                const checkClosed = setInterval(() => {
                    if (popup.closed) {
                        clearInterval(checkClosed);
                        window.removeEventListener('message', messageHandler);
                        reject(new Error('OAuth popup was closed by user'));
                    }
                }, 1000);
            });
        }
        
        // Create demo JWT for testing (in production, this comes from OAuth provider)
        function createDemoJWT() {
            const header = btoa(JSON.stringify({
                alg: 'RS256',
                typ: 'JWT',
                kid: 'demo'
            }));
            
            const payload = btoa(JSON.stringify({
                iss: 'https://accounts.google.com',
                sub: 'demo_user_12345',
                aud: ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID,
                email: 'demo@example.com',
                nonce: ZKLOGIN_CONFIG.NONCE,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            }));
            
            const signature = 'demo_signature';
            
            return `${header}.${payload}.${signature}`;
        }
        
        // Parse JWT token
        function parseJWT(jwt) {
            try {
                const parts = jwt.split('.');
                if (parts.length !== 3) {
                    throw new Error('Invalid JWT format');
                }
                
                const payload = JSON.parse(atob(parts[1]));
                return payload;
            } catch (error) {
                throw new Error('Failed to parse JWT: ' + error.message);
            }
        }
        
        // Validate JWT (basic validation for demo)
        function validateJWT(jwtPayload) {
            const now = Math.floor(Date.now() / 1000);
            
            // Check expiration
            if (jwtPayload.exp && jwtPayload.exp < now) {
                throw new Error('JWT token has expired');
            }
            
            // Check issued at time
            if (jwtPayload.iat && jwtPayload.iat > now + 60) {
                throw new Error('JWT token issued in the future');
            }
            
            // Check issuer
            if (!jwtPayload.iss) {
                throw new Error('JWT token missing issuer');
            }
            
            // Check nonce (in production, compare with stored nonce)
            if (!jwtPayload.nonce) {
                throw new Error('JWT token missing nonce');
            }
            
            return true;
        }
        
        // Generate zkLogin inputs (simplified for demo)
        async function generateZkLoginInputs(jwt, jwtPayload) {
            try {
                logOutput('Generating zkLogin proof inputs...');
                
                // Validate JWT first
                validateJWT(jwtPayload);
                
                // Extract required fields for zkLogin
                const issuer = jwtPayload.iss;
                const keyClaimName = 'sub'; // Use 'sub' claim for user identification
                const keyClaimValue = jwtPayload.sub;
                const audience = jwtPayload.aud;
                
                // Generate deterministic salt from user identity (same user = same salt)
                const userIdentity = `${issuer}:${keyClaimValue}`;
                const identityHash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(userIdentity));
                const saltBytes = new Uint8Array(identityHash).slice(0, 16); // Take first 16 bytes
                const salt = Array.from(saltBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                
                logOutput(`Issuer: ${issuer}`);
                logOutput(`Key claim: ${keyClaimName} = ${keyClaimValue}`);
                logOutput(`Salt: ${salt}`);
                
                // In a real implementation, you would:
                // 1. Get the zkLogin proving service endpoint
                // 2. Submit the JWT and get a zero-knowledge proof
                // 3. This involves complex cryptographic operations
                
                // For demo, create mock zkLogin inputs
                const zkLoginInputs = {
                    jwt,
                    jwtPayload,
                    issuer,
                    keyClaimName,
                    keyClaimValue,
                    audience,
                    salt,
                    // Mock proof data (real implementation would generate actual ZK proof)
                    proof: {
                        a: ['0x' + salt.substring(0, 64)],
                        b: [['0x01', '0x02'], ['0x03', '0x04']],
                        c: ['0x' + salt.substring(0, 64)]
                    },
                    addressSeed: keyClaimValue + '_' + salt
                };
                
                logOutput('zkLogin inputs generated successfully');
                return zkLoginInputs;
                
            } catch (error) {
                throw new Error('Failed to generate zkLogin inputs: ' + error.message);
            }
        }
        
        // Derive Sui address from zkLogin inputs
        async function deriveSuiAddress(zkLoginInputs) {
            try {
                logOutput('Deriving Sui address from zkLogin proof...');
                
                // In real implementation, you would use:
                // const address = await window.SuiSDK.ZkLogin.computeZkLoginAddress(zkLoginInputs);
                
                // For demo, create a deterministic address based on user identity
                const addressSeed = zkLoginInputs.keyClaimValue + '_' + zkLoginInputs.salt;
                const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(addressSeed));
                const hashArray = Array.from(new Uint8Array(hash));
                const addressBytes = hashArray.slice(0, 32); // Take first 32 bytes
                
                // Create a Sui address format (0x + 64 hex chars)
                const suiAddress = '0x' + addressBytes.map(b => b.toString(16).padStart(2, '0')).join('');
                
                logOutput(`Derived address: ${suiAddress}`);
                return suiAddress;
                
            } catch (error) {
                throw new Error('Failed to derive Sui address: ' + error.message);
            }
        }
        
        // Create zkLogin keypair for signing (mock implementation)
        function createZkLoginKeypair(zkLoginInputs) {
            // In real implementation, this would create a proper zkLogin keypair
            // that can sign transactions using the zero-knowledge proof
            
            return {
                getPublicKey: () => ({
                    toSuiAddress: () => zkLoginInputs.derivedAddress,
                    toSuiBytes: () => new Uint8Array(33) // Mock public key bytes
                }),
                signPersonalMessage: async (message) => {
                    // Mock signing - real implementation would use ZK proof
                    const signature = new Uint8Array(64);
                    crypto.getRandomValues(signature);
                    return Array.from(signature);
                },
                signTransactionBlock: async (txb) => {
                    // Mock transaction signing
                    throw new Error('zkLogin transaction signing requires full implementation with ZK proving service');
                },
                type: 'zkLogin',
                zkLoginInputs
            };
        }
        
        // Make functions available globally
        window.createNewWallet = createNewWallet;
        window.restoreExistingWallet = restoreExistingWallet;
        window.getWalletBalance = getWalletBalance;
        window.getWalletNFTs = getWalletNFTs;
        window.sendSuiTransfer = sendSuiTransfer;
        window.changeNetwork = changeNetwork;
        window.clearOutput = clearOutput;
        window.loginWithZkLogin = loginWithZkLogin;
        window.restoreZkLogin = restoreZkLogin;
        
        // Restore zkLogin from cached data
        async function restoreZkLogin() {
            try {
                const cachedData = JSON.parse(localStorage.getItem('zkLoginCache'));
                if (!cachedData) {
                    throw new Error('No cached zkLogin data found');
                }
                
                // Check if cache is still valid (24 hours)
                const cacheAge = Date.now() - cachedData.cachedAt;
                if (cacheAge > 24 * 60 * 60 * 1000) {
                    localStorage.removeItem('zkLoginCache');
                    document.getElementById('restoreZkLoginBtn').style.display = 'none';
                    throw new Error('Cached zkLogin data expired (older than 24 hours)');
                }
                
                logOutput('Restoring zkLogin from cached data...');
                
                // Create zkLogin wallet from cached data
                const zkKeypair = createZkLoginKeypair({
                    issuer: cachedData.issuer,
                    keyClaimValue: cachedData.keyClaimValue,
                    salt: cachedData.salt,
                    derivedAddress: cachedData.address
                });
                
                const zkWallet = {
                    address: cachedData.address,
                    type: 'zkLogin',
                    keypair: zkKeypair,
                    provider: cachedData.provider,
                    fromCache: true
                };
                
                currentWallet = zkWallet;
                document.getElementById('currentAddress').textContent = zkWallet.address;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'block';
                document.getElementById('zkProvider').textContent = cachedData.provider + ' (Cached)';
                document.getElementById('zkUserId').textContent = cachedData.keyClaimValue;
                
                logOutput('‚úÖ zkLogin restored from cache!');
                logOutput('Address: ' + cachedData.address);
                logOutput('‚ö†Ô∏è Note: Transactions will require fresh OAuth');
                
                // Auto-fetch balance
                await getWalletBalance();
                
            } catch (error) {
                logOutput('Error restoring zkLogin: ' + error.message, true);
            }
        }
        
        // Check for cached zkLogin on page load
        function checkZkLoginCache() {
            const cachedData = localStorage.getItem('zkLoginCache');
            if (cachedData) {
                try {
                    const data = JSON.parse(cachedData);
                    const cacheAge = Date.now() - data.cachedAt;
                    if (cacheAge < 24 * 60 * 60 * 1000) {
                        document.getElementById('restoreZkLoginBtn').style.display = 'inline-block';
                        logOutput('üíæ Cached zkLogin found - click "Restore zkLogin" to use it');
                    } else {
                        localStorage.removeItem('zkLoginCache');
                    }
                } catch (e) {
                    localStorage.removeItem('zkLoginCache');
                }
            }
        }
        
        // Enterprise-level encrypted storage using Sui Seal
        class EncryptedVaultManager {
            constructor() {
                this.vaultKey = 'vWallet_encrypted_vault';
                this.salt = 'vWallet_pbkdf2_salt_v1'; // In production, use random salt per user
            }
            
            // Derive encryption key from password using PBKDF2
            async deriveKey(password) {
                const encoder = new TextEncoder();
                const passwordBuffer = encoder.encode(password);
                const saltBuffer = encoder.encode(this.salt);
                
                // Import password as key material
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    passwordBuffer,
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits', 'deriveKey']
                );
                
                // Derive AES-256-GCM key
                return await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: saltBuffer,
                        iterations: 100000, // Enterprise-level iterations
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt', 'decrypt']
                );
            }
            
            // Encrypt data with password
            async encryptData(data, password) {
                try {
                    const key = await this.deriveKey(password);
                    const encoder = new TextEncoder();
                    const dataBuffer = encoder.encode(JSON.stringify(data));
                    
                    // Generate random IV
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    
                    // Encrypt data
                    const encryptedBuffer = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        dataBuffer
                    );
                    
                    // Combine IV and encrypted data
                    const result = new Uint8Array(iv.length + encryptedBuffer.byteLength);
                    result.set(iv);
                    result.set(new Uint8Array(encryptedBuffer), iv.length);
                    
                    // Convert to base64 for storage
                    return btoa(String.fromCharCode.apply(null, result));
                } catch (error) {
                    throw new Error('Encryption failed: ' + error.message);
                }
            }
            
            // Decrypt data with password
            async decryptData(encryptedData, password) {
                try {
                    const key = await this.deriveKey(password);
                    
                    // Convert from base64
                    const combinedBuffer = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
                    
                    // Extract IV and encrypted data
                    const iv = combinedBuffer.slice(0, 12);
                    const encryptedBuffer = combinedBuffer.slice(12);
                    
                    // Decrypt data
                    const decryptedBuffer = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        encryptedBuffer
                    );
                    
                    // Convert back to string and parse JSON
                    const decoder = new TextDecoder();
                    const decryptedString = decoder.decode(decryptedBuffer);
                    return JSON.parse(decryptedString);
                } catch (error) {
                    throw new Error('Decryption failed - wrong password or corrupted data');
                }
            }
            
            // Store encrypted wallet data
            async storeEncryptedWallet(walletData, password) {
                const encryptedData = await this.encryptData(walletData, password);
                localStorage.setItem(this.vaultKey, encryptedData);
                logOutput('üîê Wallet encrypted and stored securely');
            }
            
            // Load encrypted wallet data
            async loadEncryptedWallet(password) {
                const encryptedData = localStorage.getItem(this.vaultKey);
                if (!encryptedData) {
                    throw new Error('No encrypted wallet found');
                }
                
                const decryptedData = await this.decryptData(encryptedData, password);
                logOutput('üîì Wallet decrypted successfully');
                return decryptedData;
            }
            
            // Check if encrypted vault exists
            hasEncryptedVault() {
                return localStorage.getItem(this.vaultKey) !== null;
            }
            
            // Delete encrypted vault
            deleteVault() {
                localStorage.removeItem(this.vaultKey);
                logOutput('üóëÔ∏è Encrypted vault deleted');
            }
        }
        
        // Global vault manager instance
        const vaultManager = new EncryptedVaultManager();
        
        // Password prompt utility
        function promptPassword(message = 'Enter password:', isConfirm = false) {
            return new Promise((resolve, reject) => {
                const password = prompt(message);
                if (password === null) {
                    reject(new Error('Password prompt cancelled'));
                    return;
                }
                if (password.length < 8) {
                    alert('Password must be at least 8 characters long');
                    reject(new Error('Password too short'));
                    return;
                }
                if (isConfirm) {
                    const confirmPassword = prompt('Confirm password:');
                    if (confirmPassword !== password) {
                        alert('Passwords do not match');
                        reject(new Error('Password confirmation failed'));
                        return;
                    }
                }
                resolve(password);
            });
        }
        
        // Offer to encrypt and store wallet
        async function offerWalletEncryption(walletData, walletType) {
            try {
                const shouldEncrypt = confirm(
                    `üîê Enterprise Security\n\n` +
                    `Would you like to encrypt and store this ${walletType} wallet?\n\n` +
                    `Features:\n` +
                    `‚Ä¢ AES-256-GCM encryption\n` +
                    `‚Ä¢ PBKDF2 key derivation (100,000 iterations)\n` +
                    `‚Ä¢ Password-protected storage\n` +
                    `‚Ä¢ Private keys never stored in plain text\n\n` +
                    `Click OK to set up encryption, Cancel to skip.`
                );
                
                if (!shouldEncrypt) return;
                
                const password = await promptPassword(
                    'Create a strong password for your encrypted wallet:\n(Minimum 8 characters)',
                    true // Confirm password
                );
                
                // Prepare wallet data for encryption
                const encryptionData = {
                    type: walletType,
                    address: walletData.address,
                    createdAt: Date.now(),
                    ...(walletType === 'regular' && {
                        privateKey: walletData.privateKey,
                        keypairData: walletData.keypair ? {
                            publicKey: walletData.keypair.getPublicKey().toSuiBytes(),
                            // Note: We'll reconstruct the keypair from private key on decrypt
                        } : null
                    }),
                    ...(walletType === 'zkLogin' && {
                        zkLoginInputs: walletData.zkLoginInputs,
                        provider: walletData.provider,
                        jwt: walletData.jwt
                    })
                };
                
                // Encrypt and store
                await vaultManager.storeEncryptedWallet(encryptionData, password);
                
                logOutput(`üîê ${walletType} wallet encrypted with enterprise-level security`);
                logOutput('üíæ Wallet can be restored using "Unlock Vault" button');
                
                // Update UI to show vault is available
                updateVaultUI();
                
            } catch (error) {
                if (error.message !== 'Password prompt cancelled' && 
                    error.message !== 'Password too short' &&
                    error.message !== 'Password confirmation failed') {
                    logOutput('Encryption error: ' + error.message, true);
                }
            }
        }
        
        // Check for encrypted vault on page load
        function checkEncryptedVault() {
            // Always show vault UI
            updateVaultUI();
            
            if (vaultManager.hasEncryptedVault()) {
                logOutput('üîê Encrypted wallet vault detected - click "Unlock Vault" to access');
            } else {
                logOutput('üí° Create an encrypted vault to securely store your wallets');
            }
        }
        
        // Update UI to show vault status
        function updateVaultUI() {
            const vaultSection = document.getElementById('vaultSection');
            const createVaultBtn = document.getElementById('createVaultBtn');
            
            if (vaultManager.hasEncryptedVault()) {
                // Show vault section and hide create vault button
                if (vaultSection) vaultSection.style.display = 'block';
                if (createVaultBtn) createVaultBtn.style.display = 'none';
            } else {
                // Show vault section with create option
                if (vaultSection) vaultSection.style.display = 'block';
                if (createVaultBtn) createVaultBtn.style.display = 'inline-block';
            }
        }
        
        // Unlock encrypted vault
        window.unlockVault = async function unlockVault() {
            try {
                const passwordInput = document.getElementById('vaultPasswordInput');
                const password = passwordInput.value.trim();
                
                if (!password) {
                    logOutput('Please enter your vault password', true);
                    return;
                }
                const walletData = await vaultManager.loadEncryptedWallet(password);
                
                logOutput(`üîì Vault unlocked - Loading ${walletData.type} wallet...`);
                
                if (walletData.type === 'regular') {
                    // Restore regular wallet
                    const restoredWallet = restoreWallet(walletData.privateKey);
                    currentWallet = { ...restoredWallet, fromVault: true };
                    
                    document.getElementById('currentAddress').textContent = currentWallet.address;
                    document.getElementById('walletInfo').style.display = 'block';
                    document.getElementById('zkLoginInfo').style.display = 'none';
                    
                    logOutput('‚úÖ Regular wallet restored from encrypted vault');
                    
                } else if (walletData.type === 'zkLogin') {
                    // Restore zkLogin wallet
                    const zkKeypair = createZkLoginKeypair({
                        ...walletData.zkLoginInputs,
                        derivedAddress: walletData.address
                    });
                    
                    const zkWallet = {
                        address: walletData.address,
                        type: 'zkLogin',
                        keypair: zkKeypair,
                        provider: walletData.provider,
                        zkLoginInputs: walletData.zkLoginInputs,
                        jwt: walletData.jwt,
                        fromVault: true
                    };
                    
                    currentWallet = zkWallet;
                    document.getElementById('currentAddress').textContent = zkWallet.address;
                    document.getElementById('walletInfo').style.display = 'block';
                    document.getElementById('zkLoginInfo').style.display = 'block';
                    document.getElementById('zkProvider').textContent = walletData.provider + ' (Vault)';
                    document.getElementById('zkUserId').textContent = walletData.zkLoginInputs.keyClaimValue;
                    
                    logOutput('‚úÖ zkLogin wallet restored from encrypted vault');
                }
                
                logOutput(`Address: ${walletData.address}`);
                
                // Clear password input and auto-fetch balance
                passwordInput.value = '';
                await getWalletBalance();
                
            } catch (error) {
                if (error.message !== 'Password prompt cancelled') {
                    logOutput('Vault unlock failed: ' + error.message, true);
                }
            }
        }
        
        // Create new encrypted vault
        window.createVault = async function createVault() {
            try {
                const passwordInput = document.getElementById('vaultPasswordInput');
                const password = passwordInput.value.trim();
                
                if (!password) {
                    logOutput('Please enter a password for your new vault', true);
                    return;
                }
                
                if (password.length < 8) {
                    logOutput('Password must be at least 8 characters long', true);
                    return;
                }
                
                // Create a new regular wallet to initialize the vault
                logOutput('üîê Creating encrypted vault with new wallet...');
                const wallet = createWallet();
                
                await vaultManager.saveEncryptedWallet({
                    type: 'regular',
                    address: wallet.address,
                    privateKey: wallet.privateKey
                }, password);
                
                currentWallet = { ...wallet, fromVault: true };
                document.getElementById('currentAddress').textContent = wallet.address;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'none';
                
                // Update UI to reflect vault creation
                updateVaultUI();
                
                logOutput('‚úÖ Encrypted vault created successfully!');
                logOutput(`Address: ${wallet.address}`);
                logOutput('üíæ Wallet encrypted and stored securely');
                
                // Clear password input and auto-fetch balance
                passwordInput.value = '';
                await getWalletBalance();
                
            } catch (error) {
                logOutput('Vault creation failed: ' + error.message, true);
            }
        }
        
        // Check cache when page loads
        waitForSDKs().then(() => {
            checkZkLoginCache();
            checkEncryptedVault();
        });
        
        // Helper functions from wallet-logic.ts (these would be imported in dev)
        window.createWallet = function() {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            const keypair = Ed25519Keypair.generate();
            const address = keypair.toSuiAddress();
            
            // Get private key - different methods in different SDK versions
            let privateKey;
            try {
                if (typeof keypair.getSecretKey === 'function') {
                    privateKey = keypair.getSecretKey();
                } else if (typeof keypair.export === 'function') {
                    privateKey = keypair.export().privateKey;
                } else if (keypair.privateKey) {
                    privateKey = keypair.privateKey;
                } else {
                    privateKey = 'Private key export not available';
                }
            } catch (e) {
                privateKey = 'Error getting private key: ' + e.message;
            }
            
            return { address, keypair, privateKey };
        };
        
        window.restoreWallet = function(privateKeyHex) {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            
            // Try different methods for creating keypair from private key
            let keypair;
            try {
                if (typeof Ed25519Keypair.fromSecretKey === 'function') {
                    keypair = Ed25519Keypair.fromSecretKey(privateKeyHex);
                } else if (typeof Ed25519Keypair.fromPrivateKey === 'function') {
                    keypair = Ed25519Keypair.fromPrivateKey(privateKeyHex);
                } else {
                    throw new Error('No method found to restore keypair from private key');
                }
            } catch (e) {
                throw new Error('Error restoring wallet: ' + e.message);
            }
            
            const address = keypair.toSuiAddress();
            return { address, keypair };
        };
        
        window.getBalance = async function(address, network = 'devnet') {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl } = window.SuiSDK.Sui;
            const client = new SuiClient({ url: getFullnodeUrl(network) });
            const balance = await client.getBalance({ owner: address });
            return Number(balance.totalBalance) / 1_000_000_000;
        };
        
        window.getWalletObjects = async function(address, network = 'devnet') {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl } = window.SuiSDK.Sui;
            const client = new SuiClient({ url: getFullnodeUrl(network) });
            const objects = await client.getOwnedObjects({
                owner: address,
                options: { showContent: true, showDisplay: true, showType: true }
            });
            return objects.data;
        };
        
        window.transferSui = async function(fromKeypair, toAddress, amount, network = 'devnet') {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl, Transaction, TransactionBlock } = window.SuiSDK.Sui;
            const client = new SuiClient({ url: getFullnodeUrl(network) });
            
            // Use Transaction or TransactionBlock depending on what's available
            const TxBuilder = Transaction || TransactionBlock;
            if (!TxBuilder) {
                throw new Error('No transaction builder available');
            }
            
            const txb = new TxBuilder();
            const coin = txb.splitCoins(txb.gas, [txb.pure(amount * 1_000_000_000)]);
            txb.transferObjects([coin], txb.pure(toAddress));
            
            // Try different signing methods
            if (typeof client.signAndExecuteTransaction === 'function') {
                return await client.signAndExecuteTransaction({
                    signer: fromKeypair,
                    transaction: txb
                });
            } else if (typeof client.signAndExecuteTransactionBlock === 'function') {
                return await client.signAndExecuteTransactionBlock({
                    signer: fromKeypair,
                    transactionBlock: txb
                });
            } else {
                throw new Error('No transaction signing method available');
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <h1>üîê vWallet - Sui Multichain Wallet</h1>
        
        <div class="section">
            <h3>Network Selection</h3>
            <select id="networkSelect" onchange="changeNetwork()">
                <option value="devnet">Devnet</option>
                <option value="testnet">Testnet</option>
                <option value="mainnet">Mainnet</option>
            </select>
        </div>
        
        <div class="section">
            <h3>Wallet Management</h3>
            <button onclick="createNewWallet()">Create New Wallet</button>
            <button onclick="loginWithZkLogin()">zkLogin (Google)</button>
            <button onclick="restoreZkLogin()" id="restoreZkLoginBtn" style="display:none;">Restore zkLogin</button>
            <br>
            <input type="text" id="privateKeyInput" placeholder="Enter private key to restore..." style="width: 300px;">
            <button onclick="restoreExistingWallet()">Restore Wallet</button>
        </div>

        <div class="section" id="vaultSection" style="display: none;">
            <h3>üîê Encrypted Vault</h3>
            <p>Your wallets and zkLogin data are encrypted and stored securely.</p>
            <input type="password" id="vaultPasswordInput" placeholder="Enter vault password..." style="width: 300px;">
            <button onclick="unlockVault()">Unlock Vault</button>
            <button onclick="createVault()" id="createVaultBtn" style="display: none;">Create Vault</button>
        </div>
        
        <div id="walletInfo" class="wallet-info" style="display: none;">
            <h4>Current Wallet</h4>
            <p><strong>Address:</strong> <span id="currentAddress"></span></p>
            <p><strong>Balance:</strong> <span id="currentBalance">Loading...</span></p>
            <div id="zkLoginInfo" style="display: none;">
                <p><strong>Type:</strong> zkLogin (Google OAuth)</p>
                <p><strong>Provider:</strong> <span id="zkProvider"></span></p>
                <p><strong>User ID:</strong> <span id="zkUserId"></span></p>
            </div>
        </div>
        
        <div class="section">
            <h3>Wallet Operations</h3>
            <button onclick="getWalletBalance()">Refresh Balance</button>
            <button onclick="getWalletNFTs()">Get Objects/NFTs</button>
        </div>
        
        <div class="section">
            <h3>Send Transaction</h3>
            <input type="text" id="toAddress" placeholder="Recipient address..." style="width: 300px;"><br>
            <input type="number" id="amount" placeholder="Amount (SUI)" step="0.000000001" min="0">
            <button onclick="sendSuiTransfer()">Send SUI</button>
        </div>
        
        <div class="section">
            <h3>Console Output</h3>
            <button onclick="clearOutput()">Clear Output</button>
            <div id="output">Wallet initialized. SDKs loading...</div>
        </div>
    </div>
</body>
</html>