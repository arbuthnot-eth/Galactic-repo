<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vWallet</title>
    <!-- Performance optimizations -->
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Dev favicon: served from assets; injector may override in prod -->
    <link rel="icon" type="image/png" href="assets/vw-favicon.png">
    <script>
        // Optimized favicon loading - defer until critical content loads
        window.addEventListener('load',function(){
            const link=document.querySelector('link[rel="icon"]');
            if(link&&link.href){
                window.getVWalletIconUrl=function(){return link.href};
                const styleEl=document.createElement('style');
                styleEl.id='vw-favicon-var';
                styleEl.textContent=`:root{--vw-favicon-url:url("${link.href}")}`;
                (document.body||document.head).appendChild(styleEl);
            }
        });
    </script>
    <!-- Critical CSS for immediate rendering -->
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #2c1810 0%, #4a2c2a 100%);
            color: #f4f1ef;
            min-height: 100vh;
        }
        .container {
            background: linear-gradient(145deg, #3d1a1a 0%, #722f37 100%);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            border: 1px solid rgba(139, 69, 19, 0.3);
        }
        h1 {
            color: #f4f1ef;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* Loading screen styles */
        .app-loading {
            text-align: center;
            margin-top: 50px;
            color: #e8d5c3;
        }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(139, 69, 19, 0.3);
            border-radius: 50%;
            border-top-color: #8B4513;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Loading screen transitions - very fast fade */
        #loading-screen {
            transition: opacity 0.1s ease-out;
        }
        
        /* Hide main content until loaded */
        .main-content {
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        .main-content.loaded {
            opacity: 1; /* Very brief fade-in */
        }

        /* Sections fade in smoothly */
        .section {
            margin:20px 0;padding:20px;border:1px solid rgba(139,69,19,.4);border-radius:10px;background:linear-gradient(145deg,rgba(60,20,20,.6),rgba(80,30,30,.6));backdrop-filter:blur(10px);display:none;opacity:0;transition:opacity .5s ease-in;
        }
        .section.visible {
            opacity: 1;
        }
        
        /* Critical elements - optimized */
        body,.container,h1{visibility:visible!important}
        .section h3{margin-top:0;color:#e8d5c3;text-shadow:0 1px 2px rgba(0,0,0,.3)}
        :root{--vw-favicon-url:initial}
        .vw-icon{display:inline-block;width:1em;height:1em;background-image:var(--vw-favicon-url);background-size:contain;background-repeat:no-repeat;vertical-align:-.15em}
        button{background:linear-gradient(145deg,#8B4513,#A0522D);color:#f4f1ef;border:none;padding:10px 20px;border-radius:8px;cursor:pointer;margin:5px;font-size:14px;transition:all .3s ease;box-shadow:0 3px 8px rgba(0,0,0,.3);border:1px solid rgba(160,82,45,.3)}
        button:hover{background:linear-gradient(145deg,#A0522D,#CD853F);transform:translateY(-1px);box-shadow:0 6px 12px rgba(0,0,0,.4)}
        button:disabled{background:rgba(139,69,19,.4);cursor:not-allowed;transform:none;color:rgba(244,241,239,.5)}
        .primary-btn{border-radius:12px;padding:15px 25px;font-size:16px;font-weight:600;box-shadow:0 6px 15px rgba(0,0,0,.25);border:1px solid rgba(139,69,19,.5);cursor:pointer;transition:all .3s ease;background:linear-gradient(145deg,#722F37,#8B4513)}
        .primary-btn:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,.35);background:linear-gradient(145deg,#8B4513,#A0522D)}
        input[type="text"],input[type="number"],input[type="password"]{padding:12px;border:1px solid rgba(139,69,19,.4);border-radius:8px;margin:5px;background:rgba(60,20,20,.3);color:#f4f1ef;backdrop-filter:blur(5px);font-size:14px}
        .copy-btn{margin:0 0 0 8px;padding:6px 10px;font-size:12px;line-height:1;border-radius:6px;background:rgba(139,69,19,.6);border:1px solid rgba(139,69,19,.5);box-shadow:none}
        .copy-btn:hover{background:rgba(160,82,45,.85)}
        .copy-btn:disabled{opacity:.6;cursor:not-allowed}
        .copy-btn[data-copied="true"]{background:#2e7d32;border-color:#2e7d32;color:#fff}
        .address-row,.address-display{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
        .address-value{font-family:'Courier New',monospace;font-size:13px;word-break:break-all}
        input[type="text"]:focus,input[type="number"]:focus,input[type="password"]:focus{outline:none;border-color:#A0522D;box-shadow:0 0 10px rgba(160,82,45,.3)}
        input::placeholder{color:rgba(244,241,239,.6)}
        #output{background:#2c3e50;color:#ecf0f1;padding:15px;border-radius:5px;font-family:'Courier New',monospace;font-size:12px;max-height:300px;overflow-y:auto;white-space:pre-wrap;margin-top:20px}
        .wallet-info{background:linear-gradient(145deg,#1f3b2f,#254836);border-left:4px solid #27ae60;padding:12px;margin:12px 0;border-radius:10px;color:#e6f2e6}
        .wallet-info strong{color:#f4fff4}
        .error{background:#fdf2f2;border-left:4px solid #e74c3c;padding:10px;margin:10px 0;color:#c0392b}
        
        .compatibility-dialog,.browser-warning,.device-warning{display:none!important;visibility:hidden!important;opacity:0!important;pointer-events:none!important}
    </style>
    
    <!-- BUNDLE_PLACEHOLDER -->
    <script>
        window.process={env:{NODE_ENV:'production'}};window.global=window.globalThis||window;document.addEventListener('DOMContentLoaded',function(){
            // Only hide the specific compatibility dialog, not Proton Pass itself
            const hideSpecificCompatibilityDialog = () => {
                // Look for the specific compatibility dialog that appears after closing Proton Pass
                const selectors = [
                    '[role="dialog"]',
                    '.dialog',
                    '.modal',
                    '[data-testid*="dialog"]',
                    '[aria-modal="true"]',
                    '.compatibility-dialog',
                    '.browser-warning',
                    '.device-warning'
                ];
                
                selectors.forEach(selector => {
                    document.querySelectorAll(selector).forEach(el => {
                        // Only hide if it contains the specific compatibility text
                        const text = el.textContent || '';
                        if (text.includes("can't be used") && 
                            text.includes("different kind of device") && 
                            (text.includes("electron") || text.includes("trycloud"))) {
                            el.style.display = 'none';
                            el.style.visibility = 'hidden';
                            el.style.opacity = '0';
                            el.style.pointerEvents = 'none';
                            console.log('Hidden compatibility dialog after Proton Pass close');
                        }
                    });
                });
            };
            
            // Set up mutation observer to catch the compatibility dialog when it appears
            if (window.MutationObserver) {
                const observer = new MutationObserver(() => {
                    // Small delay to catch dialogs that appear after other elements
                    setTimeout(hideSpecificCompatibilityDialog, 100);
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
            
            // Also check periodically but less frequently
            setTimeout(hideSpecificCompatibilityDialog, 1000);
            setTimeout(hideSpecificCompatibilityDialog, 3000);
        });
        
        // Override window.alert for specific compatibility warnings (not all alerts)
        const originalAlert = window.alert;
        window.alert = function(message) {
            if (typeof message === 'string' && 
                message.includes("can't be used") &&
                message.includes("different kind of device") &&
                (message.includes("electron") || message.includes("trycloud"))) {
                console.log('Suppressed specific compatibility alert:', message);
                return;
            }
            return originalAlert.apply(this, arguments);
        };
    </script>
    
    <script type="module">
        const HEX_ADDRESS_RE=/^0x[0-9a-fA-F]{2,}$/;
        let currentWallet=null,currentNetwork='devnet';
        const suinsResolutionCache = new Map();
        const suiClientCache = new Map();
        const suiClientPromiseCache = new Map();
        let bootstrapPromise = null;
        let mainContentRevealed = false;
        async function copyText(value){
            if(!value) return;
            if(navigator.clipboard&&navigator.clipboard.writeText){
                return navigator.clipboard.writeText(value);
            }
            const textarea=document.createElement('textarea');
            textarea.value=value;
            textarea.style.position='fixed';
            textarea.style.opacity='0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try{document.execCommand('copy');}
            finally{document.body.removeChild(textarea);}
        }
        function setupCopyButtons(){
            const buttons=document.querySelectorAll('.copy-btn');
            buttons.forEach(button=>{
                if(button.dataset.copySetup==='done') return;
                button.dataset.copySetup='done';
                if(!button.dataset.copyLabel){button.dataset.copyLabel=button.textContent.trim();}
                const targetId=button.dataset.copyTarget;
                const targetEl=targetId?document.getElementById(targetId):null;
                const getValue=()=>{
                    if(button.dataset.copyValue!==undefined){return (button.dataset.copyValue||'').trim();}
                    return targetEl?targetEl.textContent.trim():'';
                };
                if(!targetEl&&button.dataset.copyValue===undefined){button.disabled=true;return;}
                const updateState=()=>{button.disabled=!HEX_ADDRESS_RE.test(getValue());};
                button.addEventListener('click',async()=>{
                    const value=getValue();
                    if(!HEX_ADDRESS_RE.test(value)) return;
                    try{await copyText(value);button.dataset.copied='true';button.textContent='Copied ‚úì';setTimeout(()=>{button.textContent=button.dataset.copyLabel||'Copy';delete button.dataset.copied;},1200);}catch(e){console.warn('Copy failed',e);}
                });
                if(targetEl){
                    const observer=new MutationObserver(()=>{
                        if(button.dataset.copyValue===undefined){updateState();}
                    });
                    observer.observe(targetEl,{subtree:true,characterData:true,childList:true});
                }
                updateState();
            });
        }
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof window.requestIdleCallback === 'function') {
                window.requestIdleCallback(() => setupCopyButtons(), { timeout: 500 });
            } else {
                setTimeout(() => setupCopyButtons(), 0);
            }
        });
        function waitForSDKs(){return new Promise(r=>{window.SuiSDK?r():setTimeout(()=>waitForSDKs().then(r),100)})}
        function logOutput(e,t=!1){const n=document.getElementById('output'),o=t?'[ERROR]':'[INFO]',r=t?`\n${o} ${e}`:`${o} ${e}`;n.textContent+=`${r}\n`;n.scrollTop=n.scrollHeight}

        function normalizeHexIdentifier(value) {
            if (!value) return value;
            let normalized = value.trim().toLowerCase();
            if (!normalized.startsWith('0x')) normalized = `0x${normalized}`;
            try {
                const fn = window.SuiSDK?.Sui?.normalizeSuiAddress;
                if (typeof fn === 'function') {
                    return fn(normalized);
                }
            } catch (_) {}
            return normalized;
        }

        function isLikelySuinsName(value) {
            return typeof value === 'string' && value.includes('.') && !HEX_ADDRESS_RE.test(value.trim());
        }

        function getSuinsNetworkName(net) {
            return net === 'mainnet' ? 'mainnet' : 'testnet';
        }

        async function getSuiClient(network = currentNetwork, { force = false } = {}) {
            const netKey = network || currentNetwork;
            if (force) {
                suiClientCache.delete(netKey);
                suiClientPromiseCache.delete(netKey);
            }
            if (suiClientCache.has(netKey)) return suiClientCache.get(netKey);
            if (suiClientPromiseCache.has(netKey)) return suiClientPromiseCache.get(netKey);

            const promise = (async () => {
                await waitForSDKs();
                if (!window.SuiSDK?.Sui) throw new Error('Sui SDK not loaded');
                const { SuiClient, getFullnodeUrl } = window.SuiSDK.Sui;
                const client = new SuiClient({ url: getFullnodeUrl(netKey) });
                suiClientCache.set(netKey, client);
                return client;
            })().catch(error => {
                suiClientPromiseCache.delete(netKey);
                throw error;
            });

            suiClientPromiseCache.set(netKey, promise);
            return promise;
        }

        async function resolveSuinsRecord(name, { recordKey, network } = {}) {
            const trimmed = (name || '').trim();
            if (!trimmed) return null;
            const netAlias = getSuinsNetworkName(network || currentNetwork);
            const key = recordKey || 'target_address';
            const cacheKey = `${trimmed.toLowerCase()}::${netAlias}::${key}`;
            if (suinsResolutionCache.has(cacheKey)) return suinsResolutionCache.get(cacheKey);

            await waitForSDKs();
            const suinsNs = window.SuiSDK?.SuiNS;
            if (!suinsNs || !suinsNs.SuinsClient) throw new Error('SuiNS client unavailable in current SDK bundle');

            const clientNetwork = network || netAlias;
            const client = await getSuiClient(clientNetwork);
            const { SuinsClient } = suinsNs;
            const suins = new SuinsClient({ client, network: netAlias });
            const record = await suins.getNameRecord(trimmed);
            const data = record && record.data ? record.data : {};
            const candidates = [];
            if (recordKey) candidates.push(data[recordKey]);
            candidates.push(
                data.target_address,
                data.targetAddress,
                data.address,
                data.owner,
                data.owner_address,
                record?.ownerAddress,
                record?.target_address
            );

            const resolved = candidates.find(val => typeof val === 'string' && HEX_ADDRESS_RE.test(val.trim()));
            const result = resolved ? { resolved: normalizeHexIdentifier(resolved), record } : { resolved: null, record };
            suinsResolutionCache.set(cacheKey, result);
            return result;
        }

        async function resolveAddressInput(rawValue, { label = 'address', recordKey, allowEmpty = false, silent = false } = {}) {
            const value = (rawValue || '').trim();
            if (!value) {
                if (allowEmpty) {
                    return { ok: true, value: '', source: 'empty', input: value };
                }
                return { ok: false, message: `${label} is required`, input: value };
            }

            if (HEX_ADDRESS_RE.test(value)) {
                const normalized = normalizeHexIdentifier(value);
                return { ok: true, value: normalized, source: 'direct', input: value };
            }

            if (!isLikelySuinsName(value)) {
                return { ok: false, message: `${label} must be a 0x... identifier or valid SuiNS name`, input: value };
            }

            try {
                const record = await resolveSuinsRecord(value, { recordKey });
                if (record && record.resolved) {
                    if (!silent) logOutput(`Resolved ${label} ${value} ‚ûú ${record.resolved}`);
                    return { ok: true, value: record.resolved, source: 'suins', input: value, record: record.record };
                }
                return { ok: false, message: `SuiNS name ${value} does not include a ${recordKey || 'target address'} record`, input: value };
            } catch (error) {
                if (!silent) logOutput(`SuiNS lookup failed for ${value}: ${error.message}`, true);
                return { ok: false, message: `Failed to resolve ${value}: ${error.message}`, input: value, error };
            }
        }

        function ensureAppBootstrap(force = false) {
            if (force) {
                bootstrapPromise = null;
                suinsResolutionCache.clear();
                suiClientCache.clear();
                suiClientPromiseCache.clear();
            }

            if (!bootstrapPromise) {
                bootstrapPromise = (async () => {
                    await waitForSDKs();
                    try { checkZkLoginCache(); } catch (error) { console.warn('zkLogin cache check failed', error); }
                    try { checkPasskeyCache(); } catch (error) { console.warn('Passkey cache check failed', error); }
                    try { await getSuiClient(currentNetwork, { force }); } catch (error) { console.warn('RPC warmup warning', error); }
                    return true;
                })().catch(error => {
                    bootstrapPromise = null;
                    logOutput('Bootstrap failed: ' + error.message, true);
                    throw error;
                });
            }

            return bootstrapPromise;
        }

        function revealMainContent(loadingScreen, mainContent) {
            if (mainContentRevealed) return;
            mainContentRevealed = true;

            if (mainContent) {
                mainContent.style.display = 'block';
                requestAnimationFrame(() => {
                    const allSections = document.querySelectorAll('.section');
                    allSections.forEach(section => {
                        section.style.display = 'block';
                        section.classList.add('visible');
                    });
                    mainContent.classList.add('loaded');
                });
            }

            if (loadingScreen) {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 140);
            }
        }


        async function createNewWallet(){try{logOutput('Creating new wallet...');const e=createWallet();currentWallet=e;document.getElementById('currentAddress').textContent=e.address;document.getElementById('walletInfo').style.display='block';document.getElementById('zkLoginInfo').style.display='none';logOutput('Wallet created successfully!');logOutput(`Address: ${e.address}`);await getWalletBalance()}catch(e){logOutput('Error creating wallet: '+e.message,!0)}}
        
        async function restoreExistingWallet(){const e=document.getElementById('privateKeyInput').value.trim();if(!e){logOutput('Please enter a private key',!0);return}try{logOutput('Restoring wallet from private key...');const t=restoreWallet(e);currentWallet=t;document.getElementById('currentAddress').textContent=t.address;document.getElementById('walletInfo').style.display='block';document.getElementById('zkLoginInfo').style.display='none';logOutput('Wallet restored successfully!');logOutput(`Address: ${t.address}`);await getWalletBalance()}catch(e){logOutput('Error restoring wallet: '+e.message,!0)}}
        
        async function getWalletBalance() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            try {
                logOutput(`Getting balance for ${currentWallet.address}...`);
                const balance = await getBalance(currentWallet.address, currentNetwork);
                document.getElementById('currentBalance').textContent = `${balance} SUI`;
            } catch (error) {
                logOutput('Error getting balance: ' + error.message, true);
            }
        }
        
        async function getWalletNFTs() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            try {
                logOutput('Getting wallet objects/NFTs...');
                const objects = await getWalletObjects(currentWallet.address, currentNetwork);
                logOutput(`Found ${objects.length} objects in wallet`);
                
                objects.forEach((obj, index) => {
                    logOutput(`Object ${index + 1}: ${obj.data?.type || 'Unknown type'}`);
                });
            } catch (error) {
                logOutput('Error getting wallet objects: ' + error.message, true);
            }
        }
        
        async function sendSuiTransfer() {
            if (!currentWallet) {
                logOutput('No wallet selected', true);
                return;
            }
            
            const toAddressInput = document.getElementById('toAddress').value.trim();
            const amount = parseFloat(document.getElementById('amount').value);
            
            if (!toAddressInput || !amount || amount <= 0) {
                logOutput('Please enter valid recipient address and amount', true);
                return;
            }
            
            try {
                const resolvedRecipient = await resolveAddressInput(toAddressInput, { label: 'Recipient address' });
                if (!resolvedRecipient.ok) {
                    logOutput(resolvedRecipient.message, true);
                    return;
                }

                const toAddress = resolvedRecipient.value;
                logOutput(`Sending ${amount} SUI to ${resolvedRecipient.input || toAddress}...`);
                if (resolvedRecipient.source === 'suins') {
                    logOutput(`Resolved recipient ${resolvedRecipient.input} ‚ûú ${toAddress}`);
                }
                
                let result;
                if (currentWallet.type === 'passkey') {
                    // For passkey wallets, use the passkey for signing
                    logOutput('üì± Please use your biometric to sign the transaction...');
                    result = await transferSui(currentWallet.keypair, toAddress, amount, currentNetwork);
                } else if (currentWallet.type === 'zkLogin') {
                    // Regular zkLogin
                    result = await transferSuiZkLogin(currentWallet, toAddress, amount, currentNetwork);
                } else {
                    // Regular Ed25519 wallet
                    result = await transferSui(currentWallet.keypair, toAddress, amount, currentNetwork);
                }
                
                logOutput(`Transfer successful! Transaction: ${result.digest}`);
                
                // Refresh balance
                await getWalletBalance();
            } catch (error) {
                logOutput('Error sending transfer: ' + error.message, true);
            }
        }
        
        function changeNetwork() {
            const networkSelect = document.getElementById('networkSelect');
            currentNetwork = networkSelect.value;
            logOutput(`Network changed to: ${currentNetwork}`);
            ensureAppBootstrap(true).then(() => {
                if (currentWallet) {
                    getWalletBalance();
                }
            }).catch(error => {
                logOutput(`Failed to switch client: ${error.message}`, true);
            });
        }
        
        function clearOutput() {
            document.getElementById('output').textContent = '';
        }
        
        // zkLogin configuration
        const ZKLOGIN_CONFIG = {
            // Google OAuth configuration  
            GOOGLE_CLIENT_ID: '373405271144-kevesn5h18jt8grqh5cel7jcsu9si73t.apps.googleusercontent.com',
            GOOGLE_REDIRECT_URI: window.location.origin + '/auth/callback.html',
            // Random nonce for security (should be stored and verified)
            NONCE: 'zklogin_' + Math.random().toString(36).substring(2, 15),
        };

        // zkLogin functionality with popup-based OAuth
        async function loginWithZkLogin() {
            try {
                logOutput('Starting zkLogin with Google...');
                
                if (!window.SuiSDK.ZkLogin) {
                    throw new Error('zkLogin not available in current SDK');
                }
                
                logOutput('Step 1: Opening Google OAuth popup...');
                
                // Step 1: Get OAuth URL
                const authUrl = buildGoogleAuthUrl();

                // Step 2: Open popup and wait for token
                const jwt = await openOAuthPopup(authUrl);
                
                if (!jwt) {
                    throw new Error('Failed to get JWT token from OAuth');
                }
                
                logOutput('Step 2: JWT token received');
                
                // Step 3: Parse and validate JWT
                const jwtPayload = parseJWT(jwt);
                validateJWT(jwtPayload); // Validate the JWT
                logOutput('‚úÖ JWT validation successful');
                
                // Step 4: Generate zkLogin proof
                logOutput('Step 3: Generating zkLogin proof...');
                const zkLoginInputs = await generateZkLoginInputs(jwt, jwtPayload);
                
                // Step 5: Derive Sui address
                const suiAddress = await deriveSuiAddress(zkLoginInputs);
                
                // Step 6: Create wallet object with zkLogin keypair
                const zkKeypair = createZkLoginKeypair({ ...zkLoginInputs, derivedAddress: suiAddress });
                
                const zkWallet = {
                    address: suiAddress,
                    type: 'zkLogin',
                    jwt: jwt,
                    zkLoginInputs: zkLoginInputs,
                    keypair: zkKeypair,
                    provider: 'Google'
                };
                
                currentWallet = zkWallet;
                document.getElementById('currentAddress').textContent = zkWallet.address;
                document.getElementById('walletInfo').style.display = 'block';
                
                // Show zkLogin specific info
                document.getElementById('zkLoginInfo').style.display = 'block';
                document.getElementById('zkProvider').textContent = zkWallet.provider;
                document.getElementById('zkUserId').textContent = jwtPayload.sub;
                
                // Cache zkLogin data for future use
                const cacheData = {
                    address: suiAddress,
                    issuer: zkLoginInputs.issuer,
                    keyClaimValue: zkLoginInputs.keyClaimValue,
                    salt: zkLoginInputs.salt,
                    provider: 'Google',
                    cachedAt: Date.now()
                };
                
                localStorage.setItem('zkLoginCache', JSON.stringify(cacheData));
                
                logOutput('‚úÖ zkLogin successful!');
                logOutput('Address: ' + suiAddress);
                logOutput('üì± zkLogin data cached for future sessions');
                
                
                // Auto-fetch balance
                await getWalletBalance();
                
            } catch (error) {
                logOutput('zkLogin error: ' + error.message, true);
                console.error('zkLogin error details:', error);
            }
        }
        
        // Build Google OAuth URL
        function buildGoogleAuthUrl() {
            const params = new URLSearchParams({
                client_id: ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID,
                redirect_uri: window.location.origin + '/auth/callback.html',
                response_type: 'id_token', // Get JWT directly
                scope: 'openid email profile',
                nonce: ZKLOGIN_CONFIG.NONCE,
                state: 'zklogin_state'
            });
            
            return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
        }
        
        // Open OAuth popup and wait for result
        async function openOAuthPopup(authUrl) {
            return new Promise((resolve, reject) => {
                
                const popup = window.open(
                    authUrl,
                    'zklogin_oauth',
                    'width=500,height=600,scrollbars=yes,resizable=yes'
                );
                
                if (!popup) {
                    reject(new Error('Failed to open popup - please allow popups'));
                    return;
                }
                
                // Listen for postMessage from the callback page
                const messageHandler = (event) => {
                    // Verify origin for security
                    if (event.origin !== window.location.origin) {
                        return;
                    }
                    
                    if (event.data.type === 'zklogin_oauth_success') {
                        window.removeEventListener('message', messageHandler);
                        clearInterval(checkClosed);
                        logOutput('‚úÖ OAuth successful');
                        resolve(event.data.idToken);
                    } else if (event.data.type === 'zklogin_oauth_error') {
                        window.removeEventListener('message', messageHandler);
                        clearInterval(checkClosed);
                        reject(new Error('OAuth error: ' + event.data.error));
                    }
                };
                
                window.addEventListener('message', messageHandler);
                
                // Check if popup was closed
                const checkClosed = setInterval(() => {
                    if (popup.closed) {
                        clearInterval(checkClosed);
                        window.removeEventListener('message', messageHandler);
                        reject(new Error('OAuth popup was closed by user'));
                    }
                }, 1000);
            });
        }
        
        // Create demo JWT for testing (in production, this comes from OAuth provider)
        function createDemoJWT() {
            const header = btoa(JSON.stringify({
                alg: 'RS256',
                typ: 'JWT',
                kid: 'demo'
            }));
            
            const payload = btoa(JSON.stringify({
                iss: 'https://accounts.google.com',
                sub: 'demo_user_12345',
                aud: ZKLOGIN_CONFIG.GOOGLE_CLIENT_ID,
                email: 'demo@example.com',
                nonce: ZKLOGIN_CONFIG.NONCE,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            }));
            
            const signature = 'demo_signature';
            
            return `${header}.${payload}.${signature}`;
        }
        
        // Parse JWT token
        function parseJWT(jwt) {
            try {
                const parts = jwt.split('.');
                if (parts.length !== 3) {
                    throw new Error('Invalid JWT format');
                }
                
                const payload = JSON.parse(atob(parts[1]));
                return payload;
            } catch (error) {
                throw new Error('Failed to parse JWT: ' + error.message);
            }
        }
        
        // Validate JWT (basic validation for demo)
        function validateJWT(jwtPayload) {
            const now = Math.floor(Date.now() / 1000);
            
            // Check expiration
            if (jwtPayload.exp && jwtPayload.exp < now) {
                throw new Error('JWT token has expired');
            }
            
            // Check issued at time
            if (jwtPayload.iat && jwtPayload.iat > now + 60) {
                throw new Error('JWT token issued in the future');
            }
            
            // Check issuer
            if (!jwtPayload.iss) {
                throw new Error('JWT token missing issuer');
            }
            
            // Check nonce (in production, compare with stored nonce)
            if (!jwtPayload.nonce) {
                throw new Error('JWT token missing nonce');
            }
            
            return true;
        }
        
        // Generate zkLogin inputs (simplified for demo)
        async function generateZkLoginInputs(jwt, jwtPayload) {
            try {
                // Validate JWT first
                validateJWT(jwtPayload);
                
                // Extract required fields for zkLogin
                const issuer = jwtPayload.iss;
                const keyClaimName = 'sub'; // Use 'sub' claim for user identification
                const keyClaimValue = jwtPayload.sub;
                const audience = jwtPayload.aud;
                
                // Generate deterministic salt from user identity (same user = same salt)
                const userIdentity = `${issuer}:${keyClaimValue}`;
                const identityHash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(userIdentity));
                const saltBytes = new Uint8Array(identityHash).slice(0, 16); // Take first 16 bytes
                const salt = Array.from(saltBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                
                
                // In a real implementation, you would:
                // 1. Get the zkLogin proving service endpoint
                // 2. Submit the JWT and get a zero-knowledge proof
                // 3. This involves complex cryptographic operations
                
                // For demo, create mock zkLogin inputs
                const zkLoginInputs = {
                    jwt,
                    jwtPayload,
                    issuer,
                    keyClaimName,
                    keyClaimValue,
                    audience,
                    salt,
                    // Mock proof data (real implementation would generate actual ZK proof)
                    proof: {
                        a: ['0x' + salt.substring(0, 64)],
                        b: [['0x01', '0x02'], ['0x03', '0x04']],
                        c: ['0x' + salt.substring(0, 64)]
                    },
                    addressSeed: keyClaimValue + '_' + salt
                };

                return zkLoginInputs;
                
            } catch (error) {
                throw new Error('Failed to generate zkLogin inputs: ' + error.message);
            }
        }
        
        // Derive Sui address from zkLogin inputs
        async function deriveSuiAddress(zkLoginInputs) {
            try {
                // In real implementation, you would use:
                // const address = await window.SuiSDK.ZkLogin.computeZkLoginAddress(zkLoginInputs);
                
                // For demo, create a deterministic address based on user identity
                const addressSeed = zkLoginInputs.keyClaimValue + '_' + zkLoginInputs.salt;
                const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(addressSeed));
                const hashArray = Array.from(new Uint8Array(hash));
                const addressBytes = hashArray.slice(0, 32); // Take first 32 bytes
                
                // Create a Sui address format (0x + 64 hex chars)
                const suiAddress = '0x' + addressBytes.map(b => b.toString(16).padStart(2, '0')).join('');
                

                return suiAddress;
                
            } catch (error) {
                throw new Error('Failed to derive Sui address: ' + error.message);
            }
        }
        
        // Create zkLogin keypair for signing (mock implementation)
        function createZkLoginKeypair(zkLoginInputs) {
            // In real implementation, this would create a proper zkLogin keypair
            // that can sign transactions using the zero-knowledge proof
            
            return {
                getPublicKey: () => ({
                    toSuiAddress: () => zkLoginInputs.derivedAddress,
                    toSuiBytes: () => new Uint8Array(33) // Mock public key bytes
                }),
                signPersonalMessage: async (message) => {
                    // Mock signing - real implementation would use ZK proof
                    const signature = new Uint8Array(64);
                    crypto.getRandomValues(signature);
                    return Array.from(signature);
                },
                signTransactionBlock: async (txb) => {
                    // Mock transaction signing
                    throw new Error('zkLogin transaction signing requires full implementation with ZK proving service');
                },
                type: 'zkLogin',
                zkLoginInputs
            };
        }
        
        // Make functions available globally
        window.createNewWallet = createNewWallet;
        window.restoreExistingWallet = restoreExistingWallet;
        window.getWalletBalance = getWalletBalance;
        window.getWalletNFTs = getWalletNFTs;
        window.sendSuiTransfer = sendSuiTransfer;
        window.changeNetwork = changeNetwork;
        window.clearOutput = clearOutput;
        window.loginWithZkLogin = loginWithZkLogin;
        window.restoreZkLogin = restoreZkLogin;
        
        // Restore zkLogin from cached data
        async function restoreZkLogin() {
            try {
                const cachedData = JSON.parse(localStorage.getItem('zkLoginCache'));
                if (!cachedData) {
                    throw new Error('No cached zkLogin data found');
                }
                
                // Check if cache is still valid (24 hours)
                const cacheAge = Date.now() - cachedData.cachedAt;
                if (cacheAge > 24 * 60 * 60 * 1000) {
                    localStorage.removeItem('zkLoginCache');
                    document.getElementById('restoreZkLoginBtn').style.display = 'none';
                    throw new Error('Cached zkLogin data expired (older than 24 hours)');
                }
                
                logOutput('Restoring zkLogin from cached data...');
                
                // Create zkLogin wallet from cached data
                const zkKeypair = createZkLoginKeypair({
                    issuer: cachedData.issuer,
                    keyClaimValue: cachedData.keyClaimValue,
                    salt: cachedData.salt,
                    derivedAddress: cachedData.address
                });
                
                const zkWallet = {
                    address: cachedData.address,
                    type: 'zkLogin',
                    keypair: zkKeypair,
                    provider: cachedData.provider,
                    fromCache: true
                };
                
                currentWallet = zkWallet;
                document.getElementById('currentAddress').textContent = zkWallet.address;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'block';
                document.getElementById('zkProvider').textContent = cachedData.provider + ' (Cached)';
                document.getElementById('zkUserId').textContent = cachedData.keyClaimValue;
                
                logOutput('‚úÖ zkLogin restored from cache!');
                logOutput('Address: ' + cachedData.address);
                logOutput('‚ö†Ô∏è Note: Transactions will require fresh OAuth');
                
                // Auto-fetch balance
                await getWalletBalance();
                
            } catch (error) {
                logOutput('Error restoring zkLogin: ' + error.message, true);
            }
        }
        
        // Check for cached zkLogin on page load
        function checkZkLoginCache() {
            const cachedData = localStorage.getItem('zkLoginCache');
            if (cachedData) {
                try {
                    const data = JSON.parse(cachedData);
                    const cacheAge = Date.now() - data.cachedAt;
                    if (cacheAge < 24 * 60 * 60 * 1000) {
                        document.getElementById('restoreZkLoginBtn').style.display = 'inline-block';
                    } else {
                        localStorage.removeItem('zkLoginCache');
                    }
                } catch (e) {
                    localStorage.removeItem('zkLoginCache');
                }
            }
        }
        
        
        // vWallet Smart Contract Functions
        
        // Deploy vWallet smart contract with permanent address
        async function deployVWalletContract(firstPasskey) {
            try {
                logOutput('üìã Preparing vWallet contract deployment...');
                
                // Initialize Sui client
                // Note: Using deterministic address derivation for minimal demo; no on-chain deploy here.
                
                // Get the public key from the first passkey
                const publicKey = firstPasskey.getPublicKey();
                const publicKeyBytes = publicKey.toRawBytes();
                
                logOutput('üéØ Creating permanent vWallet address...');
                
                // Create a transaction to deploy the vWallet smart contract
                // No transaction needed for the minimal demo
                
                // For now, we'll use a simple approach where the vWallet address 
                // is derived from the first passkey's public key
                // In production, this would deploy an actual Move smart contract
                
                // Derive a deterministic address from the first passkey
                const addressSeed = new Uint8Array([...publicKeyBytes, ...new TextEncoder().encode('vWallet_v1')]);
                const addressHash = await crypto.subtle.digest('SHA-256', addressSeed);
                const addressBytes = new Uint8Array(addressHash).slice(0, 32);
                
                // Convert to Sui address format
                const permanentAddress = '0x' + Array.from(addressBytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                
                logOutput('‚ú® vWallet permanent address: ' + permanentAddress);
                
                // Create vWallet contract object
                const vWalletContract = {
                    address: permanentAddress,
                    version: '1.0.0',
                    deployedAt: Date.now(),
                    deployedBy: publicKey.toSuiAddress(),
                    authorizedSigners: [publicKey.toSuiAddress()],
                    
                    // Contract methods for multi-signer authorization
                    addSigner: async function(newSignerAddress, authorizingKeypair) {
                        logOutput('üîê Adding new authorized signer: ' + newSignerAddress);
                        // In production, this would call the smart contract
                        this.authorizedSigners.push(newSignerAddress);
                        return true;
                    },
                    
                    removeSigner: async function(signerAddress, authorizingKeypair) {
                        logOutput('üóëÔ∏è Removing authorized signer: ' + signerAddress);
                        // In production, this would call the smart contract
                        const index = this.authorizedSigners.indexOf(signerAddress);
                        if (index > 0) { // Keep first signer (owner)
                            this.authorizedSigners.splice(index, 1);
                            return true;
                        }
                        return false;
                    },
                    
                    isAuthorized: function(signerAddress) {
                        return this.authorizedSigners.includes(signerAddress);
                    }
                };
                
                logOutput('üéâ vWallet smart contract deployed successfully!');
                logOutput('üîó Permanent address: ' + permanentAddress);
                
                return vWalletContract;
                
            } catch (error) {
                logOutput('‚ùå Contract deployment failed: ' + error.message, true);
                throw error;
            }
        }
        
        window.createVWallet = async function createVWallet() {
            try {
                logOutput('üç∑ Creating your premium vWallet...');
                
                if (!window.SuiSDK?.Sui?.PasskeyKeypair) {
                    throw new Error('Passkey support not available - please use a modern browser');
                }

                // Ensure we are in a secure context; passkeys require trusted HTTPS
                if (!window.isSecureContext) {
                    logOutput('‚ùå This page is not a secure context (HTTPS/trusted).', true);
                    logOutput('üí° Passkeys require a trusted HTTPS origin. Use Cloudflare Tunnel (npm run tunnel-dev) or deploy on a domain with valid certificate.', true);
                    throw new Error('Insecure context - passkeys require trusted HTTPS');
                }

                const { PasskeyKeypair, BrowserPasskeyProvider } = window.SuiSDK.Sui;
                
                // Create passkey with browser provider (localhost-friendly config)
                const hostname = window.location.hostname;
                const isLocalhost = hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1' || hostname.endsWith('.localhost') || hostname === '';
                
                // Compute RP ID: use configured domain for passkeys
                const rpIdComputed = isLocalhost
                    ? undefined
                    : (window.VWALLET_RP_ID || ((hostname === 'vwallet.red' || hostname.endsWith('.vwallet.red'))
                        ? 'vwallet.red'
                        : hostname));

                const passkeyProvider = new BrowserPasskeyProvider('vWallet Premium', {
                    rpName: 'vWallet - Premium Smart Wallet',
                    ...(rpIdComputed ? { rpId: rpIdComputed } : {}),
                    authenticatorSelection: {
                        authenticatorAttachment: 'platform',
                        userVerification: 'preferred',
                        residentKey: 'preferred',
                        requireResidentKey: false
                    },
                    pubKeyCredParams: [
                        { alg: -7, type: "public-key" },   // ES256 (secp256r1)
                        { alg: -257, type: "public-key" }  // RS256
                    ]
                });
                
                logOutput('üîë Please authenticate with your passkey to create your vWallet...');
                
                // Create passkey using the Sui provider first (more robust across environments)
                let firstPasskey;
                try {
                    if (typeof PublicKeyCredential !== 'undefined' && PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable) {
                        const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
                        logOutput('Platform authenticator available: ' + available);
                    }
                    firstPasskey = await PasskeyKeypair.getPasskeyInstance(passkeyProvider);
                    logOutput('Debug: Passkey created successfully');
                } catch (passkeyError) {
                    logOutput('Passkey creation detailed error: ' + passkeyError.message, true);
                    if (String(passkeyError.message || '').includes('InsecureLocalhostNotAllowed')) {
                        logOutput('üîí Your browser considers this localhost origin insecure.', true);
                        logOutput('‚úÖ Fix: Use Cloudflare Tunnel (npm run tunnel-dev) or deploy on a domain with valid certificate.', true);
                    }
                    if (passkeyError.name === 'NotAllowedError') {
                        logOutput('User cancelled the passkey creation or it timed out', true);
                    } else if (passkeyError.name === 'NotSupportedError') {
                        logOutput('Passkeys not supported on this device/browser', true);
                    } else if (passkeyError.name === 'SecurityError') {
                        logOutput('Security error - may need HTTPS or different origin', true);
                    }
                    throw passkeyError;
                }
                
                // Deploy vWallet smart contract with permanent address
                logOutput('üèóÔ∏è Deploying your vWallet smart contract...');
                const vWalletContract = await deployVWalletContract(firstPasskey);
                
                const vWallet = {
                    address: vWalletContract.address,     // Permanent vWallet address
                    contract: vWalletContract,            // Smart contract instance
                    type: 'vWallet',
                    
                    authorizedSigners: {
                        passkeys: [{
                            name: 'Primary Device',
                            publicKey: firstPasskey.getPublicKey().toRawBytes(),
                            keypair: firstPasskey,
                            active: true,
                            addedAt: Date.now()
                        }],
                        zkLogins: []
                    }
                };
                
                // No browser storage persistence ‚Äî all state derives from passkey
                const publicKeyBytes = firstPasskey.getPublicKey().toRawBytes();
                logOutput(`Debug: Created vWallet with ${publicKeyBytes.length} byte public key`);
                
                currentWallet = {
                    address: vWalletContract.address,
                    type: 'vWallet',
                    keypair: firstPasskey,
                    contract: vWalletContract,
                    vWallet: vWallet,
                    fromPasskey: true
                };
                
                document.getElementById('currentAddress').textContent = vWalletContract.address;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'none';
                
                // Ensure connect button is visible
                const connectBtn = document.getElementById('connectPasskeyBtn');
                if (connectBtn) connectBtn.style.display = 'inline-block';
                
                logOutput('üéâ vWallet created successfully!');
                logOutput(`üç∑ Your permanent vWallet address: ${vWalletContract.address}`);
                logOutput('üí´ You can now access your vWallet instantly with your passkey on any device');
                
                // Auto-fetch balance
                await getWalletBalance();
                
            } catch (error) {
                logOutput('üç∑ vWallet creation failed: ' + error.message, true);
                
                // Offer Ed25519 fallback for development/testing
                logOutput('');
                logOutput('üîÑ Would you like to create a vWallet with traditional keypair instead?');
                logOutput('üìù Note: This is for development only. Passkeys will work on a proper domain.');
                
                // Show fallback button
                const fallbackBtn = document.createElement('button');
                fallbackBtn.textContent = 'üîë Create vWallet with Keypair (Dev Mode)';
                fallbackBtn.className = 'primary-btn';
                fallbackBtn.style.marginTop = '15px';
                fallbackBtn.style.width = '100%';
                fallbackBtn.onclick = createVWalletWithKeypair;
                
                const container = document.querySelector('.container');
                container.appendChild(fallbackBtn);
            }
        };
        
        // Fallback vWallet creation with Ed25519 keypair for development
        window.createVWalletWithKeypair = async function createVWalletWithKeypair() {
            try {
                logOutput('üç∑ Creating vWallet with traditional keypair...');
                
                if (!window.SuiSDK?.Sui?.Ed25519Keypair) {
                    throw new Error('Ed25519Keypair not available');
                }
                
                const { Ed25519Keypair } = window.SuiSDK.Sui;
                
                // Generate Ed25519 keypair
                logOutput('üîë Generating secure keypair...');
                const keypair = Ed25519Keypair.generate();
                const publicKey = keypair.getPublicKey();
                const address = keypair.toSuiAddress();
                
                // Create mock vWallet contract for the keypair
                logOutput('üèóÔ∏è Deploying vWallet smart contract...');
                const vWalletContract = {
                    address: address,
                    version: '1.0.0-dev',
                    deployedAt: Date.now(),
                    deployedBy: address,
                    authorizedSigners: [address],
                    type: 'keypair', // Mark as development keypair
                    
                    addSigner: async function(newSignerAddress, authorizingKeypair) {
                        logOutput('üîê Adding new authorized signer: ' + newSignerAddress);
                        this.authorizedSigners.push(newSignerAddress);
                        return true;
                    },
                    
                    isAuthorized: function(signerAddress) {
                        return this.authorizedSigners.includes(signerAddress);
                    }
                };
                
                // Store vWallet info
                const vWalletInfo = {
                    address: address,
                    contractAddress: address,
                    type: 'vWallet-dev',
                    keypairType: 'Ed25519',
                    createdAt: Date.now(),
                    version: '1.0.0-dev',
                    // Store the private key for dev mode (NOT recommended for production)
                    privateKey: Array.from(keypair.getSecretKey())
                };
                
                localStorage.setItem('vWallet', JSON.stringify(vWalletInfo));
                
                currentWallet = {
                    address: address,
                    type: 'vWallet-dev',
                    keypair: keypair,
                    contract: vWalletContract,
                    fromKeypair: true
                };
                
                document.getElementById('currentAddress').textContent = address;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'none';
                
                logOutput('üéâ vWallet created successfully (Dev Mode)!');
                logOutput(`üç∑ Your vWallet address: ${address}`);
                logOutput('üí° This uses traditional cryptography - passkeys will work on a proper domain');
                
                // Hide the fallback button
                const fallbackBtn = document.querySelector('button[onclick="createVWalletWithKeypair"]');
                if (fallbackBtn) {
                    fallbackBtn.style.display = 'none';
                }
                
                // Ensure connect button is visible
                const connectBtn2 = document.getElementById('connectPasskeyBtn');
                if (connectBtn2) connectBtn2.style.display = 'inline-block';
                
                // Auto-fetch balance
                await getWalletBalance();
                
            } catch (error) {
                logOutput('‚ùå Keypair vWallet creation failed: ' + error.message, true);
            }
        };
        
        window.loginWithPasskey = async function loginWithPasskey() {
            try {
                logOutput('üç∑ Accessing your vWallet securely...');
                
                if (!window.SuiSDK?.Sui?.PasskeyKeypair) {
                    throw new Error('Passkey authentication not available - please use a modern browser');
                }

                if (!window.isSecureContext) {
                    logOutput('‚ùå Not a secure context - passkey login needs trusted HTTPS.', true);
                    logOutput('üí° Use Cloudflare Tunnel (npm run tunnel-dev) or deploy on a domain with valid certificate.', true);
                    throw new Error('Insecure context - passkeys require trusted HTTPS');
                }
                
                const { PasskeyKeypair, BrowserPasskeyProvider } = window.SuiSDK.Sui;
                
                // Create provider for login (localhost-friendly)
                const hostname = window.location.hostname;
                const isLocalhost = hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1' || hostname.endsWith('.localhost') || hostname === '';
                
                const passkeyProvider = new BrowserPasskeyProvider('vWallet', {
                    rpName: 'vWallet - Premium Smart Wallet',
                    ...(isLocalhost
                        ? {}
                        : ((hostname === 'vwallet.red' || hostname.endsWith('.vwallet.red'))
                            ? { rpId: 'vwallet.red' }
                            : { rpId: hostname })),
                    authenticatorSelection: {
                        userVerification: 'preferred'
                    }
                });
                
                logOutput('üîë Please authenticate with your passkey to access your vWallet...');

                // Attempt to obtain the passkey keypair directly (single prompt)
                let keypair;
                try {
                    keypair = await PasskeyKeypair.getPasskeyInstance(passkeyProvider);
                } catch (e) {
                    // Fallback: recover via two-signature method
                    logOutput('Direct passkey access failed, attempting recovery...', true);
                    const msg1 = new TextEncoder().encode('vWallet Recovery Message 1');
                    const msg2 = new TextEncoder().encode('vWallet Recovery Message 2');
                    const pks1 = await PasskeyKeypair.signAndRecover(passkeyProvider, msg1);
                    const pks2 = await PasskeyKeypair.signAndRecover(passkeyProvider, msg2);
                    let recovered = null;
                    for (const pk1 of pks1) {
                        for (const pk2 of pks2) {
                            if (pk1.toSuiAddress() === pk2.toSuiAddress()) {
                                recovered = pk1;
                                break;
                            }
                        }
                        if (recovered) break;
                    }
                    if (!recovered) throw new Error('Could not recover public key');
                    const pkBytes = recovered.toRawBytes();
                    keypair = new PasskeyKeypair(pkBytes, passkeyProvider);
                }

                const publicKeyBytes = keypair.getPublicKey().toRawBytes();
                const addressSeed = new Uint8Array([...publicKeyBytes, ...new TextEncoder().encode('vWallet_v1')]);
                const addressHash = await crypto.subtle.digest('SHA-256', addressSeed);
                const addressBytes = new Uint8Array(addressHash).slice(0, 32);
                const permanentAddress = '0x' + Array.from(addressBytes).map(b => b.toString(16).padStart(2, '0')).join('');

                // Construct minimal contract-like object
                const vWalletContract = {
                    address: permanentAddress,
                    version: '1.0.0',
                    deployedAt: Date.now(),
                    deployedBy: keypair.getPublicKey().toSuiAddress(),
                    authorizedSigners: [keypair.getPublicKey().toSuiAddress()],
                    type: 'vWallet',
                    addSigner: async function(newSignerAddress) {
                        this.authorizedSigners.push(newSignerAddress);
                        return true;
                    },
                    isAuthorized: function(signerAddress) {
                        return this.authorizedSigners.includes(signerAddress);
                    }
                };

                currentWallet = {
                    address: permanentAddress,
                    type: 'vWallet',
                    keypair: keypair,
                    contract: vWalletContract,
                    fromPasskey: true
                };

                document.getElementById('currentAddress').textContent = permanentAddress;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'none';
                
                logOutput('üéâ Welcome back to your vWallet!');
                logOutput(`üç∑ Connected to: ${permanentAddress}`);
                
                // Auto-fetch balance
                await getWalletBalance();
                
            } catch (error) {
                logOutput('üç∑ vWallet access failed: ' + error.message, true);
            }
        };
        
        
        // Disconnect wallet function
        window.disconnectWallet = function disconnectWallet() {
            try {
                const confirmDisconnect = confirm(
                    'üö™ Disconnect Wallet\n\n' +
                    'This will:\n' +
                    '‚Ä¢ Clear your wallet from browser storage\n' +
                    '‚Ä¢ Remove cached data\n' +
                    
                    '‚Ä¢ Reset the interface\n\n' +
                    'Your actual wallet and funds remain safe.\n' +
                    'Your passkey contains everything needed to reconnect.\n\n' +
                    'Continue with disconnect?'
                );
                
                if (!confirmDisconnect) return;
                
                // Clear any legacy cached data (compat only)
                try { localStorage.removeItem('vWallet'); } catch {}
                try { localStorage.removeItem('passkeyWallet'); } catch {}
                try { localStorage.removeItem('zkLoginCache'); } catch {}
                
                try { localStorage.removeItem('vWallet_reconnection'); } catch {}
                
                // Reset wallet state
                currentWallet = null;
                
                // Hide wallet info and reset UI
                document.getElementById('walletInfo').style.display = 'none';
                const passkeyLoginBtn = document.getElementById('passkeyLoginBtn');
                if (passkeyLoginBtn) passkeyLoginBtn.style.display = 'none';
                document.getElementById('restoreZkLoginBtn').style.display = 'none';
                
                // Clear form inputs
                document.getElementById('toAddress').value = '';
                document.getElementById('amount').value = '';
                
                logOutput('üö™ Wallet disconnected successfully');
                logOutput('üíæ All cached data cleared from browser');
                logOutput('üîë Use "Connect with Passkey" to reconnect - your passkey has everything needed!');
                
                // UI reset complete
                
            } catch (error) {
                logOutput('Error disconnecting wallet: ' + error.message, true);
            }
        };
        
        // Connect with passkey function
        window.connectWalletWithPasskey = async function connectWalletWithPasskey() {
            try {
                logOutput('üîó Connecting with existing passkey...');
                
                if (!navigator.credentials || !window.PublicKeyCredential) {
                    throw new Error('WebAuthn not supported in this browser');
                }

                if (!window.isSecureContext) {
                    logOutput('‚ùå Not a secure context - passkeys need trusted HTTPS.', true);
                    logOutput('üí° Use Cloudflare Tunnel (npm run tunnel-dev) or deploy on a domain with valid certificate.', true);
                    throw new Error('Insecure context - passkeys require trusted HTTPS');
                }
                
                const hostname = window.location.hostname;
                const rpId = (hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1' || hostname.endsWith('.localhost') || hostname === '')
                  ? undefined
                  : ((hostname === 'vwallet.red' || hostname.endsWith('.vwallet.red')) ? 'vwallet.red' : hostname);
                
                logOutput('üîë Please select and authenticate with your existing vWallet passkey...');
                logOutput('üí° This will show you available passkeys to choose from');
                
                // Use WebAuthn API directly to authenticate with existing credentials
                const authenticationOptions = {
                    publicKey: {
                        challenge: crypto.getRandomValues(new Uint8Array(32)),
                        timeout: 60000,
                        rpId: rpId,
                        userVerification: 'preferred',
                        authenticatorSelection: {
                            authenticatorAttachment: 'platform',
                            userVerification: 'preferred'
                        }
                        // Note: No allowCredentials specified - this allows selecting from available passkeys
                    }
                };
                
                let credential;
                try {
                    credential = await navigator.credentials.get(authenticationOptions);
                    logOutput('‚úÖ Passkey authentication successful');
                } catch (authError) {
                    logOutput('Passkey authentication failed: ' + authError.message, true);
                    if (authError.name === 'NotAllowedError') {
                        logOutput('‚ùå Authentication was cancelled or no passkeys found', true);
                    } else if (authError.name === 'NotSupportedError') {
                        logOutput('‚ùå Passkeys not supported on this device/browser', true);
                    }
                    throw authError;
                }
                
                if (!credential) {
                    throw new Error('No credential returned from authentication');
                }
                
                // Extract the credential ID and try to match with stored wallets
                const credentialId = Array.from(new Uint8Array(credential.rawId));
                logOutput(`üîç Found credential ID: ${credentialId.length} bytes`);
                
                // Check if we already have active wallet data
                let storedWallet = localStorage.getItem('vWallet') || localStorage.getItem('passkeyWallet');
                
                if (storedWallet) {
                    // If we have active wallet data, use existing login method
                    logOutput('üìã Found cached wallet data, authenticating...');
                    await loginWithPasskey();
                    return;
                }
                
                // No stored wallet data ‚Äî use Sui SDK's passkey recovery (no browser storage)
                logOutput('üîç No cached wallet data, recovering public key from passkey...');
                logOutput('üîß Using Sui SDK passkey recovery method...');
                
                if (!window.SuiSDK?.Sui?.PasskeyKeypair) {
                    throw new Error('Passkey SDK components not available');
                }
                
                const { PasskeyKeypair, BrowserPasskeyProvider } = window.SuiSDK.Sui;
                
                // Create a passkey provider for recovery
                const passkeyProvider = new BrowserPasskeyProvider('vWallet Recovery', {
                    rpName: 'vWallet - Recover Existing Wallet',
                    ...(rpId ? { rpId } : {}),
                    authenticatorSelection: {
                        userVerification: 'preferred'
                    }
                });
                
                logOutput('üîê Recovering your wallet with two signatures...');
                logOutput('üì± Please authenticate twice to recover your public key');
                
                // Use Sui SDK's signAndRecover method - two signature approach
                const testMessage1 = new TextEncoder().encode('vWallet Recovery Message 1');
                const testMessage2 = new TextEncoder().encode('vWallet Recovery Message 2');
                
                logOutput('üîë Signature 1/2: Please authenticate...');
                const possiblePks1 = await PasskeyKeypair.signAndRecover(passkeyProvider, testMessage1);
                
                logOutput('üîë Signature 2/2: Please authenticate again...');
                const possiblePks2 = await PasskeyKeypair.signAndRecover(passkeyProvider, testMessage2);
                
                // Find the common public key between the two results
                let recoveredPublicKey = null;
                for (const pk1 of possiblePks1) {
                    for (const pk2 of possiblePks2) {
                        if (pk1.toSuiAddress() === pk2.toSuiAddress()) {
                            recoveredPublicKey = pk1;
                            break;
                        }
                    }
                    if (recoveredPublicKey) break;
                }
                
                if (!recoveredPublicKey) {
                    throw new Error('Could not recover public key - signatures did not match');
                }
                
                // Derive the same permanent vWallet address used at creation
                const publicKeyBytes = recoveredPublicKey.toRawBytes();
                logOutput('‚úÖ Public key recovered successfully!');
                logOutput(`üîç Recovered signer address: ${recoveredPublicKey.toSuiAddress()}`);

                // Deterministically derive vWallet permanent address from public key (matches deployVWalletContract)
                const addressSeed = new Uint8Array([...publicKeyBytes, ...new TextEncoder().encode('vWallet_v1')]);
                const addressHash = await crypto.subtle.digest('SHA-256', addressSeed);
                const addressBytes = new Uint8Array(addressHash).slice(0, 32);
                const permanentAddress = '0x' + Array.from(addressBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                logOutput(`üîç Reconstructed vWallet address: ${permanentAddress}`);

                // Create the keypair with recovered public key
                const keypair = new PasskeyKeypair(publicKeyBytes, passkeyProvider);

                // Recreate vWallet contract object
                const vWalletContract = {
                    address: permanentAddress,
                    version: '1.0.0',
                    deployedAt: Date.now(),
                    deployedBy: recoveredPublicKey.toSuiAddress(),
                    authorizedSigners: [recoveredPublicKey.toSuiAddress()],
                    addSigner: async function(newSignerAddress, authorizingKeypair) {
                        logOutput('üîê Adding new authorized signer: ' + newSignerAddress);
                        this.authorizedSigners.push(newSignerAddress);
                        return true;
                    },
                    isAuthorized: function(signerAddress) {
                        return this.authorizedSigners.includes(signerAddress);
                    }
                };

                // Create wallet from recovered passkey (consistent permanent address)
                currentWallet = {
                    address: permanentAddress,
                    type: 'vWallet',
                    keypair: keypair,
                    contract: vWalletContract,
                    fromPasskeyRecover: true
                };

                // Update UI
                document.getElementById('currentAddress').textContent = permanentAddress;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('zkLoginInfo').style.display = 'none';
                const connectBtn3 = document.getElementById('connectPasskeyBtn');
                if (connectBtn3) connectBtn3.style.display = 'inline-block';
                
                logOutput('üéâ Wallet recovered and connected successfully!');
                logOutput(`üç∑ Connected to: ${permanentAddress}`);
                logOutput('üíæ Wallet info cached for future access');
                
                // Auto-fetch balance
                await getWalletBalance();
                return;
                
            } catch (error) {
                logOutput('üîó Passkey connection failed: ' + error.message, true);
            }
        };
        
        
        
        // Check for existing vWallets and passkey wallets
        function checkPasskeyCache() {
            // No reliance on browser storage; always enable passkey access
            const connectBtn = document.getElementById('connectPasskeyBtn');
            if (connectBtn) connectBtn.style.display = 'inline-block';
            logOutput('üç∑ vWallet Passkey detected. Welcome back');
        }
        
        // App initialization and loading management
        function initializeApp() {
            const loadingScreen = document.getElementById('loading-screen');
            const mainContent = document.getElementById('main-content');

            if (loadingScreen) {
                loadingScreen.style.display = 'block';
                loadingScreen.style.opacity = '1';
            }
            if (mainContent) {
                mainContent.style.display = 'none';
                requestAnimationFrame(() => {
                    if (!mainContentRevealed) {
                        mainContent.style.display = 'block';
                        const allSections = document.querySelectorAll('.section');
                        allSections.forEach(section => { section.style.display = 'block'; });
                    }
                });
            }

            const bootstrap = ensureAppBootstrap();
            const revealFallback = setTimeout(() => revealMainContent(loadingScreen, mainContent), 160);

            bootstrap.then(() => {
                clearTimeout(revealFallback);
                revealMainContent(loadingScreen, mainContent);
            }).catch(() => {
                revealMainContent(loadingScreen, mainContent);
            });
        }
        
        // Initialize immediately when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
        
        // Helper wallet functions
        window.createWallet = function() {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            const keypair = Ed25519Keypair.generate();
            const address = keypair.toSuiAddress();
            
            // Get private key - different methods in different SDK versions
            let privateKey;
            try {
                if (typeof keypair.getSecretKey === 'function') {
                    privateKey = keypair.getSecretKey();
                } else if (typeof keypair.export === 'function') {
                    privateKey = keypair.export().privateKey;
                } else if (keypair.privateKey) {
                    privateKey = keypair.privateKey;
                } else {
                    privateKey = 'Private key export not available';
                }
            } catch (e) {
                privateKey = 'Error getting private key: ' + e.message;
            }
            
            return { address, keypair, privateKey };
        };
        
        window.restoreWallet = function(privateKeyHex) {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { Ed25519Keypair } = window.SuiSDK.Sui;
            
            // Try different methods for creating keypair from private key
            let keypair;
            try {
                if (typeof Ed25519Keypair.fromSecretKey === 'function') {
                    keypair = Ed25519Keypair.fromSecretKey(privateKeyHex);
                } else if (typeof Ed25519Keypair.fromPrivateKey === 'function') {
                    keypair = Ed25519Keypair.fromPrivateKey(privateKeyHex);
                } else {
                    throw new Error('No method found to restore keypair from private key');
                }
            } catch (e) {
                throw new Error('Error restoring wallet: ' + e.message);
            }
            
            const address = keypair.toSuiAddress();
            return { address, keypair };
        };
        
        window.getBalance = async function(address, network = 'devnet') {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl } = window.SuiSDK.Sui;
            const client = new SuiClient({ url: getFullnodeUrl(network) });
            const balance = await client.getBalance({ owner: address });
            return Number(balance.totalBalance) / 1_000_000_000;
        };
        
        window.getWalletObjects = async function(address, network = 'devnet') {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl } = window.SuiSDK.Sui;
            const client = new SuiClient({ url: getFullnodeUrl(network) });
            const objects = await client.getOwnedObjects({
                owner: address,
                options: { showContent: true, showDisplay: true, showType: true }
            });
            return objects.data;
        };
        
        window.transferSui = async function(fromKeypair, toAddress, amount, network = 'devnet') {
            if (!window.SuiSDK) throw new Error('SDK not loaded');
            const { SuiClient, getFullnodeUrl, Transaction, TransactionBlock } = window.SuiSDK.Sui;
            const client = new SuiClient({ url: getFullnodeUrl(network) });
            
            // Use Transaction or TransactionBlock depending on what's available
            const TxBuilder = Transaction || TransactionBlock;
            if (!TxBuilder) {
                throw new Error('No transaction builder available');
            }
            
            const txb = new TxBuilder();
            const coin = txb.splitCoins(txb.gas, [txb.pure(amount * 1_000_000_000)]);
            txb.transferObjects([coin], txb.pure(toAddress));
            
            // Try different signing methods
            if (typeof client.signAndExecuteTransaction === 'function') {
                return await client.signAndExecuteTransaction({
                    signer: fromKeypair,
                    transaction: txb
                });
            } else if (typeof client.signAndExecuteTransactionBlock === 'function') {
                return await client.signAndExecuteTransactionBlock({
                    signer: fromKeypair,
                    transactionBlock: txb
                });
            } else {
                throw new Error('No transaction signing method available');
            }
        };
    </script>
</head>
<body>
    <!-- Loading screen shown immediately -->
    <div class="container" id="loading-screen">
        <h1><span class="vw-icon" aria-hidden="true"></span> vWallet</h1>
        <div class="app-loading">
            <p>Loading your premium wallet experience...</p>
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- Main content hidden until app is ready -->
    <div class="container main-content" id="main-content">
        <h1><span class="vw-icon" aria-hidden="true"></span> vWallet</h1>
        <p style="text-align: center; color: #e8d5c3; font-size: 16px; margin-top: -10px; margin-bottom: 30px;">
            Premium smart wallet with permanent address
        </p>
        
        <div class="section">
            <h3>Network Selection</h3>
            <select id="networkSelect" onchange="changeNetwork()">
                <option value="devnet">Devnet</option>
                <option value="testnet">Testnet</option>
                <option value="mainnet">Mainnet</option>
            </select>
        </div>
        
        <div class="section">
            <h3>üç∑ Welcome to vWallet</h3>
            <p style="color: #e8d5c3; margin-bottom: 25px;">Your premium smart wallet with permanent address. Access with passkeys from any device.</p>
            
            <!-- Primary Passkey Actions -->
            <div style="margin-bottom: 30px;">
                <button onclick="createVWallet()" class="primary-btn" style="background: linear-gradient(135deg, #722F37 0%, #8B4513 100%); width: 100%; margin-bottom: 15px; font-size: 16px; font-weight: 600;">
                    üç∑ Create vWallet
                </button>
                <p style="font-size: 12px; color: #e8d5c3; text-align: center; margin: 0;">Premium smart wallet with passkey security</p>
                
                <button onclick="connectWalletWithPasskey()" id="connectPasskeyBtn" class="primary-btn" style="background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%); width: 100%; margin-top: 15px; font-size: 16px; font-weight: 600;">
                    üîó Connect with Passkey
                </button>
                <p style="font-size: 12px; color: #e8d5c3; text-align: center; margin: 5px 0 0 0;">Connect using your passkey (no browser storage needed)</p>
            </div>
            
            <!-- Enhanced Security Options -->
                
                <button onclick="loginWithZkLogin()" style="background: #4285f4; color: white; margin-top: 15px;">
                    üåê Login with Google (zkLogin)
                </button>
                <button onclick="restoreZkLogin()" id="restoreZkLoginBtn" style="display:none; background: #4285f4; color: white; margin-left: 10px;">
                    ‚Üª Restore Google Login
                </button>
            </div>
            
            <!-- Advanced/Legacy Options -->
            <details style="margin-top: 25px; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px;">
                <summary style="cursor: pointer; font-weight: 600; color: #666; font-size: 13px;">‚öôÔ∏è Advanced Options</summary>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #f0f0f0;">
                    <p style="color: #888; font-size: 12px; margin-bottom: 15px;">
                        <strong>‚ö†Ô∏è Expert Mode:</strong> For users with existing wallets or specific requirements
                    </p>
                    <button onclick="createNewWallet()" style="background: #6c757d; font-size: 14px;">
                        ‚ö° Create Traditional Wallet
                    </button>
                    <br>
                    <input type="text" id="privateKeyInput" placeholder="Import private key or seed phrase..." style="width: 100%; margin-top: 10px; font-size: 14px; padding: 8px;">
                    <button onclick="restoreExistingWallet()" style="background: #6c757d; margin-top: 10px; font-size: 14px;">
                        üì• Import Existing Wallet
                    </button>
                    <p style="color: #999; font-size: 11px; margin-top: 10px;">
                        Traditional wallets require manual backup and seed phrase management
                    </p>
                </div>
            </details>
        </div>

        
        
        <div id="walletInfo" class="wallet-info" style="display: none;">
            <h4>Current Wallet</h4>
            <p class="address-row"><strong>Address:</strong>
                <span id="currentAddress" class="address-value"></span>
                <button type="button" class="copy-btn" data-copy-target="currentAddress" aria-label="Copy address" title="Copy address">Copy</button>
            </p>
            <p><strong>Balance:</strong> <span id="currentBalance">Loading...</span></p>
            <div id="zkLoginInfo" style="display: none;">
                <p><strong>Type:</strong> zkLogin (Google OAuth)</p>
                <p><strong>Provider:</strong> <span id="zkProvider"></span></p>
                <p><strong>User ID:</strong> <span id="zkUserId"></span></p>
            </div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                <button onclick="disconnectWallet()" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white; padding: 8px 16px; border: none; border-radius: 6px; font-size: 13px; cursor: pointer;">
                    üö™ Disconnect Wallet
                </button>
                <p style="font-size: 11px; color: #999; margin-top: 5px;">This resets the UI; reconnect with your passkey anytime</p>
            </div>
        </div>
        
        <div class="section">
            <h3>Wallet Operations</h3>
            <button onclick="getWalletBalance()">Refresh Balance</button>
            <button onclick="getWalletNFTs()">Get Objects/NFTs</button>
        </div>
        
        <div class="section">
            <h3>Send Transaction</h3>
            <input type="text" id="toAddress" placeholder="Recipient address..." style="width: 300px;"><br>
            <input type="number" id="amount" placeholder="Amount (SUI)" step="0.000000001" min="0">
            <button onclick="sendSuiTransfer()">Send SUI</button>
        </div>
        
        <div class="section">
            <h3>Console Output</h3>
            <button onclick="clearOutput()">Clear Output</button>
            <div id="output">Welcome to vWallet

</div>
        </div>
    </div>
</body>
</html>
